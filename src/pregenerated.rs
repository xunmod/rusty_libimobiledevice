// jkcoxson
// Danger: this file was NOT generated at run time and could be out of date
// Choke on this, rust-analyzer (https://github.com/rust-analyzer/rust-analyzer/issues/9720)

pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const GNUTLS_VERSION: &[u8; 6usize] = b"3.7.3\0";
pub const GNUTLS_VERSION_MAJOR: u32 = 3;
pub const GNUTLS_VERSION_MINOR: u32 = 7;
pub const GNUTLS_VERSION_PATCH: u32 = 3;
pub const GNUTLS_VERSION_NUMBER: u32 = 198403;
pub const GNUTLS_MAX_ALGORITHM_NUM: u32 = 64;
pub const GNUTLS_MAX_SESSION_ID_SIZE: u32 = 32;
pub const GNUTLS_SERVER: u32 = 1;
pub const GNUTLS_CLIENT: u32 = 2;
pub const GNUTLS_DATAGRAM: u32 = 4;
pub const GNUTLS_NONBLOCK: u32 = 8;
pub const GNUTLS_NO_EXTENSIONS: u32 = 16;
pub const GNUTLS_NO_REPLAY_PROTECTION: u32 = 32;
pub const GNUTLS_NO_SIGNAL: u32 = 64;
pub const GNUTLS_ALLOW_ID_CHANGE: u32 = 128;
pub const GNUTLS_ENABLE_FALSE_START: u32 = 256;
pub const GNUTLS_FORCE_CLIENT_CERT: u32 = 512;
pub const GNUTLS_NO_TICKETS: u32 = 1024;
pub const GNUTLS_ENABLE_CERT_TYPE_NEG: u32 = 0;
pub const GNUTLS_KU_PEER: u32 = 1;
pub const GNUTLS_SIGN_FLAG_SECURE_FOR_CERTS: u32 = 1;
pub const GNUTLS_HEARTBEAT_WAIT: u32 = 1;
pub const GNUTLS_RECORD_WAIT: u32 = 1;
pub const GNUTLS_HB_PEER_ALLOWED_TO_SEND: u32 = 1;
pub const GNUTLS_HB_PEER_NOT_ALLOWED_TO_SEND: u32 = 2;
pub const GNUTLS_HB_LOCAL_ALLOWED_TO_SEND: u32 = 4;
pub const GNUTLS_PRIORITY_INIT_DEF_APPEND: u32 = 1;
pub const GNUTLS_PRIORITY_LIST_INIT_KEYWORDS: u32 = 1;
pub const GNUTLS_PRIORITY_LIST_SPECIAL: u32 = 2;
pub const GNUTLS_MAX_SESSION_ID: u32 = 32;
pub const GNUTLS_HOOK_POST: u32 = 1;
pub const GNUTLS_HOOK_PRE: u32 = 0;
pub const GNUTLS_HOOK_BOTH: i32 = -1;
pub const GNUTLS_OCSP_SR_IS_AVAIL: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const GNUTLS_IDNA_FORCE_2008: u32 = 2;
pub const GNUTLS_KEY_DIGITAL_SIGNATURE: u32 = 128;
pub const GNUTLS_KEY_NON_REPUDIATION: u32 = 64;
pub const GNUTLS_KEY_KEY_ENCIPHERMENT: u32 = 32;
pub const GNUTLS_KEY_DATA_ENCIPHERMENT: u32 = 16;
pub const GNUTLS_KEY_KEY_AGREEMENT: u32 = 8;
pub const GNUTLS_KEY_KEY_CERT_SIGN: u32 = 4;
pub const GNUTLS_KEY_CRL_SIGN: u32 = 2;
pub const GNUTLS_KEY_ENCIPHER_ONLY: u32 = 1;
pub const GNUTLS_KEY_DECIPHER_ONLY: u32 = 32768;
pub const GNUTLS_SCOMMIT_FLAG_ALLOW_BROKEN: u32 = 1;
pub const GNUTLS_UTF8_IGNORE_ERRS: u32 = 1;
pub const GNUTLS_EXT_RAW_FLAG_TLS_CLIENT_HELLO: u32 = 1;
pub const GNUTLS_EXT_RAW_FLAG_DTLS_CLIENT_HELLO: u32 = 2;
pub const GNUTLS_FIPS140_SET_MODE_THREAD: u32 = 1;
pub const GNUTLS_E_SUCCESS: u32 = 0;
pub const GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM: i32 = -3;
pub const GNUTLS_E_UNKNOWN_CIPHER_TYPE: i32 = -6;
pub const GNUTLS_E_LARGE_PACKET: i32 = -7;
pub const GNUTLS_E_UNSUPPORTED_VERSION_PACKET: i32 = -8;
pub const GNUTLS_E_UNEXPECTED_PACKET_LENGTH: i32 = -9;
pub const GNUTLS_E_INVALID_SESSION: i32 = -10;
pub const GNUTLS_E_FATAL_ALERT_RECEIVED: i32 = -12;
pub const GNUTLS_E_UNEXPECTED_PACKET: i32 = -15;
pub const GNUTLS_E_WARNING_ALERT_RECEIVED: i32 = -16;
pub const GNUTLS_E_ERROR_IN_FINISHED_PACKET: i32 = -18;
pub const GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET: i32 = -19;
pub const GNUTLS_E_UNKNOWN_CIPHER_SUITE: i32 = -21;
pub const GNUTLS_E_UNWANTED_ALGORITHM: i32 = -22;
pub const GNUTLS_E_MPI_SCAN_FAILED: i32 = -23;
pub const GNUTLS_E_DECRYPTION_FAILED: i32 = -24;
pub const GNUTLS_E_MEMORY_ERROR: i32 = -25;
pub const GNUTLS_E_DECOMPRESSION_FAILED: i32 = -26;
pub const GNUTLS_E_COMPRESSION_FAILED: i32 = -27;
pub const GNUTLS_E_AGAIN: i32 = -28;
pub const GNUTLS_E_EXPIRED: i32 = -29;
pub const GNUTLS_E_DB_ERROR: i32 = -30;
pub const GNUTLS_E_KEYFILE_ERROR: i32 = -31;
pub const GNUTLS_E_INSUFFICIENT_CREDENTIALS: i32 = -32;
pub const GNUTLS_E_INSUFICIENT_CREDENTIALS: i32 = -32;
pub const GNUTLS_E_INSUFFICIENT_CRED: i32 = -32;
pub const GNUTLS_E_INSUFICIENT_CRED: i32 = -32;
pub const GNUTLS_E_HASH_FAILED: i32 = -33;
pub const GNUTLS_E_BASE64_DECODING_ERROR: i32 = -34;
pub const GNUTLS_E_MPI_PRINT_FAILED: i32 = -35;
pub const GNUTLS_E_REHANDSHAKE: i32 = -37;
pub const GNUTLS_E_GOT_APPLICATION_DATA: i32 = -38;
pub const GNUTLS_E_RECORD_LIMIT_REACHED: i32 = -39;
pub const GNUTLS_E_ENCRYPTION_FAILED: i32 = -40;
pub const GNUTLS_E_PK_ENCRYPTION_FAILED: i32 = -44;
pub const GNUTLS_E_PK_DECRYPTION_FAILED: i32 = -45;
pub const GNUTLS_E_PK_SIGN_FAILED: i32 = -46;
pub const GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION: i32 = -47;
pub const GNUTLS_E_KEY_USAGE_VIOLATION: i32 = -48;
pub const GNUTLS_E_NO_CERTIFICATE_FOUND: i32 = -49;
pub const GNUTLS_E_INVALID_REQUEST: i32 = -50;
pub const GNUTLS_E_SHORT_MEMORY_BUFFER: i32 = -51;
pub const GNUTLS_E_INTERRUPTED: i32 = -52;
pub const GNUTLS_E_PUSH_ERROR: i32 = -53;
pub const GNUTLS_E_PULL_ERROR: i32 = -54;
pub const GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER: i32 = -55;
pub const GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE: i32 = -56;
pub const GNUTLS_E_PKCS1_WRONG_PAD: i32 = -57;
pub const GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION: i32 = -58;
pub const GNUTLS_E_INTERNAL_ERROR: i32 = -59;
pub const GNUTLS_E_DH_PRIME_UNACCEPTABLE: i32 = -63;
pub const GNUTLS_E_FILE_ERROR: i32 = -64;
pub const GNUTLS_E_TOO_MANY_EMPTY_PACKETS: i32 = -78;
pub const GNUTLS_E_UNKNOWN_PK_ALGORITHM: i32 = -80;
pub const GNUTLS_E_TOO_MANY_HANDSHAKE_PACKETS: i32 = -81;
pub const GNUTLS_E_RECEIVED_DISALLOWED_NAME: i32 = -82;
pub const GNUTLS_E_CERTIFICATE_REQUIRED: i32 = -112;
pub const GNUTLS_E_NO_TEMPORARY_RSA_PARAMS: i32 = -84;
pub const GNUTLS_E_NO_COMPRESSION_ALGORITHMS: i32 = -86;
pub const GNUTLS_E_NO_CIPHER_SUITES: i32 = -87;
pub const GNUTLS_E_OPENPGP_GETKEY_FAILED: i32 = -88;
pub const GNUTLS_E_PK_SIG_VERIFY_FAILED: i32 = -89;
pub const GNUTLS_E_ILLEGAL_SRP_USERNAME: i32 = -90;
pub const GNUTLS_E_KEYFILE_PARSING_ERROR: i32 = -91;
pub const GNUTLS_E_NO_TEMPORARY_DH_PARAMS: i32 = -93;
pub const GNUTLS_E_ASN1_ELEMENT_NOT_FOUND: i32 = -67;
pub const GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND: i32 = -68;
pub const GNUTLS_E_ASN1_DER_ERROR: i32 = -69;
pub const GNUTLS_E_ASN1_VALUE_NOT_FOUND: i32 = -70;
pub const GNUTLS_E_ASN1_GENERIC_ERROR: i32 = -71;
pub const GNUTLS_E_ASN1_VALUE_NOT_VALID: i32 = -72;
pub const GNUTLS_E_ASN1_TAG_ERROR: i32 = -73;
pub const GNUTLS_E_ASN1_TAG_IMPLICIT: i32 = -74;
pub const GNUTLS_E_ASN1_TYPE_ANY_ERROR: i32 = -75;
pub const GNUTLS_E_ASN1_SYNTAX_ERROR: i32 = -76;
pub const GNUTLS_E_ASN1_DER_OVERFLOW: i32 = -77;
pub const GNUTLS_E_OPENPGP_UID_REVOKED: i32 = -79;
pub const GNUTLS_E_CERTIFICATE_ERROR: i32 = -43;
pub const GNUTLS_E_X509_CERTIFICATE_ERROR: i32 = -43;
pub const GNUTLS_E_CERTIFICATE_KEY_MISMATCH: i32 = -60;
pub const GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE: i32 = -61;
pub const GNUTLS_E_X509_UNKNOWN_SAN: i32 = -62;
pub const GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED: i32 = -94;
pub const GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE: i32 = -95;
pub const GNUTLS_E_UNKNOWN_HASH_ALGORITHM: i32 = -96;
pub const GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE: i32 = -97;
pub const GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE: i32 = -98;
pub const GNUTLS_E_INVALID_PASSWORD: i32 = -99;
pub const GNUTLS_E_MAC_VERIFY_FAILED: i32 = -100;
pub const GNUTLS_E_CONSTRAINT_ERROR: i32 = -101;
pub const GNUTLS_E_WARNING_IA_IPHF_RECEIVED: i32 = -102;
pub const GNUTLS_E_WARNING_IA_FPHF_RECEIVED: i32 = -103;
pub const GNUTLS_E_IA_VERIFY_FAILED: i32 = -104;
pub const GNUTLS_E_UNKNOWN_ALGORITHM: i32 = -105;
pub const GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM: i32 = -106;
pub const GNUTLS_E_SAFE_RENEGOTIATION_FAILED: i32 = -107;
pub const GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED: i32 = -108;
pub const GNUTLS_E_UNKNOWN_SRP_USERNAME: i32 = -109;
pub const GNUTLS_E_PREMATURE_TERMINATION: i32 = -110;
pub const GNUTLS_E_MALFORMED_CIDR: i32 = -111;
pub const GNUTLS_E_BASE64_ENCODING_ERROR: i32 = -201;
pub const GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY: i32 = -202;
pub const GNUTLS_E_INCOMPATIBLE_CRYPTO_LIBRARY: i32 = -202;
pub const GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY: i32 = -203;
pub const GNUTLS_E_OPENPGP_KEYRING_ERROR: i32 = -204;
pub const GNUTLS_E_X509_UNSUPPORTED_OID: i32 = -205;
pub const GNUTLS_E_RANDOM_FAILED: i32 = -206;
pub const GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR: i32 = -207;
pub const GNUTLS_E_OPENPGP_SUBKEY_ERROR: i32 = -208;
pub const GNUTLS_E_ALREADY_REGISTERED: i32 = -209;
pub const GNUTLS_E_HANDSHAKE_TOO_LARGE: i32 = -210;
pub const GNUTLS_E_CRYPTODEV_IOCTL_ERROR: i32 = -211;
pub const GNUTLS_E_CRYPTODEV_DEVICE_ERROR: i32 = -212;
pub const GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE: i32 = -213;
pub const GNUTLS_E_BAD_COOKIE: i32 = -214;
pub const GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR: i32 = -215;
pub const GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL: i32 = -216;
pub const GNUTLS_E_INSUFFICIENT_SECURITY: i32 = -217;
pub const GNUTLS_E_HEARTBEAT_PONG_RECEIVED: i32 = -292;
pub const GNUTLS_E_HEARTBEAT_PING_RECEIVED: i32 = -293;
pub const GNUTLS_E_UNRECOGNIZED_NAME: i32 = -294;
pub const GNUTLS_E_PKCS11_ERROR: i32 = -300;
pub const GNUTLS_E_PKCS11_LOAD_ERROR: i32 = -301;
pub const GNUTLS_E_PARSING_ERROR: i32 = -302;
pub const GNUTLS_E_PKCS11_PIN_ERROR: i32 = -303;
pub const GNUTLS_E_PKCS11_SLOT_ERROR: i32 = -305;
pub const GNUTLS_E_LOCKING_ERROR: i32 = -306;
pub const GNUTLS_E_PKCS11_ATTRIBUTE_ERROR: i32 = -307;
pub const GNUTLS_E_PKCS11_DEVICE_ERROR: i32 = -308;
pub const GNUTLS_E_PKCS11_DATA_ERROR: i32 = -309;
pub const GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR: i32 = -310;
pub const GNUTLS_E_PKCS11_KEY_ERROR: i32 = -311;
pub const GNUTLS_E_PKCS11_PIN_EXPIRED: i32 = -312;
pub const GNUTLS_E_PKCS11_PIN_LOCKED: i32 = -313;
pub const GNUTLS_E_PKCS11_SESSION_ERROR: i32 = -314;
pub const GNUTLS_E_PKCS11_SIGNATURE_ERROR: i32 = -315;
pub const GNUTLS_E_PKCS11_TOKEN_ERROR: i32 = -316;
pub const GNUTLS_E_PKCS11_USER_ERROR: i32 = -317;
pub const GNUTLS_E_CRYPTO_INIT_FAILED: i32 = -318;
pub const GNUTLS_E_TIMEDOUT: i32 = -319;
pub const GNUTLS_E_USER_ERROR: i32 = -320;
pub const GNUTLS_E_ECC_NO_SUPPORTED_CURVES: i32 = -321;
pub const GNUTLS_E_ECC_UNSUPPORTED_CURVE: i32 = -322;
pub const GNUTLS_E_PKCS11_REQUESTED_OBJECT_NOT_AVAILBLE: i32 = -323;
pub const GNUTLS_E_CERTIFICATE_LIST_UNSORTED: i32 = -324;
pub const GNUTLS_E_ILLEGAL_PARAMETER: i32 = -325;
pub const GNUTLS_E_NO_PRIORITIES_WERE_SET: i32 = -326;
pub const GNUTLS_E_X509_UNSUPPORTED_EXTENSION: i32 = -327;
pub const GNUTLS_E_SESSION_EOF: i32 = -328;
pub const GNUTLS_E_TPM_ERROR: i32 = -329;
pub const GNUTLS_E_TPM_KEY_PASSWORD_ERROR: i32 = -330;
pub const GNUTLS_E_TPM_SRK_PASSWORD_ERROR: i32 = -331;
pub const GNUTLS_E_TPM_SESSION_ERROR: i32 = -332;
pub const GNUTLS_E_TPM_KEY_NOT_FOUND: i32 = -333;
pub const GNUTLS_E_TPM_UNINITIALIZED: i32 = -334;
pub const GNUTLS_E_TPM_NO_LIB: i32 = -335;
pub const GNUTLS_E_NO_CERTIFICATE_STATUS: i32 = -340;
pub const GNUTLS_E_OCSP_RESPONSE_ERROR: i32 = -341;
pub const GNUTLS_E_RANDOM_DEVICE_ERROR: i32 = -342;
pub const GNUTLS_E_AUTH_ERROR: i32 = -343;
pub const GNUTLS_E_NO_APPLICATION_PROTOCOL: i32 = -344;
pub const GNUTLS_E_SOCKETS_INIT_ERROR: i32 = -345;
pub const GNUTLS_E_KEY_IMPORT_FAILED: i32 = -346;
pub const GNUTLS_E_INAPPROPRIATE_FALLBACK: i32 = -347;
pub const GNUTLS_E_CERTIFICATE_VERIFICATION_ERROR: i32 = -348;
pub const GNUTLS_E_PRIVKEY_VERIFICATION_ERROR: i32 = -349;
pub const GNUTLS_E_UNEXPECTED_EXTENSIONS_LENGTH: i32 = -350;
pub const GNUTLS_E_ASN1_EMBEDDED_NULL_IN_STRING: i32 = -351;
pub const GNUTLS_E_SELF_TEST_ERROR: i32 = -400;
pub const GNUTLS_E_NO_SELF_TEST: i32 = -401;
pub const GNUTLS_E_LIB_IN_ERROR_STATE: i32 = -402;
pub const GNUTLS_E_PK_GENERATION_ERROR: i32 = -403;
pub const GNUTLS_E_IDNA_ERROR: i32 = -404;
pub const GNUTLS_E_NEED_FALLBACK: i32 = -405;
pub const GNUTLS_E_SESSION_USER_ID_CHANGED: i32 = -406;
pub const GNUTLS_E_HANDSHAKE_DURING_FALSE_START: i32 = -407;
pub const GNUTLS_E_UNAVAILABLE_DURING_HANDSHAKE: i32 = -408;
pub const GNUTLS_E_PK_INVALID_PUBKEY: i32 = -409;
pub const GNUTLS_E_PK_INVALID_PRIVKEY: i32 = -410;
pub const GNUTLS_E_NOT_YET_ACTIVATED: i32 = -411;
pub const GNUTLS_E_INVALID_UTF8_STRING: i32 = -412;
pub const GNUTLS_E_NO_EMBEDDED_DATA: i32 = -413;
pub const GNUTLS_E_INVALID_UTF8_EMAIL: i32 = -414;
pub const GNUTLS_E_INVALID_PASSWORD_STRING: i32 = -415;
pub const GNUTLS_E_CERTIFICATE_TIME_ERROR: i32 = -416;
pub const GNUTLS_E_RECORD_OVERFLOW: i32 = -417;
pub const GNUTLS_E_ASN1_TIME_ERROR: i32 = -418;
pub const GNUTLS_E_INCOMPATIBLE_SIG_WITH_KEY: i32 = -419;
pub const GNUTLS_E_PK_INVALID_PUBKEY_PARAMS: i32 = -420;
pub const GNUTLS_E_PK_NO_VALIDATION_PARAMS: i32 = -421;
pub const GNUTLS_E_OCSP_MISMATCH_WITH_CERTS: i32 = -422;
pub const GNUTLS_E_NO_COMMON_KEY_SHARE: i32 = -423;
pub const GNUTLS_E_REAUTH_REQUEST: i32 = -424;
pub const GNUTLS_E_TOO_MANY_MATCHES: i32 = -425;
pub const GNUTLS_E_CRL_VERIFICATION_ERROR: i32 = -426;
pub const GNUTLS_E_MISSING_EXTENSION: i32 = -427;
pub const GNUTLS_E_DB_ENTRY_EXISTS: i32 = -428;
pub const GNUTLS_E_EARLY_DATA_REJECTED: i32 = -429;
pub const GNUTLS_E_X509_DUPLICATE_EXTENSION: i32 = -430;
pub const GNUTLS_E_UNIMPLEMENTED_FEATURE: i32 = -1250;
pub const GNUTLS_E_INT_RET_0: i32 = -1251;
pub const GNUTLS_E_INT_CHECK_AGAIN: i32 = -1252;
pub const GNUTLS_E_APPLICATION_ERROR_MAX: i32 = -65000;
pub const GNUTLS_E_APPLICATION_ERROR_MIN: i32 = -65500;
pub const GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT: u32 = 0;
pub const LIBGNUTLS_VERSION: &[u8; 6usize] = b"3.7.3\0";
pub const LIBGNUTLS_VERSION_MAJOR: u32 = 3;
pub const LIBGNUTLS_VERSION_MINOR: u32 = 7;
pub const LIBGNUTLS_VERSION_PATCH: u32 = 3;
pub const LIBGNUTLS_VERSION_NUMBER: u32 = 198403;
pub const LIBGNUTLS_EXTRA_VERSION: &[u8; 6usize] = b"3.7.3\0";
pub const GNUTLS_SUPPLEMENTAL_USER_MAPPING_DATA: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const USERPREF_DEVICE_CERTIFICATE_KEY: &[u8; 18usize] = b"DeviceCertificate\0";
pub const USERPREF_ESCROW_BAG_KEY: &[u8; 10usize] = b"EscrowBag\0";
pub const USERPREF_HOST_CERTIFICATE_KEY: &[u8; 16usize] = b"HostCertificate\0";
pub const USERPREF_ROOT_CERTIFICATE_KEY: &[u8; 16usize] = b"RootCertificate\0";
pub const USERPREF_HOST_PRIVATE_KEY_KEY: &[u8; 15usize] = b"HostPrivateKey\0";
pub const USERPREF_ROOT_PRIVATE_KEY_KEY: &[u8; 15usize] = b"RootPrivateKey\0";
pub const USERPREF_HOST_ID_KEY: &[u8; 7usize] = b"HostID\0";
pub const USERPREF_SYSTEM_BUID_KEY: &[u8; 11usize] = b"SystemBUID\0";
pub const USERPREF_WIFI_MAC_ADDRESS_KEY: &[u8; 15usize] = b"WiFiMACAddress\0";
pub const AFC_SERVICE_NAME: &[u8; 14usize] = b"com.apple.afc\0";
pub const COMPANION_PROXY_SERVICE_NAME: &[u8; 26usize] = b"com.apple.companion_proxy\0";
pub const DEBUGSERVER_SERVICE_NAME: &[u8; 22usize] = b"com.apple.debugserver\0";
pub const DEBUGSERVER_SECURE_SERVICE_NAME: &[u8; 43usize] =
    b"com.apple.debugserver.DVTSecureSocketProxy\0";
pub const DIAGNOSTICS_RELAY_SERVICE_NAME: &[u8; 35usize] = b"com.apple.mobile.diagnostics_relay\0";
pub const DIAGNOSTICS_RELAY_REQUEST_TYPE_ALL: &[u8; 4usize] = b"All\0";
pub const DIAGNOSTICS_RELAY_REQUEST_TYPE_WIFI: &[u8; 5usize] = b"WiFi\0";
pub const DIAGNOSTICS_RELAY_REQUEST_TYPE_GAS_GAUGE: &[u8; 9usize] = b"GasGauge\0";
pub const DIAGNOSTICS_RELAY_REQUEST_TYPE_NAND: &[u8; 5usize] = b"NAND\0";
pub const FILE_RELAY_SERVICE_NAME: &[u8; 28usize] = b"com.apple.mobile.file_relay\0";
pub const HEARTBEAT_SERVICE_NAME: &[u8; 27usize] = b"com.apple.mobile.heartbeat\0";
pub const HOUSE_ARREST_SERVICE_NAME: &[u8; 30usize] = b"com.apple.mobile.house_arrest\0";
pub const INSTPROXY_SERVICE_NAME: &[u8; 36usize] = b"com.apple.mobile.installation_proxy\0";
pub const MISAGENT_SERVICE_NAME: &[u8; 19usize] = b"com.apple.misagent\0";
pub const MOBILE_IMAGE_MOUNTER_SERVICE_NAME: &[u8; 38usize] =
    b"com.apple.mobile.mobile_image_mounter\0";
pub const MOBILEACTIVATION_SERVICE_NAME: &[u8; 28usize] = b"com.apple.mobileactivationd\0";
pub const MOBILEBACKUP_SERVICE_NAME: &[u8; 23usize] = b"com.apple.mobilebackup\0";
pub const MOBILEBACKUP2_SERVICE_NAME: &[u8; 24usize] = b"com.apple.mobilebackup2\0";
pub const MOBILESYNC_SERVICE_NAME: &[u8; 21usize] = b"com.apple.mobilesync\0";
pub const NP_SERVICE_NAME: &[u8; 36usize] = b"com.apple.mobile.notification_proxy\0";
pub const NP_SYNC_WILL_START: &[u8; 38usize] = b"com.apple.itunes-mobdev.syncWillStart\0";
pub const NP_SYNC_DID_START: &[u8; 37usize] = b"com.apple.itunes-mobdev.syncDidStart\0";
pub const NP_SYNC_DID_FINISH: &[u8; 38usize] = b"com.apple.itunes-mobdev.syncDidFinish\0";
pub const NP_SYNC_LOCK_REQUEST: &[u8; 40usize] = b"com.apple.itunes-mobdev.syncLockRequest\0";
pub const NP_SYNC_CANCEL_REQUEST: &[u8; 42usize] = b"com.apple.itunes-client.syncCancelRequest\0";
pub const NP_SYNC_SUSPEND_REQUEST: &[u8; 43usize] = b"com.apple.itunes-client.syncSuspendRequest\0";
pub const NP_SYNC_RESUME_REQUEST: &[u8; 42usize] = b"com.apple.itunes-client.syncResumeRequest\0";
pub const NP_PHONE_NUMBER_CHANGED: &[u8; 47usize] =
    b"com.apple.mobile.lockdown.phone_number_changed\0";
pub const NP_DEVICE_NAME_CHANGED: &[u8; 46usize] =
    b"com.apple.mobile.lockdown.device_name_changed\0";
pub const NP_TIMEZONE_CHANGED: &[u8; 43usize] = b"com.apple.mobile.lockdown.timezone_changed\0";
pub const NP_TRUSTED_HOST_ATTACHED: &[u8; 48usize] =
    b"com.apple.mobile.lockdown.trusted_host_attached\0";
pub const NP_HOST_DETACHED: &[u8; 40usize] = b"com.apple.mobile.lockdown.host_detached\0";
pub const NP_HOST_ATTACHED: &[u8; 40usize] = b"com.apple.mobile.lockdown.host_attached\0";
pub const NP_REGISTRATION_FAILED: &[u8; 46usize] =
    b"com.apple.mobile.lockdown.registration_failed\0";
pub const NP_ACTIVATION_STATE: &[u8; 43usize] = b"com.apple.mobile.lockdown.activation_state\0";
pub const NP_BRICK_STATE: &[u8; 38usize] = b"com.apple.mobile.lockdown.brick_state\0";
pub const NP_DISK_USAGE_CHANGED: &[u8; 45usize] = b"com.apple.mobile.lockdown.disk_usage_changed\0";
pub const NP_DS_DOMAIN_CHANGED: &[u8; 42usize] = b"com.apple.mobile.data_sync.domain_changed\0";
pub const NP_BACKUP_DOMAIN_CHANGED: &[u8; 39usize] = b"com.apple.mobile.backup.domain_changed\0";
pub const NP_APP_INSTALLED: &[u8; 39usize] = b"com.apple.mobile.application_installed\0";
pub const NP_APP_UNINSTALLED: &[u8; 41usize] = b"com.apple.mobile.application_uninstalled\0";
pub const NP_DEV_IMAGE_MOUNTED: &[u8; 41usize] = b"com.apple.mobile.developer_image_mounted\0";
pub const NP_ATTEMPTACTIVATION: &[u8; 40usize] = b"com.apple.springboard.attemptactivation\0";
pub const NP_ITDBPREP_DID_END: &[u8; 39usize] = b"com.apple.itdbprep.notification.didEnd\0";
pub const NP_LANGUAGE_CHANGED: &[u8; 27usize] = b"com.apple.language.changed\0";
pub const NP_ADDRESS_BOOK_PREF_CHANGED: &[u8; 40usize] =
    b"com.apple.AddressBook.PreferenceChanged\0";
pub const PREBOARD_SERVICE_NAME: &[u8; 29usize] = b"com.apple.preboardservice_v2\0";
pub const REVERSE_PROXY_DEFAULT_PORT: u32 = 1082;
pub const SBSERVICES_SERVICE_NAME: &[u8; 30usize] = b"com.apple.springboardservices\0";
pub const SCREENSHOTR_SERVICE_NAME: &[u8; 29usize] = b"com.apple.mobile.screenshotr\0";
pub const SYSLOG_RELAY_SERVICE_NAME: &[u8; 23usize] = b"com.apple.syslog_relay\0";
pub const WEBINSPECTOR_SERVICE_NAME: &[u8; 23usize] = b"com.apple.webinspector\0";
pub const DEVICE_CLASS_IPHONE: u32 = 1;
pub const DEVICE_CLASS_IPAD: u32 = 2;
pub const DEVICE_CLASS_IPOD: u32 = 3;
pub const DEVICE_CLASS_APPLETV: u32 = 4;
pub const DEVICE_CLASS_WATCH: u32 = 5;
pub const DEVICE_CLASS_UNKNOWN: u32 = 255;
pub const LOCKDOWN_PROTOCOL_VERSION: &[u8; 2usize] = b"2\0";
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_UNKNOWN: gnutls_cipher_algorithm = 0;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_NULL: gnutls_cipher_algorithm = 1;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_ARCFOUR_128: gnutls_cipher_algorithm = 2;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_3DES_CBC: gnutls_cipher_algorithm = 3;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CBC: gnutls_cipher_algorithm = 4;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CBC: gnutls_cipher_algorithm = 5;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_ARCFOUR_40: gnutls_cipher_algorithm = 6;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_128_CBC: gnutls_cipher_algorithm = 7;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_256_CBC: gnutls_cipher_algorithm = 8;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_192_CBC: gnutls_cipher_algorithm = 9;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_GCM: gnutls_cipher_algorithm = 10;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_GCM: gnutls_cipher_algorithm = 11;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_192_CBC: gnutls_cipher_algorithm = 12;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_SALSA20_256: gnutls_cipher_algorithm = 13;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_ESTREAM_SALSA20_256: gnutls_cipher_algorithm = 14;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_128_GCM: gnutls_cipher_algorithm = 15;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAMELLIA_256_GCM: gnutls_cipher_algorithm = 16;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_RC2_40_CBC: gnutls_cipher_algorithm = 17;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_DES_CBC: gnutls_cipher_algorithm = 18;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CCM: gnutls_cipher_algorithm = 19;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CCM: gnutls_cipher_algorithm = 20;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CCM_8: gnutls_cipher_algorithm = 21;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CCM_8: gnutls_cipher_algorithm = 22;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CHACHA20_POLY1305: gnutls_cipher_algorithm = 23;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_TC26Z_CFB: gnutls_cipher_algorithm = 24;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPA_CFB: gnutls_cipher_algorithm = 25;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPB_CFB: gnutls_cipher_algorithm = 26;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPC_CFB: gnutls_cipher_algorithm = 27;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_CPD_CFB: gnutls_cipher_algorithm = 28;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_CFB8: gnutls_cipher_algorithm = 29;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_192_CFB8: gnutls_cipher_algorithm = 30;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_CFB8: gnutls_cipher_algorithm = 31;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_XTS: gnutls_cipher_algorithm = 32;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_XTS: gnutls_cipher_algorithm = 33;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_GOST28147_TC26Z_CNT: gnutls_cipher_algorithm = 34;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CHACHA20_64: gnutls_cipher_algorithm = 35;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CHACHA20_32: gnutls_cipher_algorithm = 36;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_128_SIV: gnutls_cipher_algorithm = 37;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_256_SIV: gnutls_cipher_algorithm = 38;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES_192_GCM: gnutls_cipher_algorithm = 39;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_MAGMA_CTR_ACPKM: gnutls_cipher_algorithm = 40;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_KUZNYECHIK_CTR_ACPKM: gnutls_cipher_algorithm = 41;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_IDEA_PGP_CFB: gnutls_cipher_algorithm = 200;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_3DES_PGP_CFB: gnutls_cipher_algorithm = 201;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_CAST5_PGP_CFB: gnutls_cipher_algorithm = 202;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_BLOWFISH_PGP_CFB: gnutls_cipher_algorithm = 203;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_SAFER_SK128_PGP_CFB: gnutls_cipher_algorithm = 204;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES128_PGP_CFB: gnutls_cipher_algorithm = 205;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES192_PGP_CFB: gnutls_cipher_algorithm = 206;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_AES256_PGP_CFB: gnutls_cipher_algorithm = 207;
pub const gnutls_cipher_algorithm_GNUTLS_CIPHER_TWOFISH_PGP_CFB: gnutls_cipher_algorithm = 208;
pub type gnutls_cipher_algorithm = ::std::os::raw::c_uint;
pub use self::gnutls_cipher_algorithm as gnutls_cipher_algorithm_t;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_UNKNOWN: gnutls_kx_algorithm_t = 0;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_RSA: gnutls_kx_algorithm_t = 1;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_DHE_DSS: gnutls_kx_algorithm_t = 2;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_DHE_RSA: gnutls_kx_algorithm_t = 3;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ANON_DH: gnutls_kx_algorithm_t = 4;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_SRP: gnutls_kx_algorithm_t = 5;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_RSA_EXPORT: gnutls_kx_algorithm_t = 6;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_SRP_RSA: gnutls_kx_algorithm_t = 7;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_SRP_DSS: gnutls_kx_algorithm_t = 8;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_PSK: gnutls_kx_algorithm_t = 9;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_DHE_PSK: gnutls_kx_algorithm_t = 10;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ANON_ECDH: gnutls_kx_algorithm_t = 11;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ECDHE_RSA: gnutls_kx_algorithm_t = 12;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ECDHE_ECDSA: gnutls_kx_algorithm_t = 13;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_ECDHE_PSK: gnutls_kx_algorithm_t = 14;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_RSA_PSK: gnutls_kx_algorithm_t = 15;
pub const gnutls_kx_algorithm_t_GNUTLS_KX_VKO_GOST_12: gnutls_kx_algorithm_t = 16;
pub type gnutls_kx_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_params_type_t_GNUTLS_PARAMS_RSA_EXPORT: gnutls_params_type_t = 1;
pub const gnutls_params_type_t_GNUTLS_PARAMS_DH: gnutls_params_type_t = 2;
pub const gnutls_params_type_t_GNUTLS_PARAMS_ECDH: gnutls_params_type_t = 3;
pub type gnutls_params_type_t = ::std::os::raw::c_uint;
pub const gnutls_credentials_type_t_GNUTLS_CRD_CERTIFICATE: gnutls_credentials_type_t = 1;
pub const gnutls_credentials_type_t_GNUTLS_CRD_ANON: gnutls_credentials_type_t = 2;
pub const gnutls_credentials_type_t_GNUTLS_CRD_SRP: gnutls_credentials_type_t = 3;
pub const gnutls_credentials_type_t_GNUTLS_CRD_PSK: gnutls_credentials_type_t = 4;
pub const gnutls_credentials_type_t_GNUTLS_CRD_IA: gnutls_credentials_type_t = 5;
pub type gnutls_credentials_type_t = ::std::os::raw::c_uint;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_UNKNOWN: gnutls_mac_algorithm_t = 0;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_NULL: gnutls_mac_algorithm_t = 1;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MD5: gnutls_mac_algorithm_t = 2;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA1: gnutls_mac_algorithm_t = 3;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_RMD160: gnutls_mac_algorithm_t = 4;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MD2: gnutls_mac_algorithm_t = 5;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA256: gnutls_mac_algorithm_t = 6;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA384: gnutls_mac_algorithm_t = 7;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA512: gnutls_mac_algorithm_t = 8;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA224: gnutls_mac_algorithm_t = 9;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_224: gnutls_mac_algorithm_t = 10;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_256: gnutls_mac_algorithm_t = 11;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_384: gnutls_mac_algorithm_t = 12;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHA3_512: gnutls_mac_algorithm_t = 13;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MD5_SHA1: gnutls_mac_algorithm_t = 14;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_GOSTR_94: gnutls_mac_algorithm_t = 15;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_STREEBOG_256: gnutls_mac_algorithm_t = 16;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_STREEBOG_512: gnutls_mac_algorithm_t = 17;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AEAD: gnutls_mac_algorithm_t = 200;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_UMAC_96: gnutls_mac_algorithm_t = 201;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_UMAC_128: gnutls_mac_algorithm_t = 202;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_CMAC_128: gnutls_mac_algorithm_t = 203;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_CMAC_256: gnutls_mac_algorithm_t = 204;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_GMAC_128: gnutls_mac_algorithm_t = 205;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_GMAC_192: gnutls_mac_algorithm_t = 206;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_AES_GMAC_256: gnutls_mac_algorithm_t = 207;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_GOST28147_TC26Z_IMIT: gnutls_mac_algorithm_t = 208;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHAKE_128: gnutls_mac_algorithm_t = 209;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_SHAKE_256: gnutls_mac_algorithm_t = 210;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_MAGMA_OMAC: gnutls_mac_algorithm_t = 211;
pub const gnutls_mac_algorithm_t_GNUTLS_MAC_KUZNYECHIK_OMAC: gnutls_mac_algorithm_t = 212;
pub type gnutls_mac_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_UNKNOWN: gnutls_digest_algorithm_t = 0;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_NULL: gnutls_digest_algorithm_t = 1;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_MD5: gnutls_digest_algorithm_t = 2;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA1: gnutls_digest_algorithm_t = 3;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_RMD160: gnutls_digest_algorithm_t = 4;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_MD2: gnutls_digest_algorithm_t = 5;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA256: gnutls_digest_algorithm_t = 6;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA384: gnutls_digest_algorithm_t = 7;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA512: gnutls_digest_algorithm_t = 8;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA224: gnutls_digest_algorithm_t = 9;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_224: gnutls_digest_algorithm_t = 10;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_256: gnutls_digest_algorithm_t = 11;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_384: gnutls_digest_algorithm_t = 12;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHA3_512: gnutls_digest_algorithm_t = 13;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_MD5_SHA1: gnutls_digest_algorithm_t = 14;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_GOSTR_94: gnutls_digest_algorithm_t = 15;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_STREEBOG_256: gnutls_digest_algorithm_t = 16;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_STREEBOG_512: gnutls_digest_algorithm_t = 17;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHAKE_128: gnutls_digest_algorithm_t = 209;
pub const gnutls_digest_algorithm_t_GNUTLS_DIG_SHAKE_256: gnutls_digest_algorithm_t = 210;
pub type gnutls_digest_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_compression_method_t_GNUTLS_COMP_UNKNOWN: gnutls_compression_method_t = 0;
pub const gnutls_compression_method_t_GNUTLS_COMP_NULL: gnutls_compression_method_t = 1;
pub const gnutls_compression_method_t_GNUTLS_COMP_DEFLATE: gnutls_compression_method_t = 2;
pub const gnutls_compression_method_t_GNUTLS_COMP_ZLIB: gnutls_compression_method_t = 2;
pub type gnutls_compression_method_t = ::std::os::raw::c_uint;
pub const gnutls_init_flags_t_GNUTLS_SERVER: gnutls_init_flags_t = 1;
pub const gnutls_init_flags_t_GNUTLS_CLIENT: gnutls_init_flags_t = 2;
pub const gnutls_init_flags_t_GNUTLS_DATAGRAM: gnutls_init_flags_t = 4;
pub const gnutls_init_flags_t_GNUTLS_NONBLOCK: gnutls_init_flags_t = 8;
pub const gnutls_init_flags_t_GNUTLS_NO_EXTENSIONS: gnutls_init_flags_t = 16;
pub const gnutls_init_flags_t_GNUTLS_NO_REPLAY_PROTECTION: gnutls_init_flags_t = 32;
pub const gnutls_init_flags_t_GNUTLS_NO_SIGNAL: gnutls_init_flags_t = 64;
pub const gnutls_init_flags_t_GNUTLS_ALLOW_ID_CHANGE: gnutls_init_flags_t = 128;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_FALSE_START: gnutls_init_flags_t = 256;
pub const gnutls_init_flags_t_GNUTLS_FORCE_CLIENT_CERT: gnutls_init_flags_t = 512;
pub const gnutls_init_flags_t_GNUTLS_NO_TICKETS: gnutls_init_flags_t = 1024;
pub const gnutls_init_flags_t_GNUTLS_KEY_SHARE_TOP: gnutls_init_flags_t = 2048;
pub const gnutls_init_flags_t_GNUTLS_KEY_SHARE_TOP2: gnutls_init_flags_t = 4096;
pub const gnutls_init_flags_t_GNUTLS_KEY_SHARE_TOP3: gnutls_init_flags_t = 8192;
pub const gnutls_init_flags_t_GNUTLS_POST_HANDSHAKE_AUTH: gnutls_init_flags_t = 16384;
pub const gnutls_init_flags_t_GNUTLS_NO_AUTO_REKEY: gnutls_init_flags_t = 32768;
pub const gnutls_init_flags_t_GNUTLS_SAFE_PADDING_CHECK: gnutls_init_flags_t = 65536;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_EARLY_START: gnutls_init_flags_t = 131072;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_RAWPK: gnutls_init_flags_t = 262144;
pub const gnutls_init_flags_t_GNUTLS_AUTO_REAUTH: gnutls_init_flags_t = 524288;
pub const gnutls_init_flags_t_GNUTLS_ENABLE_EARLY_DATA: gnutls_init_flags_t = 1048576;
pub const gnutls_init_flags_t_GNUTLS_NO_AUTO_SEND_TICKET: gnutls_init_flags_t = 2097152;
pub const gnutls_init_flags_t_GNUTLS_NO_END_OF_EARLY_DATA: gnutls_init_flags_t = 4194304;
pub type gnutls_init_flags_t = ::std::os::raw::c_uint;
pub const gnutls_alert_level_t_GNUTLS_AL_WARNING: gnutls_alert_level_t = 1;
pub const gnutls_alert_level_t_GNUTLS_AL_FATAL: gnutls_alert_level_t = 2;
pub type gnutls_alert_level_t = ::std::os::raw::c_uint;
pub const gnutls_alert_description_t_GNUTLS_A_CLOSE_NOTIFY: gnutls_alert_description_t = 0;
pub const gnutls_alert_description_t_GNUTLS_A_UNEXPECTED_MESSAGE: gnutls_alert_description_t = 10;
pub const gnutls_alert_description_t_GNUTLS_A_BAD_RECORD_MAC: gnutls_alert_description_t = 20;
pub const gnutls_alert_description_t_GNUTLS_A_DECRYPTION_FAILED: gnutls_alert_description_t = 21;
pub const gnutls_alert_description_t_GNUTLS_A_RECORD_OVERFLOW: gnutls_alert_description_t = 22;
pub const gnutls_alert_description_t_GNUTLS_A_DECOMPRESSION_FAILURE: gnutls_alert_description_t =
    30;
pub const gnutls_alert_description_t_GNUTLS_A_HANDSHAKE_FAILURE: gnutls_alert_description_t = 40;
pub const gnutls_alert_description_t_GNUTLS_A_SSL3_NO_CERTIFICATE: gnutls_alert_description_t = 41;
pub const gnutls_alert_description_t_GNUTLS_A_BAD_CERTIFICATE: gnutls_alert_description_t = 42;
pub const gnutls_alert_description_t_GNUTLS_A_UNSUPPORTED_CERTIFICATE: gnutls_alert_description_t =
    43;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_REVOKED: gnutls_alert_description_t = 44;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_EXPIRED: gnutls_alert_description_t = 45;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_UNKNOWN: gnutls_alert_description_t = 46;
pub const gnutls_alert_description_t_GNUTLS_A_ILLEGAL_PARAMETER: gnutls_alert_description_t = 47;
pub const gnutls_alert_description_t_GNUTLS_A_UNKNOWN_CA: gnutls_alert_description_t = 48;
pub const gnutls_alert_description_t_GNUTLS_A_ACCESS_DENIED: gnutls_alert_description_t = 49;
pub const gnutls_alert_description_t_GNUTLS_A_DECODE_ERROR: gnutls_alert_description_t = 50;
pub const gnutls_alert_description_t_GNUTLS_A_DECRYPT_ERROR: gnutls_alert_description_t = 51;
pub const gnutls_alert_description_t_GNUTLS_A_EXPORT_RESTRICTION: gnutls_alert_description_t = 60;
pub const gnutls_alert_description_t_GNUTLS_A_PROTOCOL_VERSION: gnutls_alert_description_t = 70;
pub const gnutls_alert_description_t_GNUTLS_A_INSUFFICIENT_SECURITY: gnutls_alert_description_t =
    71;
pub const gnutls_alert_description_t_GNUTLS_A_INTERNAL_ERROR: gnutls_alert_description_t = 80;
pub const gnutls_alert_description_t_GNUTLS_A_INAPPROPRIATE_FALLBACK: gnutls_alert_description_t =
    86;
pub const gnutls_alert_description_t_GNUTLS_A_USER_CANCELED: gnutls_alert_description_t = 90;
pub const gnutls_alert_description_t_GNUTLS_A_NO_RENEGOTIATION: gnutls_alert_description_t = 100;
pub const gnutls_alert_description_t_GNUTLS_A_MISSING_EXTENSION: gnutls_alert_description_t = 109;
pub const gnutls_alert_description_t_GNUTLS_A_UNSUPPORTED_EXTENSION: gnutls_alert_description_t =
    110;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_UNOBTAINABLE: gnutls_alert_description_t =
    111;
pub const gnutls_alert_description_t_GNUTLS_A_UNRECOGNIZED_NAME: gnutls_alert_description_t = 112;
pub const gnutls_alert_description_t_GNUTLS_A_UNKNOWN_PSK_IDENTITY: gnutls_alert_description_t =
    115;
pub const gnutls_alert_description_t_GNUTLS_A_CERTIFICATE_REQUIRED: gnutls_alert_description_t =
    116;
pub const gnutls_alert_description_t_GNUTLS_A_NO_APPLICATION_PROTOCOL: gnutls_alert_description_t =
    120;
pub const gnutls_alert_description_t_GNUTLS_A_MAX: gnutls_alert_description_t = 120;
pub type gnutls_alert_description_t = ::std::os::raw::c_uint;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_HELLO_REQUEST:
    gnutls_handshake_description_t = 0;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CLIENT_HELLO:
    gnutls_handshake_description_t = 1;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SERVER_HELLO:
    gnutls_handshake_description_t = 2;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_HELLO_VERIFY_REQUEST:
    gnutls_handshake_description_t = 3;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_NEW_SESSION_TICKET:
    gnutls_handshake_description_t = 4;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_END_OF_EARLY_DATA:
    gnutls_handshake_description_t = 5;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_ENCRYPTED_EXTENSIONS:
    gnutls_handshake_description_t = 8;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_PKT:
    gnutls_handshake_description_t = 11;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SERVER_KEY_EXCHANGE:
    gnutls_handshake_description_t = 12;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_REQUEST:
    gnutls_handshake_description_t = 13;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SERVER_HELLO_DONE:
    gnutls_handshake_description_t = 14;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_VERIFY:
    gnutls_handshake_description_t = 15;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CLIENT_KEY_EXCHANGE:
    gnutls_handshake_description_t = 16;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_FINISHED: gnutls_handshake_description_t =
    20;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CERTIFICATE_STATUS:
    gnutls_handshake_description_t = 22;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_SUPPLEMENTAL:
    gnutls_handshake_description_t = 23;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_KEY_UPDATE:
    gnutls_handshake_description_t = 24;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC:
    gnutls_handshake_description_t = 254;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_CLIENT_HELLO_V2:
    gnutls_handshake_description_t = 1024;
pub const gnutls_handshake_description_t_GNUTLS_HANDSHAKE_HELLO_RETRY_REQUEST:
    gnutls_handshake_description_t = 1025;
pub type gnutls_handshake_description_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_handshake_description_get_name(
        type_: gnutls_handshake_description_t,
    ) -> *const ::std::os::raw::c_char;
}
pub const gnutls_certificate_status_t_GNUTLS_CERT_INVALID: gnutls_certificate_status_t = 2;
pub const gnutls_certificate_status_t_GNUTLS_CERT_REVOKED: gnutls_certificate_status_t = 32;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNER_NOT_FOUND: gnutls_certificate_status_t =
    64;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNER_NOT_CA: gnutls_certificate_status_t = 128;
pub const gnutls_certificate_status_t_GNUTLS_CERT_INSECURE_ALGORITHM: gnutls_certificate_status_t =
    256;
pub const gnutls_certificate_status_t_GNUTLS_CERT_NOT_ACTIVATED: gnutls_certificate_status_t = 512;
pub const gnutls_certificate_status_t_GNUTLS_CERT_EXPIRED: gnutls_certificate_status_t = 1024;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNATURE_FAILURE: gnutls_certificate_status_t =
    2048;
pub const gnutls_certificate_status_t_GNUTLS_CERT_REVOCATION_DATA_SUPERSEDED:
    gnutls_certificate_status_t = 4096;
pub const gnutls_certificate_status_t_GNUTLS_CERT_UNEXPECTED_OWNER: gnutls_certificate_status_t =
    16384;
pub const gnutls_certificate_status_t_GNUTLS_CERT_REVOCATION_DATA_ISSUED_IN_FUTURE:
    gnutls_certificate_status_t = 32768;
pub const gnutls_certificate_status_t_GNUTLS_CERT_SIGNER_CONSTRAINTS_FAILURE:
    gnutls_certificate_status_t = 65536;
pub const gnutls_certificate_status_t_GNUTLS_CERT_MISMATCH: gnutls_certificate_status_t = 131072;
pub const gnutls_certificate_status_t_GNUTLS_CERT_PURPOSE_MISMATCH: gnutls_certificate_status_t =
    262144;
pub const gnutls_certificate_status_t_GNUTLS_CERT_MISSING_OCSP_STATUS: gnutls_certificate_status_t =
    524288;
pub const gnutls_certificate_status_t_GNUTLS_CERT_INVALID_OCSP_STATUS: gnutls_certificate_status_t =
    1048576;
pub const gnutls_certificate_status_t_GNUTLS_CERT_UNKNOWN_CRIT_EXTENSIONS:
    gnutls_certificate_status_t = 2097152;
pub type gnutls_certificate_status_t = ::std::os::raw::c_uint;
pub const gnutls_certificate_request_t_GNUTLS_CERT_IGNORE: gnutls_certificate_request_t = 0;
pub const gnutls_certificate_request_t_GNUTLS_CERT_REQUEST: gnutls_certificate_request_t = 1;
pub const gnutls_certificate_request_t_GNUTLS_CERT_REQUIRE: gnutls_certificate_request_t = 2;
pub type gnutls_certificate_request_t = ::std::os::raw::c_uint;
pub const gnutls_openpgp_crt_status_t_GNUTLS_OPENPGP_CERT: gnutls_openpgp_crt_status_t = 0;
pub const gnutls_openpgp_crt_status_t_GNUTLS_OPENPGP_CERT_FINGERPRINT: gnutls_openpgp_crt_status_t =
    1;
pub type gnutls_openpgp_crt_status_t = ::std::os::raw::c_uint;
pub const gnutls_close_request_t_GNUTLS_SHUT_RDWR: gnutls_close_request_t = 0;
pub const gnutls_close_request_t_GNUTLS_SHUT_WR: gnutls_close_request_t = 1;
pub type gnutls_close_request_t = ::std::os::raw::c_uint;
pub const gnutls_protocol_t_GNUTLS_SSL3: gnutls_protocol_t = 1;
pub const gnutls_protocol_t_GNUTLS_TLS1_0: gnutls_protocol_t = 2;
pub const gnutls_protocol_t_GNUTLS_TLS1: gnutls_protocol_t = 2;
pub const gnutls_protocol_t_GNUTLS_TLS1_1: gnutls_protocol_t = 3;
pub const gnutls_protocol_t_GNUTLS_TLS1_2: gnutls_protocol_t = 4;
pub const gnutls_protocol_t_GNUTLS_TLS1_3: gnutls_protocol_t = 5;
pub const gnutls_protocol_t_GNUTLS_DTLS0_9: gnutls_protocol_t = 200;
pub const gnutls_protocol_t_GNUTLS_DTLS1_0: gnutls_protocol_t = 201;
pub const gnutls_protocol_t_GNUTLS_DTLS1_2: gnutls_protocol_t = 202;
pub const gnutls_protocol_t_GNUTLS_DTLS_VERSION_MIN: gnutls_protocol_t = 200;
pub const gnutls_protocol_t_GNUTLS_DTLS_VERSION_MAX: gnutls_protocol_t = 202;
pub const gnutls_protocol_t_GNUTLS_TLS_VERSION_MAX: gnutls_protocol_t = 5;
pub const gnutls_protocol_t_GNUTLS_VERSION_UNKNOWN: gnutls_protocol_t = 255;
pub type gnutls_protocol_t = ::std::os::raw::c_uint;
pub const gnutls_certificate_type_t_GNUTLS_CRT_UNKNOWN: gnutls_certificate_type_t = 0;
pub const gnutls_certificate_type_t_GNUTLS_CRT_X509: gnutls_certificate_type_t = 1;
pub const gnutls_certificate_type_t_GNUTLS_CRT_OPENPGP: gnutls_certificate_type_t = 2;
pub const gnutls_certificate_type_t_GNUTLS_CRT_RAWPK: gnutls_certificate_type_t = 3;
pub const gnutls_certificate_type_t_GNUTLS_CRT_MAX: gnutls_certificate_type_t = 3;
pub type gnutls_certificate_type_t = ::std::os::raw::c_uint;
pub const gnutls_x509_crt_fmt_t_GNUTLS_X509_FMT_DER: gnutls_x509_crt_fmt_t = 0;
pub const gnutls_x509_crt_fmt_t_GNUTLS_X509_FMT_PEM: gnutls_x509_crt_fmt_t = 1;
pub type gnutls_x509_crt_fmt_t = ::std::os::raw::c_uint;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_FULL: gnutls_certificate_print_formats =
    0;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_ONELINE:
    gnutls_certificate_print_formats = 1;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_UNSIGNED_FULL:
    gnutls_certificate_print_formats = 2;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_COMPACT:
    gnutls_certificate_print_formats = 3;
pub const gnutls_certificate_print_formats_GNUTLS_CRT_PRINT_FULL_NUMBERS:
    gnutls_certificate_print_formats = 4;
pub type gnutls_certificate_print_formats = ::std::os::raw::c_uint;
pub use self::gnutls_certificate_print_formats as gnutls_certificate_print_formats_t;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_UNKNOWN: gnutls_pk_algorithm_t = 0;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_RSA: gnutls_pk_algorithm_t = 1;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_DSA: gnutls_pk_algorithm_t = 2;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_DH: gnutls_pk_algorithm_t = 3;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_ECDSA: gnutls_pk_algorithm_t = 4;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_ECDH_X25519: gnutls_pk_algorithm_t = 5;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_RSA_PSS: gnutls_pk_algorithm_t = 6;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_EDDSA_ED25519: gnutls_pk_algorithm_t = 7;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_GOST_01: gnutls_pk_algorithm_t = 8;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_GOST_12_256: gnutls_pk_algorithm_t = 9;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_GOST_12_512: gnutls_pk_algorithm_t = 10;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_ECDH_X448: gnutls_pk_algorithm_t = 11;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_EDDSA_ED448: gnutls_pk_algorithm_t = 12;
pub const gnutls_pk_algorithm_t_GNUTLS_PK_MAX: gnutls_pk_algorithm_t = 12;
pub type gnutls_pk_algorithm_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_pk_algorithm_get_name(
        algorithm: gnutls_pk_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_UNKNOWN: gnutls_sign_algorithm_t = 0;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA1: gnutls_sign_algorithm_t = 1;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA: gnutls_sign_algorithm_t = 1;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA1: gnutls_sign_algorithm_t = 2;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA: gnutls_sign_algorithm_t = 2;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_MD5: gnutls_sign_algorithm_t = 3;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_MD2: gnutls_sign_algorithm_t = 4;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_RMD160: gnutls_sign_algorithm_t = 5;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA256: gnutls_sign_algorithm_t = 6;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA384: gnutls_sign_algorithm_t = 7;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA512: gnutls_sign_algorithm_t = 8;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA224: gnutls_sign_algorithm_t = 9;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA224: gnutls_sign_algorithm_t = 10;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA256: gnutls_sign_algorithm_t = 11;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA1: gnutls_sign_algorithm_t = 12;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA224: gnutls_sign_algorithm_t = 13;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA256: gnutls_sign_algorithm_t = 14;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA384: gnutls_sign_algorithm_t = 15;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA512: gnutls_sign_algorithm_t = 16;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA384: gnutls_sign_algorithm_t = 17;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA512: gnutls_sign_algorithm_t = 18;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_224: gnutls_sign_algorithm_t = 20;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_256: gnutls_sign_algorithm_t = 21;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_384: gnutls_sign_algorithm_t = 22;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SHA3_512: gnutls_sign_algorithm_t = 23;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_224: gnutls_sign_algorithm_t = 24;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_256: gnutls_sign_algorithm_t = 25;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_384: gnutls_sign_algorithm_t = 26;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_DSA_SHA3_512: gnutls_sign_algorithm_t = 27;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_224: gnutls_sign_algorithm_t = 28;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_256: gnutls_sign_algorithm_t = 29;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_384: gnutls_sign_algorithm_t = 30;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_SHA3_512: gnutls_sign_algorithm_t = 31;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_SHA256: gnutls_sign_algorithm_t = 32;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_SHA384: gnutls_sign_algorithm_t = 33;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_SHA512: gnutls_sign_algorithm_t = 34;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_EDDSA_ED25519: gnutls_sign_algorithm_t = 35;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_RAW: gnutls_sign_algorithm_t = 36;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SECP256R1_SHA256: gnutls_sign_algorithm_t = 37;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SECP384R1_SHA384: gnutls_sign_algorithm_t = 38;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_ECDSA_SECP521R1_SHA512: gnutls_sign_algorithm_t = 39;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_RSAE_SHA256: gnutls_sign_algorithm_t = 40;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_RSAE_SHA384: gnutls_sign_algorithm_t = 41;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_RSA_PSS_RSAE_SHA512: gnutls_sign_algorithm_t = 42;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_GOST_94: gnutls_sign_algorithm_t = 43;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_GOST_256: gnutls_sign_algorithm_t = 44;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_GOST_512: gnutls_sign_algorithm_t = 45;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_EDDSA_ED448: gnutls_sign_algorithm_t = 46;
pub const gnutls_sign_algorithm_t_GNUTLS_SIGN_MAX: gnutls_sign_algorithm_t = 46;
pub type gnutls_sign_algorithm_t = ::std::os::raw::c_uint;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_INVALID: gnutls_ecc_curve_t = 0;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP224R1: gnutls_ecc_curve_t = 1;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP256R1: gnutls_ecc_curve_t = 2;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP384R1: gnutls_ecc_curve_t = 3;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP521R1: gnutls_ecc_curve_t = 4;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_SECP192R1: gnutls_ecc_curve_t = 5;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_X25519: gnutls_ecc_curve_t = 6;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_ED25519: gnutls_ecc_curve_t = 7;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPA: gnutls_ecc_curve_t = 8;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPB: gnutls_ecc_curve_t = 9;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPC: gnutls_ecc_curve_t = 10;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPXA: gnutls_ecc_curve_t = 11;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256CPXB: gnutls_ecc_curve_t = 12;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST512A: gnutls_ecc_curve_t = 13;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST512B: gnutls_ecc_curve_t = 14;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST512C: gnutls_ecc_curve_t = 15;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256A: gnutls_ecc_curve_t = 16;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256B: gnutls_ecc_curve_t = 17;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256C: gnutls_ecc_curve_t = 18;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_GOST256D: gnutls_ecc_curve_t = 19;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_X448: gnutls_ecc_curve_t = 20;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_ED448: gnutls_ecc_curve_t = 21;
pub const gnutls_ecc_curve_t_GNUTLS_ECC_CURVE_MAX: gnutls_ecc_curve_t = 21;
pub type gnutls_ecc_curve_t = ::std::os::raw::c_uint;
pub const gnutls_group_t_GNUTLS_GROUP_INVALID: gnutls_group_t = 0;
pub const gnutls_group_t_GNUTLS_GROUP_SECP192R1: gnutls_group_t = 5;
pub const gnutls_group_t_GNUTLS_GROUP_SECP224R1: gnutls_group_t = 1;
pub const gnutls_group_t_GNUTLS_GROUP_SECP256R1: gnutls_group_t = 2;
pub const gnutls_group_t_GNUTLS_GROUP_SECP384R1: gnutls_group_t = 3;
pub const gnutls_group_t_GNUTLS_GROUP_SECP521R1: gnutls_group_t = 4;
pub const gnutls_group_t_GNUTLS_GROUP_X25519: gnutls_group_t = 6;
pub const gnutls_group_t_GNUTLS_GROUP_X448: gnutls_group_t = 20;
pub const gnutls_group_t_GNUTLS_GROUP_GC256A: gnutls_group_t = 16;
pub const gnutls_group_t_GNUTLS_GROUP_GC256B: gnutls_group_t = 17;
pub const gnutls_group_t_GNUTLS_GROUP_GC256C: gnutls_group_t = 18;
pub const gnutls_group_t_GNUTLS_GROUP_GC256D: gnutls_group_t = 19;
pub const gnutls_group_t_GNUTLS_GROUP_GC512A: gnutls_group_t = 13;
pub const gnutls_group_t_GNUTLS_GROUP_GC512B: gnutls_group_t = 14;
pub const gnutls_group_t_GNUTLS_GROUP_GC512C: gnutls_group_t = 15;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE2048: gnutls_group_t = 256;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE3072: gnutls_group_t = 257;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE4096: gnutls_group_t = 258;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE8192: gnutls_group_t = 259;
pub const gnutls_group_t_GNUTLS_GROUP_FFDHE6144: gnutls_group_t = 260;
pub const gnutls_group_t_GNUTLS_GROUP_MAX: gnutls_group_t = 260;
pub type gnutls_group_t = ::std::os::raw::c_uint;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_UNKNOWN: gnutls_sec_param_t = 0;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_INSECURE: gnutls_sec_param_t = 5;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_EXPORT: gnutls_sec_param_t = 10;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_VERY_WEAK: gnutls_sec_param_t = 15;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_WEAK: gnutls_sec_param_t = 20;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_LOW: gnutls_sec_param_t = 25;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_LEGACY: gnutls_sec_param_t = 30;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_MEDIUM: gnutls_sec_param_t = 35;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_HIGH: gnutls_sec_param_t = 40;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_ULTRA: gnutls_sec_param_t = 45;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_FUTURE: gnutls_sec_param_t = 50;
pub const gnutls_sec_param_t_GNUTLS_SEC_PARAM_MAX: gnutls_sec_param_t = 50;
pub type gnutls_sec_param_t = ::std::os::raw::c_uint;
pub const gnutls_channel_binding_t_GNUTLS_CB_TLS_UNIQUE: gnutls_channel_binding_t = 0;
pub const gnutls_channel_binding_t_GNUTLS_CB_TLS_SERVER_END_POINT: gnutls_channel_binding_t = 1;
pub const gnutls_channel_binding_t_GNUTLS_CB_TLS_EXPORTER: gnutls_channel_binding_t = 2;
pub type gnutls_channel_binding_t = ::std::os::raw::c_uint;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_UNKNOWN: gnutls_gost_paramset_t = 0;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_TC26_Z: gnutls_gost_paramset_t = 1;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_A: gnutls_gost_paramset_t = 2;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_B: gnutls_gost_paramset_t = 3;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_C: gnutls_gost_paramset_t = 4;
pub const gnutls_gost_paramset_t_GNUTLS_GOST_PARAMSET_CP_D: gnutls_gost_paramset_t = 5;
pub type gnutls_gost_paramset_t = ::std::os::raw::c_uint;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_CLIENT: gnutls_ctype_target_t = 0;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_SERVER: gnutls_ctype_target_t = 1;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_OURS: gnutls_ctype_target_t = 2;
pub const gnutls_ctype_target_t_GNUTLS_CTYPE_PEERS: gnutls_ctype_target_t = 3;
pub type gnutls_ctype_target_t = ::std::os::raw::c_uint;
pub type gnutls_transport_ptr_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_session_int {
    _unused: [u8; 0],
}
pub type gnutls_session_t = *mut gnutls_session_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_dh_params_int {
    _unused: [u8; 0],
}
pub type gnutls_dh_params_t = *mut gnutls_dh_params_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_privkey_int {
    _unused: [u8; 0],
}
pub type gnutls_rsa_params_t = *mut gnutls_x509_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_priority_st {
    _unused: [u8; 0],
}
pub type gnutls_priority_t = *mut gnutls_priority_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_datum_t {
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_datum_t() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_datum_t>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_datum_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_datum_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_datum_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_datum_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_datum_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_datum_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_datum_t),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_library_config_st {
    pub name: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gnutls_library_config_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_library_config_st>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_library_config_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_library_config_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_library_config_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_library_config_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_library_config_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_library_config_st>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_library_config_st),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_params_st {
    pub type_: gnutls_params_type_t,
    pub params: gnutls_params_st_params,
    pub deinit: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnutls_params_st_params {
    pub dh: gnutls_dh_params_t,
    pub rsa_export: gnutls_rsa_params_t,
}
#[test]
fn bindgen_test_layout_gnutls_params_st_params() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_params_st_params>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_params_st_params))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_params_st_params>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_params_st_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st_params>())).dh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st_params),
            "::",
            stringify!(dh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_params_st_params>())).rsa_export as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st_params),
            "::",
            stringify!(rsa_export)
        )
    );
}
#[test]
fn bindgen_test_layout_gnutls_params_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_params_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_params_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_params_st>())).deinit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_params_st),
            "::",
            stringify!(deinit)
        )
    );
}
pub type gnutls_params_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        arg2: gnutls_params_type_t,
        arg3: *mut gnutls_params_st,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_init(
        session: *mut gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_deinit(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_bye(
        session: gnutls_session_t,
        how: gnutls_close_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_handshake(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_reauth(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_handshake_set_timeout(session: gnutls_session_t, ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_rehandshake(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_key_update(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alert_get(session: gnutls_session_t) -> gnutls_alert_description_t;
}
extern "C" {
    pub fn gnutls_alert_send(
        session: gnutls_session_t,
        level: gnutls_alert_level_t,
        desc: gnutls_alert_description_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alert_send_appropriate(
        session: gnutls_session_t,
        err: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alert_get_name(
        alert: gnutls_alert_description_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_alert_get_strname(
        alert: gnutls_alert_description_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_pk_bits_to_sec_param(
        algo: gnutls_pk_algorithm_t,
        bits: ::std::os::raw::c_uint,
    ) -> gnutls_sec_param_t;
}
extern "C" {
    pub fn gnutls_sec_param_get_name(param: gnutls_sec_param_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_sec_param_to_pk_bits(
        algo: gnutls_pk_algorithm_t,
        param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_sec_param_to_symmetric_bits(param: gnutls_sec_param_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_name(curve: gnutls_ecc_curve_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_oid(curve: gnutls_ecc_curve_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_group_get_name(group: gnutls_group_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_size(curve: gnutls_ecc_curve_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ecc_curve_get(session: gnutls_session_t) -> gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_group_get(session: gnutls_session_t) -> gnutls_group_t;
}
extern "C" {
    pub fn gnutls_cipher_get(session: gnutls_session_t) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_early_cipher_get(session: gnutls_session_t) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_kx_get(session: gnutls_session_t) -> gnutls_kx_algorithm_t;
}
extern "C" {
    pub fn gnutls_mac_get(session: gnutls_session_t) -> gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_prf_hash_get(session: gnutls_session_t) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_early_prf_hash_get(session: gnutls_session_t) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_certificate_type_get(session: gnutls_session_t) -> gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_certificate_type_get2(
        session: gnutls_session_t,
        target: gnutls_ctype_target_t,
    ) -> gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get_client(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_sign_algorithm_get_requested(
        session: gnutls_session_t,
        indx: size_t,
        algo: *mut gnutls_sign_algorithm_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_cipher_get_name(
        algorithm: gnutls_cipher_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_mac_get_name(algorithm: gnutls_mac_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_digest_get_name(
        algorithm: gnutls_digest_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_digest_get_oid(
        algorithm: gnutls_digest_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_kx_get_name(algorithm: gnutls_kx_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_certificate_type_get_name(
        type_: gnutls_certificate_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_pk_get_name(algorithm: gnutls_pk_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_pk_get_oid(algorithm: gnutls_pk_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_sign_get_name(
        algorithm: gnutls_sign_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_sign_get_oid(sign: gnutls_sign_algorithm_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_gost_paramset_get_name(
        param: gnutls_gost_paramset_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_gost_paramset_get_oid(
        param: gnutls_gost_paramset_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_cipher_get_key_size(algorithm: gnutls_cipher_algorithm_t) -> size_t;
}
extern "C" {
    pub fn gnutls_mac_get_key_size(algorithm: gnutls_mac_algorithm_t) -> size_t;
}
extern "C" {
    pub fn gnutls_sign_is_secure(algorithm: gnutls_sign_algorithm_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_sign_is_secure2(
        algorithm: gnutls_sign_algorithm_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_sign_get_hash_algorithm(
        sign: gnutls_sign_algorithm_t,
    ) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_get_pk_algorithm(sign: gnutls_sign_algorithm_t) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_pk_to_sign(
        pk: gnutls_pk_algorithm_t,
        hash: gnutls_digest_algorithm_t,
    ) -> gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_supports_pk_algorithm(
        sign: gnutls_sign_algorithm_t,
        pk: gnutls_pk_algorithm_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_mac_get_id(name: *const ::std::os::raw::c_char) -> gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_digest_get_id(name: *const ::std::os::raw::c_char) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_cipher_get_id(name: *const ::std::os::raw::c_char) -> gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_kx_get_id(name: *const ::std::os::raw::c_char) -> gnutls_kx_algorithm_t;
}
extern "C" {
    pub fn gnutls_protocol_get_id(name: *const ::std::os::raw::c_char) -> gnutls_protocol_t;
}
extern "C" {
    pub fn gnutls_certificate_type_get_id(
        name: *const ::std::os::raw::c_char,
    ) -> gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_pk_get_id(name: *const ::std::os::raw::c_char) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_get_id(name: *const ::std::os::raw::c_char) -> gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_id(name: *const ::std::os::raw::c_char) -> gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_ecc_curve_get_pk(curve: gnutls_ecc_curve_t) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_group_get_id(name: *const ::std::os::raw::c_char) -> gnutls_group_t;
}
extern "C" {
    pub fn gnutls_oid_to_digest(oid: *const ::std::os::raw::c_char) -> gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_mac(oid: *const ::std::os::raw::c_char) -> gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_pk(oid: *const ::std::os::raw::c_char) -> gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_sign(oid: *const ::std::os::raw::c_char) -> gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_oid_to_ecc_curve(oid: *const ::std::os::raw::c_char) -> gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_oid_to_gost_paramset(
        oid: *const ::std::os::raw::c_char,
    ) -> gnutls_gost_paramset_t;
}
extern "C" {
    pub fn gnutls_ecc_curve_list() -> *const gnutls_ecc_curve_t;
}
extern "C" {
    pub fn gnutls_group_list() -> *const gnutls_group_t;
}
extern "C" {
    pub fn gnutls_cipher_list() -> *const gnutls_cipher_algorithm_t;
}
extern "C" {
    pub fn gnutls_mac_list() -> *const gnutls_mac_algorithm_t;
}
extern "C" {
    pub fn gnutls_digest_list() -> *const gnutls_digest_algorithm_t;
}
extern "C" {
    pub fn gnutls_protocol_list() -> *const gnutls_protocol_t;
}
extern "C" {
    pub fn gnutls_certificate_type_list() -> *const gnutls_certificate_type_t;
}
extern "C" {
    pub fn gnutls_kx_list() -> *const gnutls_kx_algorithm_t;
}
extern "C" {
    pub fn gnutls_pk_list() -> *const gnutls_pk_algorithm_t;
}
extern "C" {
    pub fn gnutls_sign_list() -> *const gnutls_sign_algorithm_t;
}
extern "C" {
    pub fn gnutls_cipher_suite_info(
        idx: size_t,
        cs_id: *mut ::std::os::raw::c_uchar,
        kx: *mut gnutls_kx_algorithm_t,
        cipher: *mut gnutls_cipher_algorithm_t,
        mac: *mut gnutls_mac_algorithm_t,
        min_version: *mut gnutls_protocol_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ecc_curve_set_enabled(
        curve: gnutls_ecc_curve_t,
        enabled: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_sign_set_secure(
        sign: gnutls_sign_algorithm_t,
        secure: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_sign_set_secure_for_certs(
        sign: gnutls_sign_algorithm_t,
        secure: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_digest_set_secure(
        dig: gnutls_digest_algorithm_t,
        secure: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_protocol_set_enabled(
        version: gnutls_protocol_t,
        enabled: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_error_is_fatal(error: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_error_to_alert(
        err: ::std::os::raw::c_int,
        level: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_perror(error: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gnutls_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_strerror_name(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_handshake_set_private_extensions(
        session: gnutls_session_t,
        allow: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_handshake_set_random(
        session: gnutls_session_t,
        random: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_handshake_get_last_out(
        session: gnutls_session_t,
    ) -> gnutls_handshake_description_t;
}
extern "C" {
    pub fn gnutls_handshake_get_last_in(
        session: gnutls_session_t,
    ) -> gnutls_handshake_description_t;
}
extern "C" {
    pub fn gnutls_heartbeat_ping(
        session: gnutls_session_t,
        data_size: size_t,
        max_tries: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_heartbeat_pong(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_set_timeout(session: gnutls_session_t, ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_record_disable_padding(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_cork(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_uncork(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_discard_queued(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_get_state(
        session: gnutls_session_t,
        read: ::std::os::raw::c_uint,
        mac_key: *mut gnutls_datum_t,
        IV: *mut gnutls_datum_t,
        cipher_key: *mut gnutls_datum_t,
        seq_number: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_set_state(
        session: gnutls_session_t,
        read: ::std::os::raw::c_uint,
        seq_number: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_range_st {
    pub low: size_t,
    pub high: size_t,
}
#[test]
fn bindgen_test_layout_gnutls_range_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_range_st>(),
        16usize,
        concat!("Size of: ", stringify!(gnutls_range_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_range_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_range_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_range_st>())).low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_range_st),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_range_st>())).high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_range_st),
            "::",
            stringify!(high)
        )
    );
}
extern "C" {
    pub fn gnutls_range_split(
        session: gnutls_session_t,
        orig: *const gnutls_range_st,
        small_range: *mut gnutls_range_st,
        rem_range: *mut gnutls_range_st,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_send(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_send2(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
        pad: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_send_range(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
        range: *const gnutls_range_st,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_recv(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbuffer_st {
    _unused: [u8; 0],
}
pub type gnutls_packet_t = *mut mbuffer_st;
extern "C" {
    pub fn gnutls_record_recv_packet(
        session: gnutls_session_t,
        packet: *mut gnutls_packet_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_packet_get(
        packet: gnutls_packet_t,
        data: *mut gnutls_datum_t,
        sequence: *mut ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn gnutls_packet_deinit(packet: gnutls_packet_t);
}
extern "C" {
    pub fn gnutls_record_recv_seq(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_size: size_t,
        seq: *mut ::std::os::raw::c_uchar,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_overhead_size(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_est_record_overhead_size(
        version: gnutls_protocol_t,
        cipher: gnutls_cipher_algorithm_t,
        mac: gnutls_mac_algorithm_t,
        comp: gnutls_compression_method_t,
        flags: ::std::os::raw::c_uint,
    ) -> size_t;
}
extern "C" {
    pub fn gnutls_session_enable_compatibility_mode(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_record_can_use_length_hiding(session: gnutls_session_t)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_record_get_direction(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_get_max_size(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_set_max_size(session: gnutls_session_t, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_set_max_recv_size(session: gnutls_session_t, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_check_pending(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_check_corked(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_get_max_early_data_size(session: gnutls_session_t) -> size_t;
}
extern "C" {
    pub fn gnutls_record_set_max_early_data_size(
        session: gnutls_session_t,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_record_send_early_data(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_record_recv_early_data(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn gnutls_session_force_valid(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_prf(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        server_random_first: ::std::os::raw::c_int,
        extra_size: size_t,
        extra: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_prf_rfc5705(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        context_size: size_t,
        context: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_prf_early(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        context_size: size_t,
        context: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_prf_raw(
        session: gnutls_session_t,
        label_size: size_t,
        label: *const ::std::os::raw::c_char,
        seed_size: size_t,
        seed: *const ::std::os::raw::c_char,
        outsize: size_t,
        out: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_server_name_type_t_GNUTLS_NAME_DNS: gnutls_server_name_type_t = 1;
pub type gnutls_server_name_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_server_name_set(
        session: gnutls_session_t,
        type_: gnutls_server_name_type_t,
        name: *const ::std::os::raw::c_void,
        name_length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_server_name_get(
        session: gnutls_session_t,
        data: *mut ::std::os::raw::c_void,
        data_length: *mut size_t,
        type_: *mut ::std::os::raw::c_uint,
        indx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_heartbeat_get_timeout(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_heartbeat_set_timeouts(
        session: gnutls_session_t,
        retrans_timeout: ::std::os::raw::c_uint,
        total_timeout: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_heartbeat_enable(session: gnutls_session_t, type_: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_heartbeat_allowed(
        session: gnutls_session_t,
        type_: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_safe_renegotiation_status(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_session_ext_master_secret_status(
        session: gnutls_session_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_session_etm_status(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_SAFE_RENEGOTIATION: gnutls_session_flags_t = 1;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_EXT_MASTER_SECRET: gnutls_session_flags_t = 2;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_ETM: gnutls_session_flags_t = 4;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_HB_LOCAL_SEND: gnutls_session_flags_t = 8;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_HB_PEER_SEND: gnutls_session_flags_t = 16;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_FALSE_START: gnutls_session_flags_t = 32;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_RFC7919: gnutls_session_flags_t = 64;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_SESSION_TICKET: gnutls_session_flags_t = 128;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_POST_HANDSHAKE_AUTH: gnutls_session_flags_t = 256;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_EARLY_START: gnutls_session_flags_t = 512;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_EARLY_DATA: gnutls_session_flags_t = 1024;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_CLI_REQUESTED_OCSP: gnutls_session_flags_t = 2048;
pub const gnutls_session_flags_t_GNUTLS_SFLAGS_SERV_REQUESTED_OCSP: gnutls_session_flags_t = 4096;
pub type gnutls_session_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_session_get_flags(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
pub const gnutls_supplemental_data_format_type_t_GNUTLS_SUPPLEMENTAL_UNKNOWN:
    gnutls_supplemental_data_format_type_t = 0;
pub type gnutls_supplemental_data_format_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_supplemental_get_name(
        type_: gnutls_supplemental_data_format_type_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_session_ticket_key_generate(key: *mut gnutls_datum_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_enable_client(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_enable_server(
        session: gnutls_session_t,
        key: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ticket_send(
        session: gnutls_session_t,
        nr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_AES128_CM_HMAC_SHA1_80: gnutls_srtp_profile_t = 1;
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_AES128_CM_HMAC_SHA1_32: gnutls_srtp_profile_t = 2;
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_NULL_HMAC_SHA1_80: gnutls_srtp_profile_t = 5;
pub const gnutls_srtp_profile_t_GNUTLS_SRTP_NULL_HMAC_SHA1_32: gnutls_srtp_profile_t = 6;
pub type gnutls_srtp_profile_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_srtp_set_profile(
        session: gnutls_session_t,
        profile: gnutls_srtp_profile_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_set_profile_direct(
        session: gnutls_session_t,
        profiles: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_selected_profile(
        session: gnutls_session_t,
        profile: *mut gnutls_srtp_profile_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_profile_name(
        profile: gnutls_srtp_profile_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_srtp_get_profile_id(
        name: *const ::std::os::raw::c_char,
        profile: *mut gnutls_srtp_profile_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_keys(
        session: gnutls_session_t,
        key_material: *mut ::std::os::raw::c_void,
        key_material_size: ::std::os::raw::c_uint,
        client_key: *mut gnutls_datum_t,
        client_salt: *mut gnutls_datum_t,
        server_key: *mut gnutls_datum_t,
        server_salt: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_set_mki(
        session: gnutls_session_t,
        mki: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srtp_get_mki(
        session: gnutls_session_t,
        mki: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_alpn_flags_t_GNUTLS_ALPN_MANDATORY: gnutls_alpn_flags_t = 1;
pub const gnutls_alpn_flags_t_GNUTLS_ALPN_SERVER_PRECEDENCE: gnutls_alpn_flags_t = 2;
pub type gnutls_alpn_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_alpn_get_selected_protocol(
        session: gnutls_session_t,
        protocol: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_alpn_set_protocols(
        session: gnutls_session_t,
        protocols: *const gnutls_datum_t,
        protocols_size: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_key_generate(
        key: *mut gnutls_datum_t,
        key_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_init(
        priority_cache: *mut gnutls_priority_t,
        priorities: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_init2(
        priority_cache: *mut gnutls_priority_t,
        priorities: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_deinit(priority_cache: gnutls_priority_t);
}
extern "C" {
    pub fn gnutls_priority_get_cipher_suite_index(
        pcache: gnutls_priority_t,
        idx: ::std::os::raw::c_uint,
        sidx: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_string_list(
        iter: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_priority_set(
        session: gnutls_session_t,
        priority: gnutls_priority_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_set_direct(
        session: gnutls_session_t,
        priorities: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_certificate_type_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_certificate_type_list2(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
        target: gnutls_ctype_target_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_sign_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_protocol_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_ecc_curve_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_group_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_kx_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_cipher_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_priority_mac_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_get_system_config_file() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_set_default_priority(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_set_default_priority_append(
        session: gnutls_session_t,
        add_prio: *const ::std::os::raw::c_char,
        err_pos: *mut *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_cipher_suite_get_name(
        kx_algorithm: gnutls_kx_algorithm_t,
        cipher_algorithm: gnutls_cipher_algorithm_t,
        mac_algorithm: gnutls_mac_algorithm_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_protocol_get_version(session: gnutls_session_t) -> gnutls_protocol_t;
}
extern "C" {
    pub fn gnutls_protocol_get_name(version: gnutls_protocol_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_session_set_data(
        session: gnutls_session_t,
        session_data: *const ::std::os::raw::c_void,
        session_data_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_data(
        session: gnutls_session_t,
        session_data: *mut ::std::os::raw::c_void,
        session_data_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_data2(
        session: gnutls_session_t,
        data: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_random(
        session: gnutls_session_t,
        client: *mut gnutls_datum_t,
        server: *mut gnutls_datum_t,
    );
}
extern "C" {
    pub fn gnutls_session_get_master_secret(session: gnutls_session_t, secret: *mut gnutls_datum_t);
}
extern "C" {
    pub fn gnutls_session_get_desc(session: gnutls_session_t) -> *mut ::std::os::raw::c_char;
}
pub type gnutls_certificate_verify_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_session_t) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn gnutls_session_set_verify_function(
        session: gnutls_session_t,
        func: gnutls_certificate_verify_function,
    );
}
pub const gnutls_vdata_types_t_GNUTLS_DT_UNKNOWN: gnutls_vdata_types_t = 0;
pub const gnutls_vdata_types_t_GNUTLS_DT_DNS_HOSTNAME: gnutls_vdata_types_t = 1;
pub const gnutls_vdata_types_t_GNUTLS_DT_KEY_PURPOSE_OID: gnutls_vdata_types_t = 2;
pub const gnutls_vdata_types_t_GNUTLS_DT_RFC822NAME: gnutls_vdata_types_t = 3;
pub const gnutls_vdata_types_t_GNUTLS_DT_IP_ADDRESS: gnutls_vdata_types_t = 4;
pub type gnutls_vdata_types_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_typed_vdata_st {
    pub type_: gnutls_vdata_types_t,
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gnutls_typed_vdata_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_typed_vdata_st>(),
        24usize,
        concat!("Size of: ", stringify!(gnutls_typed_vdata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_typed_vdata_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_typed_vdata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_typed_vdata_st>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_typed_vdata_st),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn gnutls_session_set_verify_cert(
        session: gnutls_session_t,
        hostname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_session_set_verify_cert2(
        session: gnutls_session_t,
        data: *mut gnutls_typed_vdata_st,
        elements: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_session_get_verify_cert_status(arg1: gnutls_session_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_session_set_premaster(
        session: gnutls_session_t,
        entity: ::std::os::raw::c_uint,
        version: gnutls_protocol_t,
        kx: gnutls_kx_algorithm_t,
        cipher: gnutls_cipher_algorithm_t,
        mac: gnutls_mac_algorithm_t,
        comp: gnutls_compression_method_t,
        master: *const gnutls_datum_t,
        session_id: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_id(
        session: gnutls_session_t,
        session_id: *mut ::std::os::raw::c_void,
        session_id_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_get_id2(
        session: gnutls_session_t,
        session_id: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_set_id(
        session: gnutls_session_t,
        sid: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_channel_binding(
        session: gnutls_session_t,
        cbtype: gnutls_channel_binding_t,
        cb: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_is_resumed(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_resumption_requested(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
pub type gnutls_db_store_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        key: gnutls_datum_t,
        data: gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_db_remove_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        key: gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_db_retr_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, key: gnutls_datum_t) -> gnutls_datum_t,
>;
extern "C" {
    pub fn gnutls_db_set_cache_expiration(
        session: gnutls_session_t,
        seconds: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_db_get_default_cache_expiration() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_db_remove_session(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_db_set_retrieve_function(
        session: gnutls_session_t,
        retr_func: gnutls_db_retr_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_remove_function(
        session: gnutls_session_t,
        rem_func: gnutls_db_remove_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_store_function(
        session: gnutls_session_t,
        store_func: gnutls_db_store_func,
    );
}
extern "C" {
    pub fn gnutls_db_set_ptr(session: gnutls_session_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gnutls_db_get_ptr(session: gnutls_session_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gnutls_db_check_entry(
        session: gnutls_session_t,
        session_entry: gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_db_check_entry_time(entry: *mut gnutls_datum_t) -> time_t;
}
extern "C" {
    pub fn gnutls_db_check_entry_expire_time(entry: *mut gnutls_datum_t) -> time_t;
}
pub type gnutls_handshake_hook_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        htype: ::std::os::raw::c_uint,
        when: ::std::os::raw::c_uint,
        incoming: ::std::os::raw::c_uint,
        msg: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_hook_function(
        session: gnutls_session_t,
        htype: ::std::os::raw::c_uint,
        when: ::std::os::raw::c_int,
        func: gnutls_handshake_hook_func,
    );
}
pub type gnutls_handshake_simple_hook_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: gnutls_session_t) -> ::std::os::raw::c_int>;
extern "C" {
    pub fn gnutls_handshake_set_post_client_hello_function(
        session: gnutls_session_t,
        func: gnutls_handshake_simple_hook_func,
    );
}
extern "C" {
    pub fn gnutls_handshake_set_max_packet_length(session: gnutls_session_t, max: size_t);
}
extern "C" {
    pub fn gnutls_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_credentials_clear(session: gnutls_session_t);
}
extern "C" {
    pub fn gnutls_credentials_set(
        session: gnutls_session_t,
        type_: gnutls_credentials_type_t,
        cred: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_credentials_get(
        session: gnutls_session_t,
        type_: gnutls_credentials_type_t,
        cred: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pubkey_st {
    _unused: [u8; 0],
}
pub type gnutls_pubkey_t = *mut gnutls_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_privkey_st {
    _unused: [u8; 0],
}
pub type gnutls_privkey_t = *mut gnutls_privkey_st;
pub type gnutls_x509_privkey_t = *mut gnutls_x509_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crl_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crl_t = *mut gnutls_x509_crl_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crt_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crt_t = *mut gnutls_x509_crt_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_x509_crq_int {
    _unused: [u8; 0],
}
pub type gnutls_x509_crq_t = *mut gnutls_x509_crq_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_keyring_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_keyring_t = *mut gnutls_openpgp_keyring_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_certificate_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_certificate_credentials_t = *mut gnutls_certificate_credentials_st;
pub type gnutls_certificate_server_credentials = gnutls_certificate_credentials_t;
pub type gnutls_certificate_client_credentials = gnutls_certificate_credentials_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anon_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_anon_server_credentials_t = *mut gnutls_anon_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anon_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_anon_client_credentials_t = *mut gnutls_anon_client_credentials_st;
extern "C" {
    pub fn gnutls_anon_free_server_credentials(sc: gnutls_anon_server_credentials_t);
}
extern "C" {
    pub fn gnutls_anon_allocate_server_credentials(
        sc: *mut gnutls_anon_server_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_anon_set_server_dh_params(
        res: gnutls_anon_server_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_anon_set_server_known_dh_params(
        res: gnutls_anon_server_credentials_t,
        sec_param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_anon_set_server_params_function(
        res: gnutls_anon_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_anon_free_client_credentials(sc: gnutls_anon_client_credentials_t);
}
extern "C" {
    pub fn gnutls_anon_allocate_client_credentials(
        sc: *mut gnutls_anon_client_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_free_credentials(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_allocate_credentials(
        res: *mut gnutls_certificate_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_issuer(
        sc: gnutls_certificate_credentials_t,
        cert: gnutls_x509_crt_t,
        issuer: *mut gnutls_x509_crt_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_crt_raw(
        sc: gnutls_certificate_credentials_t,
        idx1: ::std::os::raw::c_uint,
        idx2: ::std::os::raw::c_uint,
        cert: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_free_keys(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_cas(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_ca_names(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_free_crls(sc: gnutls_certificate_credentials_t);
}
extern "C" {
    pub fn gnutls_certificate_set_dh_params(
        res: gnutls_certificate_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_known_dh_params(
        res: gnutls_certificate_credentials_t,
        sec_param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_verify_flags(
        res: gnutls_certificate_credentials_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_verify_flags(
        res: gnutls_certificate_credentials_t,
    ) -> ::std::os::raw::c_uint;
}
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_SKIP_KEY_CERT_MATCH:
    gnutls_certificate_flags = 1;
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_API_V2: gnutls_certificate_flags = 2;
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_SKIP_OCSP_RESPONSE_CHECK:
    gnutls_certificate_flags = 4;
pub const gnutls_certificate_flags_GNUTLS_CERTIFICATE_VERIFY_CRLS: gnutls_certificate_flags = 8;
pub type gnutls_certificate_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_certificate_set_flags(
        arg1: gnutls_certificate_credentials_t,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_verify_limits(
        res: gnutls_certificate_credentials_t,
        max_bits: ::std::os::raw::c_uint,
        max_depth: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_x509_system_trust(
        cred: gnutls_certificate_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_file(
        cred: gnutls_certificate_credentials_t,
        cafile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_dir(
        cred: gnutls_certificate_credentials_t,
        ca_dir: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust_mem(
        res: gnutls_certificate_credentials_t,
        ca: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl_file(
        res: gnutls_certificate_credentials_t,
        crlfile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl_mem(
        res: gnutls_certificate_credentials_t,
        CRL: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_file(
        res: gnutls_certificate_credentials_t,
        certfile: *const ::std::os::raw::c_char,
        keyfile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_file2(
        res: gnutls_certificate_credentials_t,
        certfile: *const ::std::os::raw::c_char,
        keyfile: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_mem(
        res: gnutls_certificate_credentials_t,
        cert: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key_mem2(
        res: gnutls_certificate_credentials_t,
        cert: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_send_x509_rdn_sequence(
        session: gnutls_session_t,
        status: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_x509_simple_pkcs12_file(
        res: gnutls_certificate_credentials_t,
        pkcs12file: *const ::std::os::raw::c_char,
        type_: gnutls_x509_crt_fmt_t,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_simple_pkcs12_mem(
        res: gnutls_certificate_credentials_t,
        p12blob: *const gnutls_datum_t,
        type_: gnutls_x509_crt_fmt_t,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_key(
        res: gnutls_certificate_credentials_t,
        cert_list: *mut gnutls_x509_crt_t,
        cert_list_size: ::std::os::raw::c_int,
        key: gnutls_x509_privkey_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_trust(
        res: gnutls_certificate_credentials_t,
        ca_list: *mut gnutls_x509_crt_t,
        ca_list_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_x509_crl(
        res: gnutls_certificate_credentials_t,
        crl_list: *mut gnutls_x509_crl_t,
        crl_list_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_x509_key(
        res: gnutls_certificate_credentials_t,
        index: ::std::os::raw::c_uint,
        key: *mut gnutls_x509_privkey_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_get_x509_crt(
        res: gnutls_certificate_credentials_t,
        index: ::std::os::raw::c_uint,
        crt_list: *mut *mut gnutls_x509_crt_t,
        crt_list_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_status_request_ocsp_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        ptr: *mut ::std::os::raw::c_void,
        ocsp_response: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_function(
        res: gnutls_certificate_credentials_t,
        ocsp_func: gnutls_status_request_ocsp_func,
        ptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_function2(
        res: gnutls_certificate_credentials_t,
        idx: ::std::os::raw::c_uint,
        ocsp_func: gnutls_status_request_ocsp_func,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_file(
        res: gnutls_certificate_credentials_t,
        response_file: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_file2(
        res: gnutls_certificate_credentials_t,
        response_file: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_uint,
        fmt: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_ocsp_status_request_mem(
        res: gnutls_certificate_credentials_t,
        resp: *const gnutls_datum_t,
        idx: ::std::os::raw::c_uint,
        fmt: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_ocsp_data_st {
    pub version: ::std::os::raw::c_uint,
    pub response: gnutls_datum_t,
    pub exptime: time_t,
    pub padding: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_gnutls_ocsp_data_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_ocsp_data_st>(),
        64usize,
        concat!("Size of: ", stringify!(gnutls_ocsp_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_ocsp_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_ocsp_data_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).response as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).exptime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(exptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_ocsp_data_st>())).padding as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_ocsp_data_st),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn gnutls_certificate_get_ocsp_expiration(
        sc: gnutls_certificate_credentials_t,
        idx: ::std::os::raw::c_uint,
        oidx: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> time_t;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_enable_client(
        session: gnutls_session_t,
        responder_id: *mut gnutls_datum_t,
        responder_id_size: size_t,
        request_extensions: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_get(
        session: gnutls_session_t,
        response: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_is_checked(
        session: gnutls_session_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_ocsp_status_request_get2(
        session: gnutls_session_t,
        idx: ::std::os::raw::c_uint,
        response: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_rawpk_key_mem(
        cred: gnutls_certificate_credentials_t,
        spki: *const gnutls_datum_t,
        pkey: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        key_usage: ::std::os::raw::c_uint,
        names: *mut *const ::std::os::raw::c_char,
        names_length: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_rawpk_key_file(
        cred: gnutls_certificate_credentials_t,
        rawpkfile: *const ::std::os::raw::c_char,
        privkeyfile: *const ::std::os::raw::c_char,
        format: gnutls_x509_crt_fmt_t,
        pass: *const ::std::os::raw::c_char,
        key_usage: ::std::os::raw::c_uint,
        names: *mut *const ::std::os::raw::c_char,
        names_length: ::std::os::raw::c_uint,
        privkey_flags: ::std::os::raw::c_uint,
        pkcs11_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_global_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_global_deinit();
}
extern "C" {
    pub fn gnutls_get_library_config() -> *const gnutls_library_config_st;
}
pub type gnutls_time_func = ::std::option::Option<unsafe extern "C" fn(t: *mut time_t) -> time_t>;
pub type mutex_init_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type mutex_lock_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type mutex_unlock_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type mutex_deinit_func = ::std::option::Option<
    unsafe extern "C" fn(mutex: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_global_set_mutex(
        init: mutex_init_func,
        deinit: mutex_deinit_func,
        lock: mutex_lock_func,
        unlock: mutex_unlock_func,
    );
}
pub type gnutls_alloc_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>;
pub type gnutls_calloc_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: size_t, arg2: size_t) -> *mut ::std::os::raw::c_void,
>;
pub type gnutls_is_secure_function = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type gnutls_free_function =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type gnutls_realloc_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn gnutls_global_set_time_function(time_func: gnutls_time_func);
}
extern "C" {
    pub static mut gnutls_malloc: gnutls_alloc_function;
}
extern "C" {
    pub static mut gnutls_realloc: gnutls_realloc_function;
}
extern "C" {
    pub static mut gnutls_calloc: gnutls_calloc_function;
}
extern "C" {
    pub static mut gnutls_free: gnutls_free_function;
}
extern "C" {
    pub static mut gnutls_strdup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub fn gnutls_memset(data: *mut ::std::os::raw::c_void, c: ::std::os::raw::c_int, size: size_t);
}
extern "C" {
    pub fn gnutls_memcmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_log_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
pub type gnutls_audit_log_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: gnutls_session_t, arg2: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn gnutls_global_set_log_function(log_func: gnutls_log_func);
}
extern "C" {
    pub fn gnutls_global_set_audit_log_function(log_func: gnutls_audit_log_func);
}
extern "C" {
    pub fn gnutls_global_set_log_level(level: ::std::os::raw::c_int);
}
pub type gnutls_keylog_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        label: *const ::std::os::raw::c_char,
        secret: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_session_get_keylog_function(session: gnutls_session_t) -> gnutls_keylog_func;
}
extern "C" {
    pub fn gnutls_session_set_keylog_function(session: gnutls_session_t, func: gnutls_keylog_func);
}
extern "C" {
    pub fn gnutls_dh_params_init(dh_params: *mut gnutls_dh_params_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_deinit(dh_params: gnutls_dh_params_t);
}
extern "C" {
    pub fn gnutls_dh_params_import_raw(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_dsa(
        dh_params: gnutls_dh_params_t,
        key: gnutls_x509_privkey_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_raw2(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
        key_bits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_raw3(
        dh_params: gnutls_dh_params_t,
        prime: *const gnutls_datum_t,
        q: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_import_pkcs3(
        params: gnutls_dh_params_t,
        pkcs3_params: *const gnutls_datum_t,
        format: gnutls_x509_crt_fmt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_generate2(
        params: gnutls_dh_params_t,
        bits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export_pkcs3(
        params: gnutls_dh_params_t,
        format: gnutls_x509_crt_fmt_t,
        params_data: *mut ::std::os::raw::c_uchar,
        params_data_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export2_pkcs3(
        params: gnutls_dh_params_t,
        format: gnutls_x509_crt_fmt_t,
        out: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_export_raw(
        params: gnutls_dh_params_t,
        prime: *mut gnutls_datum_t,
        generator: *mut gnutls_datum_t,
        bits: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_params_cpy(
        dst: gnutls_dh_params_t,
        src: gnutls_dh_params_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
pub type giovec_t = iovec;
pub type gnutls_pull_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t,
>;
pub type gnutls_push_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t,
>;
extern "C" {
    pub fn gnutls_system_recv_timeout(
        ptr: gnutls_transport_ptr_t,
        ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_pull_timeout_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_vec_push_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_transport_ptr_t,
        iov: *const giovec_t,
        iovcnt: ::std::os::raw::c_int,
    ) -> ssize_t,
>;
pub type gnutls_errno_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: gnutls_transport_ptr_t) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_transport_set_int2(
        session: gnutls_session_t,
        r: ::std::os::raw::c_int,
        s: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_transport_get_int2(
        session: gnutls_session_t,
        r: *mut ::std::os::raw::c_int,
        s: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gnutls_transport_get_int(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_transport_set_ptr(session: gnutls_session_t, ptr: gnutls_transport_ptr_t);
}
extern "C" {
    pub fn gnutls_transport_set_ptr2(
        session: gnutls_session_t,
        recv_ptr: gnutls_transport_ptr_t,
        send_ptr: gnutls_transport_ptr_t,
    );
}
extern "C" {
    pub fn gnutls_transport_get_ptr(session: gnutls_session_t) -> gnutls_transport_ptr_t;
}
extern "C" {
    pub fn gnutls_transport_get_ptr2(
        session: gnutls_session_t,
        recv_ptr: *mut gnutls_transport_ptr_t,
        send_ptr: *mut gnutls_transport_ptr_t,
    );
}
extern "C" {
    pub fn gnutls_transport_set_vec_push_function(
        session: gnutls_session_t,
        vec_func: gnutls_vec_push_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_push_function(
        session: gnutls_session_t,
        push_func: gnutls_push_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_pull_function(
        session: gnutls_session_t,
        pull_func: gnutls_pull_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_pull_timeout_function(
        session: gnutls_session_t,
        func: gnutls_pull_timeout_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_errno_function(
        session: gnutls_session_t,
        errno_func: gnutls_errno_func,
    );
}
extern "C" {
    pub fn gnutls_transport_set_errno(session: gnutls_session_t, err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gnutls_session_set_ptr(session: gnutls_session_t, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gnutls_session_get_ptr(session: gnutls_session_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gnutls_openpgp_send_cert(session: gnutls_session_t, status: gnutls_openpgp_crt_status_t);
}
extern "C" {
    pub fn gnutls_fingerprint(
        algo: gnutls_digest_algorithm_t,
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_void,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_random_art_GNUTLS_RANDOM_ART_OPENSSH: gnutls_random_art = 1;
pub type gnutls_random_art = ::std::os::raw::c_uint;
pub use self::gnutls_random_art as gnutls_random_art_t;
extern "C" {
    pub fn gnutls_random_art(
        type_: gnutls_random_art_t,
        key_type: *const ::std::os::raw::c_char,
        key_size: ::std::os::raw::c_uint,
        fpr: *mut ::std::os::raw::c_void,
        fpr_size: size_t,
        art: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_idna_map(
        input: *const ::std::os::raw::c_char,
        ilen: ::std::os::raw::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_idna_reverse_map(
        input: *const ::std::os::raw::c_char,
        ilen: ::std::os::raw::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_srp_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_srp_server_credentials_t = *mut gnutls_srp_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_srp_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_srp_client_credentials_t = *mut gnutls_srp_client_credentials_st;
extern "C" {
    pub fn gnutls_srp_free_client_credentials(sc: gnutls_srp_client_credentials_t);
}
extern "C" {
    pub fn gnutls_srp_allocate_client_credentials(
        sc: *mut gnutls_srp_client_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_client_credentials(
        res: gnutls_srp_client_credentials_t,
        username: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_free_server_credentials(sc: gnutls_srp_server_credentials_t);
}
extern "C" {
    pub fn gnutls_srp_allocate_server_credentials(
        sc: *mut gnutls_srp_server_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_server_credentials_file(
        res: gnutls_srp_server_credentials_t,
        password_file: *const ::std::os::raw::c_char,
        password_conf_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_server_get_username(
        session: gnutls_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_srp_set_prime_bits(session: gnutls_session_t, bits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_srp_verifier(
        username: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
        salt: *const gnutls_datum_t,
        generator: *const gnutls_datum_t,
        prime: *const gnutls_datum_t,
        res: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static gnutls_srp_8192_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_8192_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_4096_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_4096_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_3072_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_3072_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_2048_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_2048_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1536_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1536_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1024_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_srp_1024_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_8192_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_6144_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_6144_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_6144_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_6144_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_4096_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_4096_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_4096_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_4096_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_3072_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_3072_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_3072_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_3072_key_bits: ::std::os::raw::c_uint;
}
extern "C" {
    pub static gnutls_ffdhe_2048_group_prime: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_2048_group_q: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_2048_group_generator: gnutls_datum_t;
}
extern "C" {
    pub static gnutls_ffdhe_2048_key_bits: ::std::os::raw::c_uint;
}
pub type gnutls_srp_server_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const ::std::os::raw::c_char,
        salt: *mut gnutls_datum_t,
        verifier: *mut gnutls_datum_t,
        generator: *mut gnutls_datum_t,
        prime: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_srp_set_server_credentials_function(
        cred: gnutls_srp_server_credentials_t,
        func: gnutls_srp_server_credentials_function,
    );
}
pub type gnutls_srp_client_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_srp_set_client_credentials_function(
        cred: gnutls_srp_client_credentials_t,
        func: gnutls_srp_client_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_srp_base64_encode(
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_decode(
        b64_data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_base64_decode2(
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_srp_set_server_fake_salt_seed(
        sc: gnutls_srp_server_credentials_t,
        seed: *const gnutls_datum_t,
        salt_length: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_psk_server_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_psk_server_credentials_t = *mut gnutls_psk_server_credentials_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_psk_client_credentials_st {
    _unused: [u8; 0],
}
pub type gnutls_psk_client_credentials_t = *mut gnutls_psk_client_credentials_st;
pub const gnutls_psk_key_flags_GNUTLS_PSK_KEY_RAW: gnutls_psk_key_flags = 0;
pub const gnutls_psk_key_flags_GNUTLS_PSK_KEY_HEX: gnutls_psk_key_flags = 1;
pub type gnutls_psk_key_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_psk_free_client_credentials(sc: gnutls_psk_client_credentials_t);
}
extern "C" {
    pub fn gnutls_psk_allocate_client_credentials(
        sc: *mut gnutls_psk_client_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials(
        res: gnutls_psk_client_credentials_t,
        username: *const ::std::os::raw::c_char,
        key: *const gnutls_datum_t,
        flags: gnutls_psk_key_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials2(
        res: gnutls_psk_client_credentials_t,
        username: *const gnutls_datum_t,
        key: *const gnutls_datum_t,
        flags: gnutls_psk_key_flags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_free_server_credentials(sc: gnutls_psk_server_credentials_t);
}
extern "C" {
    pub fn gnutls_psk_allocate_server_credentials(
        sc: *mut gnutls_psk_server_credentials_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_file(
        res: gnutls_psk_server_credentials_t,
        password_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_hint(
        res: gnutls_psk_server_credentials_t,
        hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_server_get_username(
        session: gnutls_session_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_psk_server_get_username2(
        session: gnutls_session_t,
        out: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_client_get_hint(session: gnutls_session_t) -> *const ::std::os::raw::c_char;
}
pub type gnutls_psk_server_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const ::std::os::raw::c_char,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_psk_server_credentials_function2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *const gnutls_datum_t,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_psk_set_server_credentials_function(
        cred: gnutls_psk_server_credentials_t,
        func: gnutls_psk_server_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_server_credentials_function2(
        cred: gnutls_psk_server_credentials_t,
        func: gnutls_psk_server_credentials_function2,
    );
}
pub type gnutls_psk_client_credentials_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *mut *mut ::std::os::raw::c_char,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_psk_client_credentials_function2 = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        username: *mut gnutls_datum_t,
        key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_psk_set_client_credentials_function(
        cred: gnutls_psk_client_credentials_t,
        func: gnutls_psk_client_credentials_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_client_credentials_function2(
        cred: gnutls_psk_client_credentials_t,
        func: gnutls_psk_client_credentials_function2,
    );
}
extern "C" {
    pub fn gnutls_hex_encode(
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_hex_decode(
        hex_data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_void,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_hex_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_hex_decode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_dh_params(
        res: gnutls_psk_server_credentials_t,
        dh_params: gnutls_dh_params_t,
    );
}
extern "C" {
    pub fn gnutls_psk_set_server_known_dh_params(
        res: gnutls_psk_server_credentials_t,
        sec_param: gnutls_sec_param_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_psk_set_server_params_function(
        res: gnutls_psk_server_credentials_t,
        func: gnutls_params_function,
    );
}
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_DNSNAME: gnutls_x509_subject_alt_name_t = 1;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_RFC822NAME: gnutls_x509_subject_alt_name_t = 2;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_URI: gnutls_x509_subject_alt_name_t = 3;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_IPADDRESS: gnutls_x509_subject_alt_name_t = 4;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_OTHERNAME: gnutls_x509_subject_alt_name_t = 5;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_DN: gnutls_x509_subject_alt_name_t = 6;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_REGISTERED_ID: gnutls_x509_subject_alt_name_t =
    7;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_MAX: gnutls_x509_subject_alt_name_t = 7;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_OTHERNAME_XMPP: gnutls_x509_subject_alt_name_t =
    1000;
pub const gnutls_x509_subject_alt_name_t_GNUTLS_SAN_OTHERNAME_KRB5PRINCIPAL:
    gnutls_x509_subject_alt_name_t = 1001;
pub type gnutls_x509_subject_alt_name_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_crt_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_crt_t = *mut gnutls_openpgp_crt_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_openpgp_privkey_int {
    _unused: [u8; 0],
}
pub type gnutls_openpgp_privkey_t = *mut gnutls_openpgp_privkey_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_pkcs11_privkey_st {
    _unused: [u8; 0],
}
pub type gnutls_pkcs11_privkey_t = *mut gnutls_pkcs11_privkey_st;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_X509: gnutls_privkey_type_t = 0;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_OPENPGP: gnutls_privkey_type_t = 1;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_PKCS11: gnutls_privkey_type_t = 2;
pub const gnutls_privkey_type_t_GNUTLS_PRIVKEY_EXT: gnutls_privkey_type_t = 3;
pub type gnutls_privkey_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnutls_retr2_st {
    pub cert_type: gnutls_certificate_type_t,
    pub key_type: gnutls_privkey_type_t,
    pub cert: gnutls_retr2_st__bindgen_ty_1,
    pub ncerts: ::std::os::raw::c_uint,
    pub key: gnutls_retr2_st__bindgen_ty_2,
    pub deinit_all: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnutls_retr2_st__bindgen_ty_1 {
    pub x509: *mut gnutls_x509_crt_t,
    pub pgp: gnutls_openpgp_crt_t,
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_1>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_1),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_1>())).pgp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_1),
            "::",
            stringify!(pgp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnutls_retr2_st__bindgen_ty_2 {
    pub x509: gnutls_x509_privkey_t,
    pub pgp: gnutls_openpgp_privkey_t,
    pub pkcs11: gnutls_pkcs11_privkey_t,
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).x509 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).pgp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(pgp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gnutls_retr2_st__bindgen_ty_2>())).pkcs11 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st__bindgen_ty_2),
            "::",
            stringify!(pkcs11)
        )
    );
}
#[test]
fn bindgen_test_layout_gnutls_retr2_st() {
    assert_eq!(
        ::std::mem::size_of::<gnutls_retr2_st>(),
        40usize,
        concat!("Size of: ", stringify!(gnutls_retr2_st))
    );
    assert_eq!(
        ::std::mem::align_of::<gnutls_retr2_st>(),
        8usize,
        concat!("Alignment of ", stringify!(gnutls_retr2_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).cert_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(cert_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).key_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(key_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).cert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).ncerts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(ncerts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gnutls_retr2_st>())).deinit_all as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gnutls_retr2_st),
            "::",
            stringify!(deinit_all)
        )
    );
}
extern "C" {
    pub fn gnutls_auth_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t;
}
extern "C" {
    pub fn gnutls_auth_server_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t;
}
extern "C" {
    pub fn gnutls_auth_client_get_type(session: gnutls_session_t) -> gnutls_credentials_type_t;
}
extern "C" {
    pub fn gnutls_dh_set_prime_bits(session: gnutls_session_t, bits: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gnutls_dh_get_secret_bits(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_peers_public_bits(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_prime_bits(session: gnutls_session_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_group(
        session: gnutls_session_t,
        raw_gen: *mut gnutls_datum_t,
        raw_prime: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_dh_get_pubkey(
        session: gnutls_session_t,
        raw_key: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_certificate_retrieve_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: gnutls_session_t,
        req_ca_rdn: *const gnutls_datum_t,
        nreqs: ::std::os::raw::c_int,
        pk_algos: *const gnutls_pk_algorithm_t,
        pk_algos_length: ::std::os::raw::c_int,
        arg2: *mut gnutls_retr2_st,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_retrieve_function(
        cred: gnutls_certificate_credentials_t,
        func: gnutls_certificate_retrieve_function,
    );
}
extern "C" {
    pub fn gnutls_certificate_set_verify_function(
        cred: gnutls_certificate_credentials_t,
        func: gnutls_certificate_verify_function,
    );
}
extern "C" {
    pub fn gnutls_certificate_server_set_request(
        session: gnutls_session_t,
        req: gnutls_certificate_request_t,
    );
}
extern "C" {
    pub fn gnutls_certificate_get_peers(
        session: gnutls_session_t,
        list_size: *mut ::std::os::raw::c_uint,
    ) -> *const gnutls_datum_t;
}
extern "C" {
    pub fn gnutls_certificate_get_ours(session: gnutls_session_t) -> *const gnutls_datum_t;
}
extern "C" {
    pub fn gnutls_certificate_get_peers_subkey_id(
        session: gnutls_session_t,
        id: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_activation_time_peers(session: gnutls_session_t) -> time_t;
}
extern "C" {
    pub fn gnutls_certificate_expiration_time_peers(session: gnutls_session_t) -> time_t;
}
extern "C" {
    pub fn gnutls_certificate_client_get_request_status(
        session: gnutls_session_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers2(
        session: gnutls_session_t,
        status: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers3(
        session: gnutls_session_t,
        hostname: *const ::std::os::raw::c_char,
        status: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verify_peers(
        session: gnutls_session_t,
        data: *mut gnutls_typed_vdata_st,
        elements: ::std::os::raw::c_uint,
        status: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_verification_status_print(
        status: ::std::os::raw::c_uint,
        type_: gnutls_certificate_type_t,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_encode(
        msg: *const ::std::os::raw::c_char,
        data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_char,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_decode(
        header: *const ::std::os::raw::c_char,
        b64_data: *const gnutls_datum_t,
        result: *mut ::std::os::raw::c_uchar,
        result_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_encode2(
        msg: *const ::std::os::raw::c_char,
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_pem_base64_decode2(
        header: *const ::std::os::raw::c_char,
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_base64_encode2(
        data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_base64_decode2(
        b64_data: *const gnutls_datum_t,
        result: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_certificate_set_params_function(
        res: gnutls_certificate_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_anon_set_params_function(
        res: gnutls_anon_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_psk_set_params_function(
        res: gnutls_psk_server_credentials_t,
        func: gnutls_params_function,
    );
}
extern "C" {
    pub fn gnutls_hex2bin(
        hex_data: *const ::std::os::raw::c_char,
        hex_size: size_t,
        bin_data: *mut ::std::os::raw::c_void,
        bin_size: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_tdb_store_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        expiration: time_t,
        pubkey: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_tdb_store_commitment_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        expiration: time_t,
        hash_algo: gnutls_digest_algorithm_t,
        hash: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_tdb_verify_func = ::std::option::Option<
    unsafe extern "C" fn(
        db_name: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        pubkey: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_tdb_int {
    _unused: [u8; 0],
}
pub type gnutls_tdb_t = *mut gnutls_tdb_int;
extern "C" {
    pub fn gnutls_tdb_init(tdb: *mut gnutls_tdb_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_tdb_set_store_func(tdb: gnutls_tdb_t, store: gnutls_tdb_store_func);
}
extern "C" {
    pub fn gnutls_tdb_set_store_commitment_func(
        tdb: gnutls_tdb_t,
        cstore: gnutls_tdb_store_commitment_func,
    );
}
extern "C" {
    pub fn gnutls_tdb_set_verify_func(tdb: gnutls_tdb_t, verify: gnutls_tdb_verify_func);
}
extern "C" {
    pub fn gnutls_tdb_deinit(tdb: gnutls_tdb_t);
}
extern "C" {
    pub fn gnutls_verify_stored_pubkey(
        db_name: *const ::std::os::raw::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        cert_type: gnutls_certificate_type_t,
        cert: *const gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_store_commitment(
        db_name: *const ::std::os::raw::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hash_algo: gnutls_digest_algorithm_t,
        hash: *const gnutls_datum_t,
        expiration: time_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_store_pubkey(
        db_name: *const ::std::os::raw::c_char,
        tdb: gnutls_tdb_t,
        host: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        cert_type: gnutls_certificate_type_t,
        cert: *const gnutls_datum_t,
        expiration: time_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_load_file(
        filename: *const ::std::os::raw::c_char,
        data: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_url_is_supported(url: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
pub const gnutls_pin_flag_t_GNUTLS_PIN_USER: gnutls_pin_flag_t = 1;
pub const gnutls_pin_flag_t_GNUTLS_PIN_SO: gnutls_pin_flag_t = 2;
pub const gnutls_pin_flag_t_GNUTLS_PIN_FINAL_TRY: gnutls_pin_flag_t = 4;
pub const gnutls_pin_flag_t_GNUTLS_PIN_COUNT_LOW: gnutls_pin_flag_t = 8;
pub const gnutls_pin_flag_t_GNUTLS_PIN_CONTEXT_SPECIFIC: gnutls_pin_flag_t = 16;
pub const gnutls_pin_flag_t_GNUTLS_PIN_WRONG: gnutls_pin_flag_t = 32;
pub type gnutls_pin_flag_t = ::std::os::raw::c_uint;
pub type gnutls_pin_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        attempt: ::std::os::raw::c_int,
        token_url: *const ::std::os::raw::c_char,
        token_label: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        pin: *mut ::std::os::raw::c_char,
        pin_max: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_certificate_set_pin_function(
        arg1: gnutls_certificate_credentials_t,
        fn_: gnutls_pin_callback_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_buffer_st {
    _unused: [u8; 0],
}
pub type gnutls_buffer_t = *mut gnutls_buffer_st;
extern "C" {
    pub fn gnutls_buffer_append_data(
        arg1: gnutls_buffer_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_utf8_password_normalize(
        password: *const ::std::os::raw::c_uchar,
        password_len: ::std::os::raw::c_uint,
        out: *mut gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_ext_priv_data_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn gnutls_ext_set_data(
        session: gnutls_session_t,
        type_: ::std::os::raw::c_uint,
        arg1: gnutls_ext_priv_data_t,
    );
}
extern "C" {
    pub fn gnutls_ext_get_data(
        session: gnutls_session_t,
        type_: ::std::os::raw::c_uint,
        arg1: *mut gnutls_ext_priv_data_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ext_get_current_msg(session: gnutls_session_t) -> ::std::os::raw::c_uint;
}
pub type gnutls_ext_recv_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_send_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        extdata: gnutls_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_deinit_data_func =
    ::std::option::Option<unsafe extern "C" fn(data: gnutls_ext_priv_data_t)>;
pub type gnutls_ext_pack_func = ::std::option::Option<
    unsafe extern "C" fn(
        data: gnutls_ext_priv_data_t,
        packed_data: gnutls_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_unpack_func = ::std::option::Option<
    unsafe extern "C" fn(
        packed_data: gnutls_buffer_t,
        data: *mut gnutls_ext_priv_data_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_ext_raw_process_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        tls_id: ::std::os::raw::c_uint,
        data: *const ::std::os::raw::c_uchar,
        data_size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_ext_raw_parse(
        ctx: *mut ::std::os::raw::c_void,
        cb: gnutls_ext_raw_process_func,
        data: *const gnutls_datum_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_ANY: gnutls_ext_parse_type_t = 0;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_APPLICATION: gnutls_ext_parse_type_t = 1;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_TLS: gnutls_ext_parse_type_t = 2;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_MANDATORY: gnutls_ext_parse_type_t = 3;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_NONE: gnutls_ext_parse_type_t = 4;
pub const gnutls_ext_parse_type_t_GNUTLS_EXT_VERSION_NEG: gnutls_ext_parse_type_t = 5;
pub type gnutls_ext_parse_type_t = ::std::os::raw::c_uint;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_OVERRIDE_INTERNAL: gnutls_ext_flags_t = 1;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_CLIENT_HELLO: gnutls_ext_flags_t = 2;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_TLS12_SERVER_HELLO: gnutls_ext_flags_t = 4;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_TLS13_SERVER_HELLO: gnutls_ext_flags_t = 8;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_EE: gnutls_ext_flags_t = 16;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_HRR: gnutls_ext_flags_t = 32;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_IGNORE_CLIENT_REQUEST: gnutls_ext_flags_t = 64;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_TLS: gnutls_ext_flags_t = 128;
pub const gnutls_ext_flags_t_GNUTLS_EXT_FLAG_DTLS: gnutls_ext_flags_t = 256;
pub type gnutls_ext_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_ext_register(
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        parse_point: gnutls_ext_parse_type_t,
        recv_func: gnutls_ext_recv_func,
        send_func: gnutls_ext_send_func,
        deinit_func: gnutls_ext_deinit_data_func,
        pack_func: gnutls_ext_pack_func,
        unpack_func: gnutls_ext_unpack_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_ext_register(
        arg1: gnutls_session_t,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        parse_point: gnutls_ext_parse_type_t,
        recv_func: gnutls_ext_recv_func,
        send_func: gnutls_ext_send_func,
        deinit_func: gnutls_ext_deinit_data_func,
        pack_func: gnutls_ext_pack_func,
        unpack_func: gnutls_ext_unpack_func,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_ext_get_name(ext: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_ext_get_name2(
        session: gnutls_session_t,
        tls_id: ::std::os::raw::c_uint,
        parse_point: gnutls_ext_parse_type_t,
    ) -> *const ::std::os::raw::c_char;
}
pub type gnutls_supp_recv_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        data: *const ::std::os::raw::c_uchar,
        data_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type gnutls_supp_send_func = ::std::option::Option<
    unsafe extern "C" fn(session: gnutls_session_t, buf: gnutls_buffer_t) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_supplemental_register(
        name: *const ::std::os::raw::c_char,
        type_: gnutls_supplemental_data_format_type_t,
        supp_recv_func: gnutls_supp_recv_func,
        supp_send_func: gnutls_supp_send_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_session_supplemental_register(
        session: gnutls_session_t,
        name: *const ::std::os::raw::c_char,
        type_: gnutls_supplemental_data_format_type_t,
        supp_recv_func: gnutls_supp_recv_func,
        supp_send_func: gnutls_supp_send_func,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_supplemental_recv(
        session: gnutls_session_t,
        do_recv_supplemental: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_supplemental_send(
        session: gnutls_session_t,
        do_send_supplemental: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_anti_replay_st {
    _unused: [u8; 0],
}
pub type gnutls_anti_replay_t = *mut gnutls_anti_replay_st;
extern "C" {
    pub fn gnutls_anti_replay_init(anti_replay: *mut gnutls_anti_replay_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_anti_replay_deinit(anti_replay: gnutls_anti_replay_t);
}
extern "C" {
    pub fn gnutls_anti_replay_set_window(
        anti_replay: gnutls_anti_replay_t,
        window: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn gnutls_anti_replay_enable(session: gnutls_session_t, anti_replay: gnutls_anti_replay_t);
}
pub type gnutls_db_add_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        exp_time: time_t,
        key: *const gnutls_datum_t,
        data: *const gnutls_datum_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_anti_replay_set_add_function(
        arg1: gnutls_anti_replay_t,
        add_func: gnutls_db_add_func,
    );
}
extern "C" {
    pub fn gnutls_anti_replay_set_ptr(arg1: gnutls_anti_replay_t, ptr: *mut ::std::os::raw::c_void);
}
pub const gnutls_record_encryption_level_t_GNUTLS_ENCRYPTION_LEVEL_INITIAL:
    gnutls_record_encryption_level_t = 0;
pub const gnutls_record_encryption_level_t_GNUTLS_ENCRYPTION_LEVEL_EARLY:
    gnutls_record_encryption_level_t = 1;
pub const gnutls_record_encryption_level_t_GNUTLS_ENCRYPTION_LEVEL_HANDSHAKE:
    gnutls_record_encryption_level_t = 2;
pub const gnutls_record_encryption_level_t_GNUTLS_ENCRYPTION_LEVEL_APPLICATION:
    gnutls_record_encryption_level_t = 3;
pub type gnutls_record_encryption_level_t = ::std::os::raw::c_uint;
pub type gnutls_handshake_read_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t,
        htype: gnutls_handshake_description_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_read_function(
        session: gnutls_session_t,
        func: gnutls_handshake_read_func,
    );
}
extern "C" {
    pub fn gnutls_handshake_write(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t,
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type gnutls_handshake_secret_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t,
        secret_read: *const ::std::os::raw::c_void,
        secret_write: *const ::std::os::raw::c_void,
        secret_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_handshake_set_secret_function(
        session: gnutls_session_t,
        func: gnutls_handshake_secret_func,
    );
}
pub type gnutls_alert_read_func = ::std::option::Option<
    unsafe extern "C" fn(
        session: gnutls_session_t,
        level: gnutls_record_encryption_level_t,
        alert_level: gnutls_alert_level_t,
        alert_desc: gnutls_alert_description_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gnutls_alert_set_read_function(session: gnutls_session_t, func: gnutls_alert_read_func);
}
extern "C" {
    pub fn gnutls_fips140_mode_enabled() -> ::std::os::raw::c_uint;
}
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_DISABLED: gnutls_fips_mode_t = 0;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_STRICT: gnutls_fips_mode_t = 1;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_SELFTESTS: gnutls_fips_mode_t = 2;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_LAX: gnutls_fips_mode_t = 3;
pub const gnutls_fips_mode_t_GNUTLS_FIPS140_LOG: gnutls_fips_mode_t = 4;
pub type gnutls_fips_mode_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_fips140_set_mode(mode: gnutls_fips_mode_t, flags: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnutls_fips140_context_st {
    _unused: [u8; 0],
}
pub type gnutls_fips140_context_t = *mut gnutls_fips140_context_st;
extern "C" {
    pub fn gnutls_fips140_context_init(
        context: *mut gnutls_fips140_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_fips140_context_deinit(context: gnutls_fips140_context_t);
}
pub const gnutls_fips140_operation_state_t_GNUTLS_FIPS140_OP_INITIAL:
    gnutls_fips140_operation_state_t = 0;
pub const gnutls_fips140_operation_state_t_GNUTLS_FIPS140_OP_APPROVED:
    gnutls_fips140_operation_state_t = 1;
pub const gnutls_fips140_operation_state_t_GNUTLS_FIPS140_OP_NOT_APPROVED:
    gnutls_fips140_operation_state_t = 2;
pub const gnutls_fips140_operation_state_t_GNUTLS_FIPS140_OP_ERROR:
    gnutls_fips140_operation_state_t = 3;
pub type gnutls_fips140_operation_state_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gnutls_fips140_get_operation_state(
        context: gnutls_fips140_context_t,
    ) -> gnutls_fips140_operation_state_t;
}
extern "C" {
    pub fn gnutls_fips140_push_context(context: gnutls_fips140_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_fips140_pop_context() -> ::std::os::raw::c_int;
}
pub type gnutls_connection_end_t = ::std::os::raw::c_uint;
pub use self::gnutls_compression_method_t as gnutls_compression_method;
pub use self::gnutls_digest_algorithm_t as gnutls_digest_algorithm;
pub use self::gnutls_kx_algorithm_t as gnutls_kx_algorithm;
pub use self::gnutls_mac_algorithm_t as gnutls_mac_algorithm;
pub type gnutls_connection_end = gnutls_connection_end_t;
pub use self::gnutls_certificate_request_t as gnutls_certificate_request;
pub use self::gnutls_certificate_status_t as gnutls_certificate_status;
pub use self::gnutls_close_request_t as gnutls_close_request;
pub use self::gnutls_pk_algorithm_t as gnutls_pk_algorithm;
pub use self::gnutls_sign_algorithm_t as gnutls_sign_algorithm;
pub use self::gnutls_x509_crt_fmt_t as gnutls_x509_crt_fmt;
pub type gnutls_session = gnutls_session_t;
pub use self::gnutls_alert_description_t as gnutls_alert_description;
pub use self::gnutls_alert_level_t as gnutls_alert_level;
pub use self::gnutls_x509_subject_alt_name_t as gnutls_x509_subject_alt_name;
pub type gnutls_openpgp_privkey = gnutls_openpgp_privkey_t;
pub type gnutls_openpgp_keyring = gnutls_openpgp_keyring_t;
pub type gnutls_x509_crt = gnutls_x509_crt_t;
pub type gnutls_x509_privkey = gnutls_x509_privkey_t;
pub type gnutls_x509_crl = gnutls_x509_crl_t;
pub type gnutls_x509_crq = gnutls_x509_crq_t;
pub type gnutls_certificate_credentials = gnutls_certificate_credentials_t;
pub type gnutls_anon_server_credentials = gnutls_anon_server_credentials_t;
pub type gnutls_anon_client_credentials = gnutls_anon_client_credentials_t;
pub type gnutls_srp_client_credentials = gnutls_srp_client_credentials_t;
pub type gnutls_srp_server_credentials = gnutls_srp_server_credentials_t;
pub type gnutls_dh_params = gnutls_dh_params_t;
pub type gnutls_rsa_params = gnutls_rsa_params_t;
pub use self::gnutls_certificate_type_t as gnutls_certificate_type;
pub use self::gnutls_credentials_type_t as gnutls_credentials_type;
pub use self::gnutls_params_type_t as gnutls_params_type;
pub type gnutls_datum = gnutls_datum_t;
pub type gnutls_transport_ptr = gnutls_transport_ptr_t;
pub use self::gnutls_openpgp_crt_status_t as gnutls_openpgp_key_status_t;
pub type gnutls_openpgp_key_t = gnutls_openpgp_crt_t;
extern "C" {
    pub fn gnutls_x509_privkey_sign_hash(
        key: gnutls_x509_privkey_t,
        hash: *const gnutls_datum_t,
        signature: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_openpgp_privkey_sign_hash(
        key: gnutls_openpgp_privkey_t,
        hash: *const gnutls_datum_t,
        signature: *mut gnutls_datum_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_x509_crt_get_preferred_hash_algorithm(
        crt: gnutls_x509_crt_t,
        hash: *mut gnutls_digest_algorithm_t,
        mand: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnutls_global_set_mem_functions(
        alloc_func: gnutls_alloc_function,
        secure_alloc_func: gnutls_alloc_function,
        is_secure_func: gnutls_is_secure_function,
        realloc_func: gnutls_realloc_function,
        free_func: gnutls_free_function,
    );
}
extern "C" {
    pub fn gnutls_compression_get(session: gnutls_session_t) -> gnutls_compression_method_t;
}
extern "C" {
    pub fn gnutls_compression_get_name(
        algorithm: gnutls_compression_method_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gnutls_compression_get_id(
        name: *const ::std::os::raw::c_char,
    ) -> gnutls_compression_method_t;
}
extern "C" {
    pub fn gnutls_compression_list() -> *const gnutls_compression_method_t;
}
extern "C" {
    pub fn gnutls_priority_compression_list(
        pcache: gnutls_priority_t,
        list: *mut *const ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type key_data_t = gnutls_datum_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type plist_t = *mut ::std::os::raw::c_void;
pub type plist_dict_iter = *mut ::std::os::raw::c_void;
pub type plist_array_iter = *mut ::std::os::raw::c_void;
pub const plist_type_PLIST_NONE: plist_type = -1;
pub const plist_type_PLIST_BOOLEAN: plist_type = 0;
pub const plist_type_PLIST_INT: plist_type = 1;
pub const plist_type_PLIST_REAL: plist_type = 2;
pub const plist_type_PLIST_STRING: plist_type = 3;
pub const plist_type_PLIST_ARRAY: plist_type = 4;
pub const plist_type_PLIST_DICT: plist_type = 5;
pub const plist_type_PLIST_DATE: plist_type = 6;
pub const plist_type_PLIST_DATA: plist_type = 7;
pub const plist_type_PLIST_KEY: plist_type = 8;
pub const plist_type_PLIST_UID: plist_type = 9;
pub const plist_type_PLIST_NULL: plist_type = 10;
pub type plist_type = ::std::os::raw::c_int;
pub const plist_err_t_PLIST_ERR_SUCCESS: plist_err_t = 0;
pub const plist_err_t_PLIST_ERR_INVALID_ARG: plist_err_t = -1;
pub const plist_err_t_PLIST_ERR_FORMAT: plist_err_t = -2;
pub const plist_err_t_PLIST_ERR_PARSE: plist_err_t = -3;
pub const plist_err_t_PLIST_ERR_NO_MEM: plist_err_t = -4;
pub const plist_err_t_PLIST_ERR_IO: plist_err_t = -5;
pub const plist_err_t_PLIST_ERR_UNKNOWN: plist_err_t = -255;
pub type plist_err_t = ::std::os::raw::c_int;
pub const plist_format_t_PLIST_FORMAT_NONE: plist_format_t = 0;
pub const plist_format_t_PLIST_FORMAT_XML: plist_format_t = 1;
pub const plist_format_t_PLIST_FORMAT_BINARY: plist_format_t = 2;
pub const plist_format_t_PLIST_FORMAT_JSON: plist_format_t = 3;
pub const plist_format_t_PLIST_FORMAT_OSTEP: plist_format_t = 4;
pub const plist_format_t_PLIST_FORMAT_PRINT: plist_format_t = 10;
pub const plist_format_t_PLIST_FORMAT_LIMD: plist_format_t = 11;
pub const plist_format_t_PLIST_FORMAT_PLUTIL: plist_format_t = 12;
pub type plist_format_t = ::std::os::raw::c_uint;
pub const plist_write_options_t_PLIST_OPT_NONE: plist_write_options_t = 0;
pub const plist_write_options_t_PLIST_OPT_COMPACT: plist_write_options_t = 1;
pub const plist_write_options_t_PLIST_OPT_PARTIAL_DATA: plist_write_options_t = 2;
pub const plist_write_options_t_PLIST_OPT_NO_NEWLINE: plist_write_options_t = 4;
pub const plist_write_options_t_PLIST_OPT_INDENT: plist_write_options_t = 8;
pub type plist_write_options_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn plist_new_dict() -> plist_t;
}
extern "C" {
    pub fn plist_new_array() -> plist_t;
}
extern "C" {
    pub fn plist_new_string(val: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    pub fn plist_new_bool(val: u8) -> plist_t;
}
extern "C" {
    pub fn plist_new_uint(val: u64) -> plist_t;
}
extern "C" {
    pub fn plist_new_int(val: i64) -> plist_t;
}
extern "C" {
    pub fn plist_new_real(val: f64) -> plist_t;
}
extern "C" {
    pub fn plist_new_data(val: *const ::std::os::raw::c_char, length: u64) -> plist_t;
}
extern "C" {
    pub fn plist_new_date(sec: i32, usec: i32) -> plist_t;
}
extern "C" {
    pub fn plist_new_uid(val: u64) -> plist_t;
}
extern "C" {
    pub fn plist_new_null() -> plist_t;
}
extern "C" {
    pub fn plist_free(plist: plist_t);
}
extern "C" {
    pub fn plist_copy(node: plist_t) -> plist_t;
}
extern "C" {
    pub fn plist_array_get_size(node: plist_t) -> u32;
}
extern "C" {
    pub fn plist_array_get_item(node: plist_t, n: u32) -> plist_t;
}
extern "C" {
    pub fn plist_array_get_item_index(node: plist_t) -> u32;
}
extern "C" {
    pub fn plist_array_set_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    pub fn plist_array_append_item(node: plist_t, item: plist_t);
}
extern "C" {
    pub fn plist_array_insert_item(node: plist_t, item: plist_t, n: u32);
}
extern "C" {
    pub fn plist_array_remove_item(node: plist_t, n: u32);
}
extern "C" {
    pub fn plist_array_item_remove(node: plist_t);
}
extern "C" {
    pub fn plist_array_new_iter(node: plist_t, iter: *mut plist_array_iter);
}
extern "C" {
    pub fn plist_array_next_item(node: plist_t, iter: plist_array_iter, item: *mut plist_t);
}
extern "C" {
    pub fn plist_dict_get_size(node: plist_t) -> u32;
}
extern "C" {
    pub fn plist_dict_new_iter(node: plist_t, iter: *mut plist_dict_iter);
}
extern "C" {
    pub fn plist_dict_next_item(
        node: plist_t,
        iter: plist_dict_iter,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut plist_t,
    );
}
extern "C" {
    pub fn plist_dict_get_item_key(node: plist_t, key: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn plist_dict_get_item(node: plist_t, key: *const ::std::os::raw::c_char) -> plist_t;
}
extern "C" {
    pub fn plist_dict_item_get_key(node: plist_t) -> plist_t;
}
extern "C" {
    pub fn plist_dict_set_item(node: plist_t, key: *const ::std::os::raw::c_char, item: plist_t);
}
extern "C" {
    pub fn plist_dict_remove_item(node: plist_t, key: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn plist_dict_merge(target: *mut plist_t, source: plist_t);
}
extern "C" {
    pub fn plist_dict_get_bool(dict: plist_t, key: *const ::std::os::raw::c_char) -> u8;
}
extern "C" {
    pub fn plist_dict_get_int(dict: plist_t, key: *const ::std::os::raw::c_char) -> i64;
}
extern "C" {
    pub fn plist_dict_get_uint(dict: plist_t, key: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn plist_dict_copy_item(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_dict_copy_bool(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_dict_copy_int(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_dict_copy_uint(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_dict_copy_data(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_dict_copy_string(
        target_dict: plist_t,
        source_dict: plist_t,
        key: *const ::std::os::raw::c_char,
        alt_source_key: *const ::std::os::raw::c_char,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_get_parent(node: plist_t) -> plist_t;
}
extern "C" {
    pub fn plist_get_node_type(node: plist_t) -> plist_type;
}
extern "C" {
    pub fn plist_get_key_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn plist_get_string_val(node: plist_t, val: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn plist_get_string_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn plist_get_bool_val(node: plist_t, val: *mut u8);
}
extern "C" {
    pub fn plist_get_uint_val(node: plist_t, val: *mut u64);
}
extern "C" {
    pub fn plist_get_int_val(node: plist_t, val: *mut i64);
}
extern "C" {
    pub fn plist_get_real_val(node: plist_t, val: *mut f64);
}
extern "C" {
    pub fn plist_get_data_val(
        node: plist_t,
        val: *mut *mut ::std::os::raw::c_char,
        length: *mut u64,
    );
}
extern "C" {
    pub fn plist_get_data_ptr(node: plist_t, length: *mut u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn plist_get_date_val(node: plist_t, sec: *mut i32, usec: *mut i32);
}
extern "C" {
    pub fn plist_get_uid_val(node: plist_t, val: *mut u64);
}
extern "C" {
    pub fn plist_set_key_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn plist_set_string_val(node: plist_t, val: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn plist_set_bool_val(node: plist_t, val: u8);
}
extern "C" {
    pub fn plist_set_uint_val(node: plist_t, val: u64);
}
extern "C" {
    pub fn plist_set_int_val(node: plist_t, val: i64);
}
extern "C" {
    pub fn plist_set_real_val(node: plist_t, val: f64);
}
extern "C" {
    pub fn plist_set_data_val(node: plist_t, val: *const ::std::os::raw::c_char, length: u64);
}
extern "C" {
    pub fn plist_set_date_val(node: plist_t, sec: i32, usec: i32);
}
extern "C" {
    pub fn plist_set_uid_val(node: plist_t, val: u64);
}
extern "C" {
    pub fn plist_to_xml(
        plist: plist_t,
        plist_xml: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_to_bin(
        plist: plist_t,
        plist_bin: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_to_json(
        plist: plist_t,
        plist_json: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        prettify: ::std::os::raw::c_int,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_to_openstep(
        plist: plist_t,
        plist_openstep: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        prettify: ::std::os::raw::c_int,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_from_xml(
        plist_xml: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_from_bin(
        plist_bin: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_from_json(
        json: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_from_openstep(
        openstep: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_from_memory(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
        plist: *mut plist_t,
        format: *mut plist_format_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_read_from_file(
        filename: *const ::std::os::raw::c_char,
        plist: *mut plist_t,
        format: *mut plist_format_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_write_to_string(
        plist: plist_t,
        output: *mut *mut ::std::os::raw::c_char,
        length: *mut u32,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_write_to_stream(
        plist: plist_t,
        stream: *mut FILE,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_write_to_file(
        plist: plist_t,
        filename: *const ::std::os::raw::c_char,
        format: plist_format_t,
        options: plist_write_options_t,
    ) -> plist_err_t;
}
extern "C" {
    pub fn plist_print(plist: plist_t);
}
extern "C" {
    pub fn plist_is_binary(
        plist_data: *const ::std::os::raw::c_char,
        length: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_access_path(plist: plist_t, length: u32, ...) -> plist_t;
}
extern "C" {
    pub fn plist_access_pathv(plist: plist_t, length: u32, v: *mut __va_list_tag) -> plist_t;
}
extern "C" {
    pub fn plist_compare_node_value(node_l: plist_t, node_r: plist_t) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn plist_bool_val_is_true(boolnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_int_val_is_negative(intnode: plist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_int_val_compare(uintnode: plist_t, cmpval: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_uint_val_compare(uintnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_uid_val_compare(uidnode: plist_t, cmpval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_real_val_compare(realnode: plist_t, cmpval: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_date_val_compare(
        datenode: plist_t,
        cmpsec: i32,
        cmpusec: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_string_val_compare(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_string_val_compare_with_size(
        strnode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_string_val_contains(
        strnode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_key_val_compare(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_key_val_compare_with_size(
        keynode: plist_t,
        cmpval: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_key_val_contains(
        keynode: plist_t,
        substr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_data_val_compare(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_data_val_compare_with_size(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_data_val_contains(
        datanode: plist_t,
        cmpval: *const u8,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn plist_sort(plist: plist_t);
}
extern "C" {
    pub fn plist_mem_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn plist_set_debug(debug: ::std::os::raw::c_int);
}
extern "C" {
    pub fn libplist_version() -> *const ::std::os::raw::c_char;
}
pub const userpref_error_t_USERPREF_E_SUCCESS: userpref_error_t = 0;
pub const userpref_error_t_USERPREF_E_INVALID_ARG: userpref_error_t = -1;
pub const userpref_error_t_USERPREF_E_NOENT: userpref_error_t = -2;
pub const userpref_error_t_USERPREF_E_INVALID_CONF: userpref_error_t = -3;
pub const userpref_error_t_USERPREF_E_SSL_ERROR: userpref_error_t = -4;
pub const userpref_error_t_USERPREF_E_READ_ERROR: userpref_error_t = -5;
pub const userpref_error_t_USERPREF_E_WRITE_ERROR: userpref_error_t = -6;
pub const userpref_error_t_USERPREF_E_UNKNOWN_ERROR: userpref_error_t = -256;
#[doc = " Error Codes"]
pub type userpref_error_t = ::std::os::raw::c_int;
extern "C" {
    pub fn userpref_get_config_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn userpref_read_system_buid(
        system_buid: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn userpref_read_pair_record(
        udid: *const ::std::os::raw::c_char,
        pair_record: *mut plist_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_save_pair_record(
        udid: *const ::std::os::raw::c_char,
        device_id: u32,
        pair_record: plist_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_delete_pair_record(udid: *const ::std::os::raw::c_char) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_generate_keys_and_certs(
        pair_record: plist_t,
        public_key: key_data_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_import_key_with_name(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        key: gnutls_x509_privkey_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_import_crt_with_name(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        cert: gnutls_x509_crt_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_get_host_id(
        pair_record: plist_t,
        host_id: *mut *mut ::std::os::raw::c_char,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_set_host_id(
        pair_record: plist_t,
        host_id: *const ::std::os::raw::c_char,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_get_item_as_key_data(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        value: *mut key_data_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn pair_record_set_item_from_key_data(
        pair_record: plist_t,
        name: *const ::std::os::raw::c_char,
        value: *mut key_data_t,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_get_paired_udids(
        list: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
    ) -> userpref_error_t;
}
extern "C" {
    pub fn userpref_has_pair_record(udid: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub const idevice_error_t_IDEVICE_E_SUCCESS: idevice_error_t = 0;
pub const idevice_error_t_IDEVICE_E_INVALID_ARG: idevice_error_t = -1;
pub const idevice_error_t_IDEVICE_E_UNKNOWN_ERROR: idevice_error_t = -2;
pub const idevice_error_t_IDEVICE_E_NO_DEVICE: idevice_error_t = -3;
pub const idevice_error_t_IDEVICE_E_NOT_ENOUGH_DATA: idevice_error_t = -4;
pub const idevice_error_t_IDEVICE_E_CONNREFUSED: idevice_error_t = -5;
pub const idevice_error_t_IDEVICE_E_SSL_ERROR: idevice_error_t = -6;
pub const idevice_error_t_IDEVICE_E_TIMEOUT: idevice_error_t = -7;
pub type idevice_error_t = ::std::os::raw::c_int;
pub type idevice_t = *mut idevice_private;
pub type idevice_connection_t = *mut idevice_connection_private;
pub const idevice_options_IDEVICE_LOOKUP_USBMUX: idevice_options = 2;
pub const idevice_options_IDEVICE_LOOKUP_NETWORK: idevice_options = 4;
pub const idevice_options_IDEVICE_LOOKUP_PREFER_NETWORK: idevice_options = 8;
pub type idevice_options = ::std::os::raw::c_uint;
pub const idevice_connection_type_CONNECTION_USBMUXD: idevice_connection_type = 1;
pub const idevice_connection_type_CONNECTION_NETWORK: idevice_connection_type = 2;
pub type idevice_connection_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_info {
    pub udid: *mut ::std::os::raw::c_char,
    pub conn_type: idevice_connection_type,
    pub conn_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_idevice_info() {
    assert_eq!(
        ::std::mem::size_of::<idevice_info>(),
        24usize,
        concat!("Size of: ", stringify!(idevice_info))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_info>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_info>())).udid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_info>())).conn_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(conn_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_info>())).conn_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_info),
            "::",
            stringify!(conn_data)
        )
    );
}
pub type idevice_info_t = *mut idevice_info;
pub const idevice_event_type_IDEVICE_DEVICE_ADD: idevice_event_type = 1;
pub const idevice_event_type_IDEVICE_DEVICE_REMOVE: idevice_event_type = 2;
pub const idevice_event_type_IDEVICE_DEVICE_PAIRED: idevice_event_type = 3;
pub type idevice_event_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_event_t {
    pub event: idevice_event_type,
    pub udid: *const ::std::os::raw::c_char,
    pub conn_type: idevice_connection_type,
}
#[test]
fn bindgen_test_layout_idevice_event_t() {
    assert_eq!(
        ::std::mem::size_of::<idevice_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(idevice_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_event_t>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_event_t>())).udid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_event_t>())).conn_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_event_t),
            "::",
            stringify!(conn_type)
        )
    );
}
pub type idevice_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(event: *const idevice_event_t, user_data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_subscription_context {
    _unused: [u8; 0],
}
pub type idevice_subscription_context_t = *mut idevice_subscription_context;
extern "C" {
    pub fn idevice_set_debug_level(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn idevice_events_subscribe(
        context: *mut idevice_subscription_context_t,
        callback: idevice_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_events_unsubscribe(context: idevice_subscription_context_t) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_event_subscribe(
        callback: idevice_event_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_event_unsubscribe() -> idevice_error_t;
}
extern "C" {
    pub fn idevice_get_device_list(
        devices: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_device_list_free(devices: *mut *mut ::std::os::raw::c_char) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_get_device_list_extended(
        devices: *mut *mut idevice_info_t,
        count: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_device_list_extended_free(devices: *mut idevice_info_t) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_new(
        device: *mut idevice_t,
        udid: *const ::std::os::raw::c_char,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_new_with_options(
        device: *mut idevice_t,
        udid: *const ::std::os::raw::c_char,
        options: idevice_options,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_free(device: idevice_t) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connect(
        device: idevice_t,
        port: u16,
        connection: *mut idevice_connection_t,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_disconnect(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_send(
        connection: idevice_connection_t,
        data: *const ::std::os::raw::c_char,
        len: u32,
        sent_bytes: *mut u32,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_receive_timeout(
        connection: idevice_connection_t,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_receive(
        connection: idevice_connection_t,
        data: *mut ::std::os::raw::c_char,
        len: u32,
        recv_bytes: *mut u32,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_enable_ssl(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_disable_ssl(connection: idevice_connection_t) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_disable_bypass_ssl(
        connection: idevice_connection_t,
        sslBypass: u8,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_connection_get_fd(
        connection: idevice_connection_t,
        fd: *mut ::std::os::raw::c_int,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_get_handle(device: idevice_t, handle: *mut u32) -> idevice_error_t;
}
extern "C" {
    pub fn idevice_get_udid(
        device: idevice_t,
        udid: *mut *mut ::std::os::raw::c_char,
    ) -> idevice_error_t;
}
extern "C" {
    pub fn libimobiledevice_version() -> *const ::std::os::raw::c_char;
}
pub const lockdownd_error_t_LOCKDOWN_E_SUCCESS: lockdownd_error_t = 0;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_ARG: lockdownd_error_t = -1;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_CONF: lockdownd_error_t = -2;
pub const lockdownd_error_t_LOCKDOWN_E_PLIST_ERROR: lockdownd_error_t = -3;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_FAILED: lockdownd_error_t = -4;
pub const lockdownd_error_t_LOCKDOWN_E_SSL_ERROR: lockdownd_error_t = -5;
pub const lockdownd_error_t_LOCKDOWN_E_DICT_ERROR: lockdownd_error_t = -6;
pub const lockdownd_error_t_LOCKDOWN_E_RECEIVE_TIMEOUT: lockdownd_error_t = -7;
pub const lockdownd_error_t_LOCKDOWN_E_MUX_ERROR: lockdownd_error_t = -8;
pub const lockdownd_error_t_LOCKDOWN_E_NO_RUNNING_SESSION: lockdownd_error_t = -9;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_RESPONSE: lockdownd_error_t = -10;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_KEY: lockdownd_error_t = -11;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_VALUE: lockdownd_error_t = -12;
pub const lockdownd_error_t_LOCKDOWN_E_GET_PROHIBITED: lockdownd_error_t = -13;
pub const lockdownd_error_t_LOCKDOWN_E_SET_PROHIBITED: lockdownd_error_t = -14;
pub const lockdownd_error_t_LOCKDOWN_E_REMOVE_PROHIBITED: lockdownd_error_t = -15;
pub const lockdownd_error_t_LOCKDOWN_E_IMMUTABLE_VALUE: lockdownd_error_t = -16;
pub const lockdownd_error_t_LOCKDOWN_E_PASSWORD_PROTECTED: lockdownd_error_t = -17;
pub const lockdownd_error_t_LOCKDOWN_E_USER_DENIED_PAIRING: lockdownd_error_t = -18;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING: lockdownd_error_t = -19;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_HOST_ID: lockdownd_error_t = -20;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_HOST_ID: lockdownd_error_t = -21;
pub const lockdownd_error_t_LOCKDOWN_E_SESSION_ACTIVE: lockdownd_error_t = -22;
pub const lockdownd_error_t_LOCKDOWN_E_SESSION_INACTIVE: lockdownd_error_t = -23;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_SESSION_ID: lockdownd_error_t = -24;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_SESSION_ID: lockdownd_error_t = -25;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_SERVICE: lockdownd_error_t = -26;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_SERVICE: lockdownd_error_t = -27;
pub const lockdownd_error_t_LOCKDOWN_E_SERVICE_LIMIT: lockdownd_error_t = -28;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_PAIR_RECORD: lockdownd_error_t = -29;
pub const lockdownd_error_t_LOCKDOWN_E_SAVE_PAIR_RECORD_FAILED: lockdownd_error_t = -30;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_PAIR_RECORD: lockdownd_error_t = -31;
pub const lockdownd_error_t_LOCKDOWN_E_INVALID_ACTIVATION_RECORD: lockdownd_error_t = -32;
pub const lockdownd_error_t_LOCKDOWN_E_MISSING_ACTIVATION_RECORD: lockdownd_error_t = -33;
pub const lockdownd_error_t_LOCKDOWN_E_SERVICE_PROHIBITED: lockdownd_error_t = -34;
pub const lockdownd_error_t_LOCKDOWN_E_ESCROW_LOCKED: lockdownd_error_t = -35;
pub const lockdownd_error_t_LOCKDOWN_E_PAIRING_PROHIBITED_OVER_THIS_CONNECTION: lockdownd_error_t =
    -36;
pub const lockdownd_error_t_LOCKDOWN_E_FMIP_PROTECTED: lockdownd_error_t = -37;
pub const lockdownd_error_t_LOCKDOWN_E_MC_PROTECTED: lockdownd_error_t = -38;
pub const lockdownd_error_t_LOCKDOWN_E_MC_CHALLENGE_REQUIRED: lockdownd_error_t = -39;
pub const lockdownd_error_t_LOCKDOWN_E_UNKNOWN_ERROR: lockdownd_error_t = -256;
pub type lockdownd_error_t = ::std::os::raw::c_int;
pub type lockdownd_client_t = *mut lockdownd_client_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_pair_record {
    pub device_certificate: *mut ::std::os::raw::c_char,
    pub host_certificate: *mut ::std::os::raw::c_char,
    pub root_certificate: *mut ::std::os::raw::c_char,
    pub host_id: *mut ::std::os::raw::c_char,
    pub system_buid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lockdownd_pair_record() {
    assert_eq!(
        ::std::mem::size_of::<lockdownd_pair_record>(),
        40usize,
        concat!("Size of: ", stringify!(lockdownd_pair_record))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_pair_record>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_pair_record))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).device_certificate as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(device_certificate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).host_certificate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(host_certificate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).root_certificate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(root_certificate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_pair_record>())).host_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(host_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_pair_record>())).system_buid as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_pair_record),
            "::",
            stringify!(system_buid)
        )
    );
}
pub type lockdownd_pair_record_t = *mut lockdownd_pair_record;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_service_descriptor {
    pub port: u16,
    pub ssl_enabled: u8,
    pub identifier: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lockdownd_service_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<lockdownd_service_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(lockdownd_service_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_service_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_service_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_service_descriptor>())).port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_service_descriptor>())).ssl_enabled as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(ssl_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_service_descriptor>())).identifier as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_service_descriptor),
            "::",
            stringify!(identifier)
        )
    );
}
pub type lockdownd_service_descriptor_t = *mut lockdownd_service_descriptor;
pub const lockdownd_cu_pairing_cb_type_t_LOCKDOWN_CU_PAIRING_PIN_REQUESTED:
    lockdownd_cu_pairing_cb_type_t = 0;
pub const lockdownd_cu_pairing_cb_type_t_LOCKDOWN_CU_PAIRING_DEVICE_INFO:
    lockdownd_cu_pairing_cb_type_t = 1;
pub const lockdownd_cu_pairing_cb_type_t_LOCKDOWN_CU_PAIRING_ERROR: lockdownd_cu_pairing_cb_type_t =
    2;
pub type lockdownd_cu_pairing_cb_type_t = ::std::os::raw::c_uint;
pub type lockdownd_cu_pairing_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        cb_type: lockdownd_cu_pairing_cb_type_t,
        user_data: *mut ::std::os::raw::c_void,
        data_ptr: *mut ::std::os::raw::c_void,
        data_size: *mut ::std::os::raw::c_uint,
    ),
>;
extern "C" {
    pub fn lockdownd_client_new(
        device: idevice_t,
        client: *mut lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_client_new_with_handshake(
        device: idevice_t,
        client: *mut lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_client_free(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_query_type(
        client: lockdownd_client_t,
        type_: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_get_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_set_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_remove_value(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_start_service(
        client: lockdownd_client_t,
        identifier: *const ::std::os::raw::c_char,
        service: *mut lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_start_service_with_escrow_bag(
        client: lockdownd_client_t,
        identifier: *const ::std::os::raw::c_char,
        service: *mut lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_start_session(
        client: lockdownd_client_t,
        host_id: *const ::std::os::raw::c_char,
        session_id: *mut *mut ::std::os::raw::c_char,
        ssl_enabled: *mut ::std::os::raw::c_int,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_stop_session(
        client: lockdownd_client_t,
        session_id: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_send(client: lockdownd_client_t, plist: plist_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_receive(client: lockdownd_client_t, plist: *mut plist_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_pair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_pair_with_options(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
        options: plist_t,
        response: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_validate_pair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_unpair(
        client: lockdownd_client_t,
        pair_record: lockdownd_pair_record_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_activate(
        client: lockdownd_client_t,
        activation_record: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_deactivate(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_enter_recovery(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_goodbye(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_cu_pairing_create(
        client: lockdownd_client_t,
        pairing_callback: lockdownd_cu_pairing_cb_t,
        cb_user_data: *mut ::std::os::raw::c_void,
        host_info: plist_t,
        acl: plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_cu_send_request_and_get_reply(
        client: lockdownd_client_t,
        request: *const ::std::os::raw::c_char,
        request_payload: plist_t,
        reply: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_get_value_cu(
        client: lockdownd_client_t,
        domain: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_pair_cu(client: lockdownd_client_t) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_client_set_label(
        client: lockdownd_client_t,
        label: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn lockdownd_get_device_udid(
        client: lockdownd_client_t,
        udid: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_get_device_name(
        client: lockdownd_client_t,
        device_name: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_get_sync_data_classes(
        client: lockdownd_client_t,
        classes: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_data_classes_free(
        classes: *mut *mut ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_service_descriptor_free(
        service: lockdownd_service_descriptor_t,
    ) -> lockdownd_error_t;
}
extern "C" {
    pub fn lockdownd_strerror(err: lockdownd_error_t) -> *const ::std::os::raw::c_char;
}
pub const afc_error_t_AFC_E_SUCCESS: afc_error_t = 0;
pub const afc_error_t_AFC_E_UNKNOWN_ERROR: afc_error_t = 1;
pub const afc_error_t_AFC_E_OP_HEADER_INVALID: afc_error_t = 2;
pub const afc_error_t_AFC_E_NO_RESOURCES: afc_error_t = 3;
pub const afc_error_t_AFC_E_READ_ERROR: afc_error_t = 4;
pub const afc_error_t_AFC_E_WRITE_ERROR: afc_error_t = 5;
pub const afc_error_t_AFC_E_UNKNOWN_PACKET_TYPE: afc_error_t = 6;
pub const afc_error_t_AFC_E_INVALID_ARG: afc_error_t = 7;
pub const afc_error_t_AFC_E_OBJECT_NOT_FOUND: afc_error_t = 8;
pub const afc_error_t_AFC_E_OBJECT_IS_DIR: afc_error_t = 9;
pub const afc_error_t_AFC_E_PERM_DENIED: afc_error_t = 10;
pub const afc_error_t_AFC_E_SERVICE_NOT_CONNECTED: afc_error_t = 11;
pub const afc_error_t_AFC_E_OP_TIMEOUT: afc_error_t = 12;
pub const afc_error_t_AFC_E_TOO_MUCH_DATA: afc_error_t = 13;
pub const afc_error_t_AFC_E_END_OF_DATA: afc_error_t = 14;
pub const afc_error_t_AFC_E_OP_NOT_SUPPORTED: afc_error_t = 15;
pub const afc_error_t_AFC_E_OBJECT_EXISTS: afc_error_t = 16;
pub const afc_error_t_AFC_E_OBJECT_BUSY: afc_error_t = 17;
pub const afc_error_t_AFC_E_NO_SPACE_LEFT: afc_error_t = 18;
pub const afc_error_t_AFC_E_OP_WOULD_BLOCK: afc_error_t = 19;
pub const afc_error_t_AFC_E_IO_ERROR: afc_error_t = 20;
pub const afc_error_t_AFC_E_OP_INTERRUPTED: afc_error_t = 21;
pub const afc_error_t_AFC_E_OP_IN_PROGRESS: afc_error_t = 22;
pub const afc_error_t_AFC_E_INTERNAL_ERROR: afc_error_t = 23;
pub const afc_error_t_AFC_E_MUX_ERROR: afc_error_t = 30;
pub const afc_error_t_AFC_E_NO_MEM: afc_error_t = 31;
pub const afc_error_t_AFC_E_NOT_ENOUGH_DATA: afc_error_t = 32;
pub const afc_error_t_AFC_E_DIR_NOT_EMPTY: afc_error_t = 33;
pub const afc_error_t_AFC_E_FORCE_SIGNED_TYPE: afc_error_t = -1;
#[doc = " Error Codes"]
pub type afc_error_t = ::std::os::raw::c_int;
#[doc = "< r   O_RDONLY"]
pub const afc_file_mode_t_AFC_FOPEN_RDONLY: afc_file_mode_t = 1;
#[doc = "< r+  O_RDWR   | O_CREAT"]
pub const afc_file_mode_t_AFC_FOPEN_RW: afc_file_mode_t = 2;
#[doc = "< w   O_WRONLY | O_CREAT  | O_TRUNC"]
pub const afc_file_mode_t_AFC_FOPEN_WRONLY: afc_file_mode_t = 3;
#[doc = "< w+  O_RDWR   | O_CREAT  | O_TRUNC"]
pub const afc_file_mode_t_AFC_FOPEN_WR: afc_file_mode_t = 4;
#[doc = "< a   O_WRONLY | O_APPEND | O_CREAT"]
pub const afc_file_mode_t_AFC_FOPEN_APPEND: afc_file_mode_t = 5;
#[doc = "< a+  O_RDWR   | O_APPEND | O_CREAT"]
pub const afc_file_mode_t_AFC_FOPEN_RDAPPEND: afc_file_mode_t = 6;
#[doc = " Flags for afc_file_open"]
pub type afc_file_mode_t = ::std::os::raw::c_uint;
pub const afc_link_type_t_AFC_HARDLINK: afc_link_type_t = 1;
pub const afc_link_type_t_AFC_SYMLINK: afc_link_type_t = 2;
#[doc = " Type of link for afc_make_link() calls"]
pub type afc_link_type_t = ::std::os::raw::c_uint;
#[doc = "< shared lock"]
pub const afc_lock_op_t_AFC_LOCK_SH: afc_lock_op_t = 5;
#[doc = "< exclusive lock"]
pub const afc_lock_op_t_AFC_LOCK_EX: afc_lock_op_t = 6;
#[doc = "< unlock"]
pub const afc_lock_op_t_AFC_LOCK_UN: afc_lock_op_t = 12;
#[doc = " Lock operation flags"]
pub type afc_lock_op_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct afc_client_private {
    _unused: [u8; 0],
}
pub type afc_client_t = *mut afc_client_private;
extern "C" {
    #[doc = " Makes a connection to the AFC service on the device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated afc_client_t"]
    #[doc = "        upon successful return."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success, AFC_E_INVALID_ARG if device or service is"]
    #[doc = "         invalid, AFC_E_MUX_ERROR if the connection cannot be established,"]
    #[doc = "         or AFC_E_NO_MEM if there is a memory allocation problem."]
    pub fn afc_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut afc_client_t,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Starts a new AFC service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated afc_client_t upon"]
    #[doc = "        successful return. Must be freed using afc_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "        Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success, or an AFC_E_* error code otherwise."]
    pub fn afc_client_start_service(
        device: idevice_t,
        client: *mut afc_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Frees up an AFC client. If the connection was created by the client itself,"]
    #[doc = " the connection will be closed."]
    #[doc = ""]
    #[doc = " @param client The client to free."]
    pub fn afc_client_free(client: afc_client_t) -> afc_error_t;
}
extern "C" {
    #[doc = " Get device information for a connected client. The device information"]
    #[doc = " returned is the device model as well as the free space, the total capacity"]
    #[doc = " and blocksize on the accessed disk partition."]
    #[doc = ""]
    #[doc = " @param client The client to get device info for."]
    #[doc = " @param device_information A char list of device information terminated by an"]
    #[doc = "        empty string or NULL if there was an error. Free with"]
    #[doc = "        afc_dictionary_free()."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_get_device_info(
        client: afc_client_t,
        device_information: *mut *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Gets a directory listing of the directory requested."]
    #[doc = ""]
    #[doc = " @param client The client to get a directory listing from."]
    #[doc = " @param path The directory for listing. (must be a fully-qualified path)"]
    #[doc = " @param directory_information A char list of files in the directory"]
    #[doc = "        terminated by an empty string or NULL if there was an error. Free with"]
    #[doc = "        afc_dictionary_free()."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_read_directory(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        directory_information: *mut *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Gets information about a specific file."]
    #[doc = ""]
    #[doc = " @param client The client to use to get the information of the file."]
    #[doc = " @param path The fully-qualified path to the file."]
    #[doc = " @param file_information Pointer to a buffer that will be filled with a"]
    #[doc = "        NULL-terminated list of strings with the file information. Set to NULL"]
    #[doc = "        before calling this function. Free with afc_dictionary_free()."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_get_file_info(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        file_information: *mut *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Opens a file on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use to open the file."]
    #[doc = " @param filename The file to open. (must be a fully-qualified path)"]
    #[doc = " @param file_mode The mode to use to open the file."]
    #[doc = " @param handle Pointer to a uint64_t that will hold the handle of the file"]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_open(
        client: afc_client_t,
        filename: *const ::std::os::raw::c_char,
        file_mode: afc_file_mode_t,
        handle: *mut u64,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Closes a file on the device."]
    #[doc = ""]
    #[doc = " @param client The client to close the file with."]
    #[doc = " @param handle File handle of a previously opened file."]
    pub fn afc_file_close(client: afc_client_t, handle: u64) -> afc_error_t;
}
extern "C" {
    #[doc = " Locks or unlocks a file on the device."]
    #[doc = ""]
    #[doc = " Makes use of flock on the device."]
    #[doc = " @see http://developer.apple.com/documentation/Darwin/Reference/ManPages/man2/flock.2.html"]
    #[doc = ""]
    #[doc = " @param client The client to lock the file with."]
    #[doc = " @param handle File handle of a previously opened file."]
    #[doc = " @param operation the lock or unlock operation to perform, this is one of"]
    #[doc = "        AFC_LOCK_SH (shared lock), AFC_LOCK_EX (exclusive lock), or"]
    #[doc = "        AFC_LOCK_UN (unlock)."]
    pub fn afc_file_lock(
        client: afc_client_t,
        handle: u64,
        operation: afc_lock_op_t,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Attempts to the read the given number of bytes from the given file."]
    #[doc = ""]
    #[doc = " @param client The relevant AFC client"]
    #[doc = " @param handle File handle of a previously opened file"]
    #[doc = " @param data The pointer to the memory region to store the read data"]
    #[doc = " @param length The number of bytes to read"]
    #[doc = " @param bytes_read The number of bytes actually read."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_read(
        client: afc_client_t,
        handle: u64,
        data: *mut ::std::os::raw::c_char,
        length: u32,
        bytes_read: *mut u32,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Writes a given number of bytes to a file."]
    #[doc = ""]
    #[doc = " @param client The client to use to write to the file."]
    #[doc = " @param handle File handle of previously opened file."]
    #[doc = " @param data The data to write to the file."]
    #[doc = " @param length How much data to write."]
    #[doc = " @param bytes_written The number of bytes actually written to the file."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_write(
        client: afc_client_t,
        handle: u64,
        data: *const ::std::os::raw::c_char,
        length: u32,
        bytes_written: *mut u32,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Seeks to a given position of a pre-opened file on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use to seek to the position."]
    #[doc = " @param handle File handle of a previously opened."]
    #[doc = " @param offset Seek offset."]
    #[doc = " @param whence Seeking direction, one of SEEK_SET, SEEK_CUR, or SEEK_END."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_seek(
        client: afc_client_t,
        handle: u64,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Returns current position in a pre-opened file on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use."]
    #[doc = " @param handle File handle of a previously opened file."]
    #[doc = " @param position Position in bytes of indicator"]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_file_tell(client: afc_client_t, handle: u64, position: *mut u64) -> afc_error_t;
}
extern "C" {
    #[doc = " Sets the size of a file on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use to set the file size."]
    #[doc = " @param handle File handle of a previously opened file."]
    #[doc = " @param newsize The size to set the file to."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    #[doc = ""]
    #[doc = " @note This function is more akin to ftruncate than truncate, and truncate"]
    #[doc = "       calls would have to open the file before calling this, sadly."]
    pub fn afc_file_truncate(client: afc_client_t, handle: u64, newsize: u64) -> afc_error_t;
}
extern "C" {
    #[doc = " Deletes a file or directory."]
    #[doc = ""]
    #[doc = " @param client The client to use."]
    #[doc = " @param path The path to delete. (must be a fully-qualified path)"]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_remove_path(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Renames a file or directory on the device."]
    #[doc = ""]
    #[doc = " @param client The client to have rename."]
    #[doc = " @param from The name to rename from. (must be a fully-qualified path)"]
    #[doc = " @param to The new name. (must also be a fully-qualified path)"]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_rename_path(
        client: afc_client_t,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Creates a directory on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use to make a directory."]
    #[doc = " @param path The directory's path. (must be a fully-qualified path, I assume"]
    #[doc = "        all other mkdir restrictions apply as well)"]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_make_directory(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Sets the size of a file on the device without prior opening it."]
    #[doc = ""]
    #[doc = " @param client The client to use to set the file size."]
    #[doc = " @param path The path of the file to be truncated."]
    #[doc = " @param newsize The size to set the file to."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_truncate(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        newsize: u64,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Creates a hard link or symbolic link on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use for making a link"]
    #[doc = " @param linktype 1 = hard link, 2 = symlink"]
    #[doc = " @param target The file to be linked."]
    #[doc = " @param linkname The name of link."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_make_link(
        client: afc_client_t,
        linktype: afc_link_type_t,
        target: *const ::std::os::raw::c_char,
        linkname: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Sets the modification time of a file on the device."]
    #[doc = ""]
    #[doc = " @param client The client to use to set the file size."]
    #[doc = " @param path Path of the file for which the modification time should be set."]
    #[doc = " @param mtime The modification time to set in nanoseconds since epoch."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_set_file_time(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
        mtime: u64,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Deletes a file or directory including possible contents."]
    #[doc = ""]
    #[doc = " @param client The client to use."]
    #[doc = " @param path The path to delete. (must be a fully-qualified path)"]
    #[doc = " @since libimobiledevice 1.1.7"]
    #[doc = " @note Only available in iOS 6 and later."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_remove_path_and_contents(
        client: afc_client_t,
        path: *const ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Get a specific key of the device info list for a client connection."]
    #[doc = " Known key values are: Model, FSTotalBytes, FSFreeBytes and FSBlockSize."]
    #[doc = " This is a helper function for afc_get_device_info()."]
    #[doc = ""]
    #[doc = " @param client The client to get device info for."]
    #[doc = " @param key The key to get the value of."]
    #[doc = " @param value The value for the key if successful or NULL otherwise."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_get_device_info_key(
        client: afc_client_t,
        key: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;
}
extern "C" {
    #[doc = " Frees up a char dictionary as returned by some AFC functions."]
    #[doc = ""]
    #[doc = " @param dictionary The char array terminated by an empty string."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS on success or an AFC_E_* error value."]
    pub fn afc_dictionary_free(dictionary: *mut *mut ::std::os::raw::c_char) -> afc_error_t;
}
extern "C" {
    #[doc = " Gets a readable error string for a given AFC error code."]
    #[doc = ""]
    #[doc = " @param err An AFC error code"]
    #[doc = ""]
    #[doc = " @returns A readable error string"]
    pub fn afc_strerror(err: afc_error_t) -> *const ::std::os::raw::c_char;
}
pub const companion_proxy_error_t_COMPANION_PROXY_E_SUCCESS: companion_proxy_error_t = 0;
pub const companion_proxy_error_t_COMPANION_PROXY_E_INVALID_ARG: companion_proxy_error_t = -1;
pub const companion_proxy_error_t_COMPANION_PROXY_E_PLIST_ERROR: companion_proxy_error_t = -2;
pub const companion_proxy_error_t_COMPANION_PROXY_E_MUX_ERROR: companion_proxy_error_t = -3;
pub const companion_proxy_error_t_COMPANION_PROXY_E_SSL_ERROR: companion_proxy_error_t = -4;
pub const companion_proxy_error_t_COMPANION_PROXY_E_NOT_ENOUGH_DATA: companion_proxy_error_t = -5;
pub const companion_proxy_error_t_COMPANION_PROXY_E_TIMEOUT: companion_proxy_error_t = -6;
pub const companion_proxy_error_t_COMPANION_PROXY_E_OP_IN_PROGRESS: companion_proxy_error_t = -7;
pub const companion_proxy_error_t_COMPANION_PROXY_E_NO_DEVICES: companion_proxy_error_t = -100;
pub const companion_proxy_error_t_COMPANION_PROXY_E_UNSUPPORTED_KEY: companion_proxy_error_t = -101;
pub const companion_proxy_error_t_COMPANION_PROXY_E_TIMEOUT_REPLY: companion_proxy_error_t = -102;
pub const companion_proxy_error_t_COMPANION_PROXY_E_UNKNOWN_ERROR: companion_proxy_error_t = -256;
#[doc = " Error Codes"]
pub type companion_proxy_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct companion_proxy_client_private {
    _unused: [u8; 0],
}
pub type companion_proxy_client_t = *mut companion_proxy_client_private;
#[doc = " Callback for companion device events"]
pub type companion_proxy_device_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(event: plist_t, userdata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Connects to the companion_proxy service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     companion_proxy_client_t upon successful return. Must be freed using"]
    #[doc = "     companion_proxy_client_free() after use."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success, COMPANION_PROXY_E_INVALID_ARG when"]
    #[doc = "     the arguments are invalid, or an COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut companion_proxy_client_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Starts a new companion_proxy service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     companion_proxy_client_t upon successful return. Must be freed using"]
    #[doc = "     companion_proxy_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success, or an COMPANION_PROXY_E_* error"]
    #[doc = "     code otherwise."]
    pub fn companion_proxy_client_start_service(
        device: idevice_t,
        client: *mut companion_proxy_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Disconnects a companion_proxy client from the device and frees up the"]
    #[doc = " companion_proxy client data."]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success, COMPANION_PROXY_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_client_free(client: companion_proxy_client_t)
        -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Sends a plist to the service."]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param plist The plist to send"]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  COMPANION_PROXY_E_INVALID_ARG when client or plist is NULL"]
    pub fn companion_proxy_send(
        client: companion_proxy_client_t,
        plist: plist_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Receives a plist from the service."]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param plist The plist to store the received data"]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  COMPANION_PROXY_E_INVALID_ARG when client or plist is NULL"]
    pub fn companion_proxy_receive(
        client: companion_proxy_client_t,
        plist: *mut plist_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Retrieves a list of paired devices."]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param paired_devices Point that will receive a PLIST_ARRAY with paired device UDIDs"]
    #[doc = ""]
    #[doc = " @note The device closes the connection after sending the reply."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  COMPANION_PROXY_E_NO_DEVICES if no devices are paired,"]
    #[doc = "  or a COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_get_device_registry(
        client: companion_proxy_client_t,
        paired_devices: *mut plist_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Starts listening for paired devices."]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param callback Callback function that will be called when a new device is detected"]
    #[doc = " @param userdata Pointer that that will be passed to the callback function"]
    #[doc = ""]
    #[doc = " @note The event parameter that gets passed to the callback function is"]
    #[doc = "  freed internally after returning from the callback. The consumer needs"]
    #[doc = "  to make a copy if required."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  or a COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_start_listening_for_devices(
        client: companion_proxy_client_t,
        callback: companion_proxy_device_event_cb_t,
        userdata: *mut ::std::os::raw::c_void,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Stops listening for paired devices"]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  or a COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_stop_listening_for_devices(
        client: companion_proxy_client_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Returns a value for the given key."]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param companion_udid UDID of the (paired) companion device"]
    #[doc = " @param key The key to retrieve the value for"]
    #[doc = " @param value A pointer to a plist_t that will receive the value for the given key."]
    #[doc = "   The consumer is responsible for freeing the value with plist_free() when no longer needed."]
    #[doc = ""]
    #[doc = " @note The device closes the connection after sending the reply."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  COMPANION_PROXY_E_INVALID_ARG when client or paired_devices is invalid,"]
    #[doc = "  COMPANION_PROXY_E_UNSUPPORTED_KEY if the companion device doesn't support the given key,"]
    #[doc = "  or a COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_get_value_from_registry(
        client: companion_proxy_client_t,
        companion_udid: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Start forwarding a service port on the companion device to a port on the idevice."]
    #[doc = ""]
    #[doc = " @see companion_proxy_stop_forwarding_service_port"]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param remote_port remote port"]
    #[doc = " @param service_name The name of the service that shall be forwarded"]
    #[doc = " @param forward_port Pointer that will receive the newly-assigned port accessible via USB/Network on the idevice"]
    #[doc = " @param options PLIST_DICT with additional options. Currently known are"]
    #[doc = "    IsServiceLowPriority (boolean) and PreferWifi (boolean)."]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  or a COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_start_forwarding_service_port(
        client: companion_proxy_client_t,
        remote_port: u16,
        service_name: *const ::std::os::raw::c_char,
        forward_port: *mut u16,
        options: plist_t,
    ) -> companion_proxy_error_t;
}
extern "C" {
    #[doc = " Stop forwarding a service port between companion device and idevice."]
    #[doc = ""]
    #[doc = " @see companion_proxy_start_forwarding_service_port"]
    #[doc = ""]
    #[doc = " @param client The companion_proxy client"]
    #[doc = " @param remote_port remote port"]
    #[doc = ""]
    #[doc = " @return COMPANION_PROXY_E_SUCCESS on success,"]
    #[doc = "  or a COMPANION_PROXY_E_* error code otherwise."]
    pub fn companion_proxy_stop_forwarding_service_port(
        client: companion_proxy_client_t,
        remote_port: u16,
    ) -> companion_proxy_error_t;
}
pub const debugserver_error_t_DEBUGSERVER_E_SUCCESS: debugserver_error_t = 0;
pub const debugserver_error_t_DEBUGSERVER_E_INVALID_ARG: debugserver_error_t = -1;
pub const debugserver_error_t_DEBUGSERVER_E_MUX_ERROR: debugserver_error_t = -2;
pub const debugserver_error_t_DEBUGSERVER_E_SSL_ERROR: debugserver_error_t = -3;
pub const debugserver_error_t_DEBUGSERVER_E_RESPONSE_ERROR: debugserver_error_t = -4;
pub const debugserver_error_t_DEBUGSERVER_E_TIMEOUT: debugserver_error_t = -5;
pub const debugserver_error_t_DEBUGSERVER_E_UNKNOWN_ERROR: debugserver_error_t = -256;
#[doc = " Error Codes"]
pub type debugserver_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debugserver_client_private {
    _unused: [u8; 0],
}
pub type debugserver_client_t = *mut debugserver_client_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debugserver_command_private {
    _unused: [u8; 0],
}
pub type debugserver_command_t = *mut debugserver_command_private;
extern "C" {
    #[doc = " Connects to the debugserver service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     debugserver_client_t upon successful return. Must be freed using"]
    #[doc = "     debugserver_client_free() after use."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, DEBUGSERVER_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an DEBUGSERVER_E_* error code otherwise."]
    pub fn debugserver_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut debugserver_client_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Starts a new debugserver service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     debugserver_client_t upon successful return. Must be freed using"]
    #[doc = "     debugserver_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, or an DEBUGSERVER_E_* error"]
    #[doc = "     code otherwise."]
    pub fn debugserver_client_start_service(
        device: idevice_t,
        client: *mut debugserver_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Disconnects a debugserver client from the device and frees up the"]
    #[doc = " debugserver client data."]
    #[doc = ""]
    #[doc = " @param client The debugserver client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, DEBUGSERVER_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an DEBUGSERVER_E_* error code otherwise."]
    pub fn debugserver_client_free(client: debugserver_client_t) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sends raw data using the given debugserver service client."]
    #[doc = ""]
    #[doc = " @param client The debugserver client to use for sending"]
    #[doc = " @param data Data to send"]
    #[doc = " @param size Size of the data to send"]
    #[doc = " @param sent Number of bytes sent (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "      DEBUGSERVER_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, or DEBUGSERVER_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn debugserver_client_send(
        client: debugserver_client_t,
        data: *const ::std::os::raw::c_char,
        size: u32,
        sent: *mut u32,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Receives raw data using the given debugserver client with specified timeout."]
    #[doc = ""]
    #[doc = " @param client The debugserver client to use for receiving"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "      DEBUGSERVER_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, DEBUGSERVER_E_MUX_ERROR when a communication error"]
    #[doc = "      occurs, DEBUGSERVER_E_TIMEOUT when the timeout is reached,"]
    #[doc = "      or DEBUGSERVER_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn debugserver_client_receive_with_timeout(
        client: debugserver_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Receives raw data from the debugserver service."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = " @note The default read timeout is 10 seconds."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client or plist is NULL"]
    pub fn debugserver_client_receive(
        client: debugserver_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sends a command to the debugserver service."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param command Command to process and send"]
    #[doc = " @param response Response received for the command (can be NULL to ignore)"]
    #[doc = " @param response_size Pointer to receive response size. Set to NULL to ignore."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client or command is NULL"]
    pub fn debugserver_client_send_command(
        client: debugserver_client_t,
        command: debugserver_command_t,
        response: *mut *mut ::std::os::raw::c_char,
        response_size: *mut size_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Receives and parses response of debugserver service."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param response Response received for last command (can be NULL to ignore)"]
    #[doc = " @param response_size Pointer to receive response size. Set to NULL to ignore."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client is NULL"]
    pub fn debugserver_client_receive_response(
        client: debugserver_client_t,
        response: *mut *mut ::std::os::raw::c_char,
        response_size: *mut size_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Controls status of ACK mode when sending commands or receiving responses."]
    #[doc = ""]
    #[doc = " @see debugserver_client_send_command, debugserver_client_receive_response"]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param enabled A boolean flag indicating whether the internal ACK mode"]
    #[doc = "   handling should be enabled or disabled."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, or an DEBUGSERVER_E_* error"]
    #[doc = "     code otherwise."]
    pub fn debugserver_client_set_ack_mode(
        client: debugserver_client_t,
        enabled: ::std::os::raw::c_int,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sets behavior when awaiting a response from the server."]
    #[doc = ""]
    #[doc = " @see debugserver_client_send_command, debugserver_client_receive_response,"]
    #[doc = "   debugserver_client_receive"]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param cancel_receive A function pointer that will be called approximately"]
    #[doc = "     every receive_loop_timeout milliseconds; the function should return a"]
    #[doc = "     boolean flag specifying whether to stop waiting for a response. If NULL,"]
    #[doc = "     behaves as if it always returns true."]
    #[doc = " @param receive_loop_timeout Time in milliseconds between calls to"]
    #[doc = "     cancel_receive."]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success, or an DEBUGSERVER_E_* error"]
    #[doc = "     code otherwise."]
    pub fn debugserver_client_set_receive_params(
        client: debugserver_client_t,
        cancel_receive: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
        receive_loop_timeout: ::std::os::raw::c_int,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Sets the argv which launches an app."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param argc Number of arguments"]
    #[doc = " @param argv Array starting with the executable to be run followed by it's arguments"]
    #[doc = " @param response Response received for the command (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client is NULL"]
    pub fn debugserver_client_set_argv(
        client: debugserver_client_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        response: *mut *mut ::std::os::raw::c_char,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Adds or sets an environment variable."]
    #[doc = ""]
    #[doc = " @param client The debugserver client"]
    #[doc = " @param env The environment variable in \"KEY=VALUE\" notation"]
    #[doc = " @param response Response received for the command (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when client is NULL"]
    pub fn debugserver_client_set_environment_hex_encoded(
        client: debugserver_client_t,
        env: *const ::std::os::raw::c_char,
        response: *mut *mut ::std::os::raw::c_char,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Creates and initializes a new command object."]
    #[doc = ""]
    #[doc = " @param name The name of the command which is sent in plain text"]
    #[doc = " @param argv Array of tokens for the command ment to be encoded"]
    #[doc = " @param argc Number of items in the token array"]
    #[doc = " @param command New command object"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when name or command is NULL"]
    pub fn debugserver_command_new(
        name: *const ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        command: *mut debugserver_command_t,
    ) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Frees memory of command object."]
    #[doc = ""]
    #[doc = " @param command The command object"]
    #[doc = ""]
    #[doc = " @return DEBUGSERVER_E_SUCCESS on success,"]
    #[doc = "  DEBUGSERVER_E_INVALID_ARG when command is NULL"]
    pub fn debugserver_command_free(command: debugserver_command_t) -> debugserver_error_t;
}
extern "C" {
    #[doc = " Encodes a string into hex notation."]
    #[doc = ""]
    #[doc = " @param buffer String to encode into hex notiation"]
    #[doc = " @param encoded_buffer The buffer receives a hex encoded string"]
    #[doc = " @param encoded_length Length of the hex encoded string"]
    pub fn debugserver_encode_string(
        buffer: *const ::std::os::raw::c_char,
        encoded_buffer: *mut *mut ::std::os::raw::c_char,
        encoded_length: *mut u32,
    );
}
extern "C" {
    #[doc = " Decodes a hex encoded string."]
    #[doc = ""]
    #[doc = " @param encoded_buffer The buffer with a hex encoded string"]
    #[doc = " @param encoded_length Length of the encoded buffer"]
    #[doc = " @param buffer Decoded string to be freed by the caller"]
    pub fn debugserver_decode_string(
        encoded_buffer: *const ::std::os::raw::c_char,
        encoded_length: size_t,
        buffer: *mut *mut ::std::os::raw::c_char,
    );
}
pub const diagnostics_relay_error_t_DIAGNOSTICS_RELAY_E_SUCCESS: diagnostics_relay_error_t = 0;
pub const diagnostics_relay_error_t_DIAGNOSTICS_RELAY_E_INVALID_ARG: diagnostics_relay_error_t = -1;
pub const diagnostics_relay_error_t_DIAGNOSTICS_RELAY_E_PLIST_ERROR: diagnostics_relay_error_t = -2;
pub const diagnostics_relay_error_t_DIAGNOSTICS_RELAY_E_MUX_ERROR: diagnostics_relay_error_t = -3;
pub const diagnostics_relay_error_t_DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST: diagnostics_relay_error_t =
    -4;
pub const diagnostics_relay_error_t_DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR: diagnostics_relay_error_t =
    -256;
#[doc = " Error Codes"]
pub type diagnostics_relay_error_t = ::std::os::raw::c_int;
pub const diagnostics_relay_action_t_DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT:
    diagnostics_relay_action_t = 2;
pub const diagnostics_relay_action_t_DIAGNOSTICS_RELAY_ACTION_FLAG_DISPLAY_PASS:
    diagnostics_relay_action_t = 4;
pub const diagnostics_relay_action_t_DIAGNOSTICS_RELAY_ACTION_FLAG_DISPLAY_FAIL:
    diagnostics_relay_action_t = 8;
#[doc = " Action type for #diagnostics_relay_restart and #diagnostics_relay_shutdown"]
pub type diagnostics_relay_action_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostics_relay_client_private {
    _unused: [u8; 0],
}
pub type diagnostics_relay_client_t = *mut diagnostics_relay_client_private;
extern "C" {
    #[doc = " Connects to the diagnostics_relay service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Reference that will point to a newly allocated"]
    #[doc = "     diagnostics_relay_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "     DIAGNOSTICS_RELAY_E_INVALID_ARG when one of the parameters is invalid,"]
    #[doc = "     or DIAGNOSTICS_RELAY_E_MUX_ERROR when the connection failed."]
    pub fn diagnostics_relay_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut diagnostics_relay_client_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Starts a new diagnostics_relay service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     diagnostics_relay_client_t upon successful return. Must be freed using"]
    #[doc = "     diagnostics_relay_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success, or an DIAGNOSTICS_RELAY_E_* error"]
    #[doc = "     code otherwise."]
    pub fn diagnostics_relay_client_start_service(
        device: idevice_t,
        client: *mut diagnostics_relay_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Disconnects a diagnostics_relay client from the device and frees up the"]
    #[doc = " diagnostics_relay client data."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "     DIAGNOSTICS_RELAY_E_INVALID_ARG when one of client or client->parent"]
    #[doc = "     is invalid, or DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR when the was an"]
    #[doc = "     error freeing the parent property_list_service client."]
    pub fn diagnostics_relay_client_free(
        client: diagnostics_relay_client_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Sends the Goodbye request signaling the end of communication."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_goodbye(
        client: diagnostics_relay_client_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Puts the device into deep sleep mode and disconnects from host."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_sleep(client: diagnostics_relay_client_t)
        -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Restart the device and optionally show a user notification."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = " @param flags A binary flag combination of"]
    #[doc = "        DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT to wait until"]
    #[doc = "        diagnostics_relay_client_free() disconnects before execution and"]
    #[doc = "        DIAGNOSTICS_RELAY_ACTION_FLAG_DISPLAY_FAIL to show a \"FAIL\" dialog"]
    #[doc = "        or DIAGNOSTICS_RELAY_ACTION_FLAG_DISPLAY_PASS to show an \"OK\" dialog"]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_restart(
        client: diagnostics_relay_client_t,
        flags: diagnostics_relay_action_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Shutdown of the device and optionally show a user notification."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = " @param flags A binary flag combination of"]
    #[doc = "        DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT to wait until"]
    #[doc = "        diagnostics_relay_client_free() disconnects before execution and"]
    #[doc = "        DIAGNOSTICS_RELAY_ACTION_FLAG_DISPLAY_FAIL to show a \"FAIL\" dialog"]
    #[doc = "        or DIAGNOSTICS_RELAY_ACTION_FLAG_DISPLAY_PASS to show an \"OK\" dialog"]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_shutdown(
        client: diagnostics_relay_client_t,
        flags: diagnostics_relay_action_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Request diagnostics information for a given type."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = " @param type The type or domain to query for diagnostics. Some known values"]
    #[doc = "     are \"All\", \"WiFi\", \"GasGauge\", and \"NAND\"."]
    #[doc = " @param diagnostics A pointer to plist_t that will receive the diagnostics information."]
    #[doc = "     The consumer has to free the allocated memory with plist_free() when no longer needed."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_request_diagnostics(
        client: diagnostics_relay_client_t,
        type_: *const ::std::os::raw::c_char,
        diagnostics: *mut plist_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Query one or multiple MobileGestalt keys."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = " @param keys A PLIST_ARRAY with the keys to query."]
    #[doc = " @param result A pointer to plist_t that will receive the result. The consumer"]
    #[doc = "     has to free the allocated memory with plist_free() when no longer needed."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_query_mobilegestalt(
        client: diagnostics_relay_client_t,
        keys: plist_t,
        result: *mut plist_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Query an IORegistry entry of a given class."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = " @param entry_name The IORegistry entry name to query."]
    #[doc = " @param entry_class The IORegistry class to query."]
    #[doc = " @param result A pointer to plist_t that will receive the result. The consumer"]
    #[doc = "     has to free the allocated memory with plist_free() when no longer needed."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_query_ioregistry_entry(
        client: diagnostics_relay_client_t,
        entry_name: *const ::std::os::raw::c_char,
        entry_class: *const ::std::os::raw::c_char,
        result: *mut plist_t,
    ) -> diagnostics_relay_error_t;
}
extern "C" {
    #[doc = " Query an IORegistry plane."]
    #[doc = ""]
    #[doc = " @param client The diagnostics_relay client"]
    #[doc = " @param plane The IORegistry plane name to query."]
    #[doc = " @param result A pointer to plist_t that will receive the result. The consumer"]
    #[doc = "     has to free the allocated memory with plist_free() when no longer needed."]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client is NULL,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_PLIST_ERROR if the device did not acknowledge the"]
    #[doc = "  request"]
    pub fn diagnostics_relay_query_ioregistry_plane(
        client: diagnostics_relay_client_t,
        plane: *const ::std::os::raw::c_char,
        result: *mut plist_t,
    ) -> diagnostics_relay_error_t;
}
pub const file_relay_error_t_FILE_RELAY_E_SUCCESS: file_relay_error_t = 0;
pub const file_relay_error_t_FILE_RELAY_E_INVALID_ARG: file_relay_error_t = -1;
pub const file_relay_error_t_FILE_RELAY_E_PLIST_ERROR: file_relay_error_t = -2;
pub const file_relay_error_t_FILE_RELAY_E_MUX_ERROR: file_relay_error_t = -3;
pub const file_relay_error_t_FILE_RELAY_E_INVALID_SOURCE: file_relay_error_t = -4;
pub const file_relay_error_t_FILE_RELAY_E_STAGING_EMPTY: file_relay_error_t = -5;
pub const file_relay_error_t_FILE_RELAY_E_PERMISSION_DENIED: file_relay_error_t = -6;
pub const file_relay_error_t_FILE_RELAY_E_UNKNOWN_ERROR: file_relay_error_t = -256;
#[doc = " Error Codes"]
pub type file_relay_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_relay_client_private {
    _unused: [u8; 0],
}
pub type file_relay_client_t = *mut file_relay_client_private;
extern "C" {
    #[doc = " Connects to the file_relay service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Reference that will point to a newly allocated"]
    #[doc = "     file_relay_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return FILE_RELAY_E_SUCCESS on success,"]
    #[doc = "     FILE_RELAY_E_INVALID_ARG when one of the parameters is invalid,"]
    #[doc = "     or FILE_RELAY_E_MUX_ERROR when the connection failed."]
    pub fn file_relay_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut file_relay_client_t,
    ) -> file_relay_error_t;
}
extern "C" {
    #[doc = " Starts a new file_relay service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     file_relay_client_t upon successful return. Must be freed using"]
    #[doc = "     file_relay_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return FILE_RELAY_E_SUCCESS on success, or an FILE_RELAY_E_* error"]
    #[doc = "     code otherwise."]
    pub fn file_relay_client_start_service(
        device: idevice_t,
        client: *mut file_relay_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> file_relay_error_t;
}
extern "C" {
    #[doc = " Disconnects a file_relay client from the device and frees up the file_relay"]
    #[doc = " client data."]
    #[doc = ""]
    #[doc = " @param client The file_relay client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return FILE_RELAY_E_SUCCESS on success,"]
    #[doc = "     FILE_RELAY_E_INVALID_ARG when one of client or client->parent"]
    #[doc = "     is invalid, or FILE_RELAY_E_UNKNOWN_ERROR when the was an error"]
    #[doc = "     freeing the parent property_list_service client."]
    pub fn file_relay_client_free(client: file_relay_client_t) -> file_relay_error_t;
}
extern "C" {
    #[doc = " Request data for the given sources."]
    #[doc = ""]
    #[doc = " @param client The connected file_relay client."]
    #[doc = " @param sources A NULL-terminated list of sources to retrieve."]
    #[doc = "     Valid sources are:"]
    #[doc = "     - AppleSupport"]
    #[doc = "     - Network"]
    #[doc = "     - VPN"]
    #[doc = "     - WiFi"]
    #[doc = "     - UserDatabases"]
    #[doc = "     - CrashReporter"]
    #[doc = "     - tmp"]
    #[doc = "     - SystemConfiguration"]
    #[doc = " @param connection The connection that has to be used for receiving the"]
    #[doc = "     data using idevice_connection_receive(). The connection will be closed"]
    #[doc = "     automatically by the device, but use file_relay_client_free() to clean"]
    #[doc = "     up properly."]
    #[doc = ""]
    #[doc = " @note WARNING: Don't call this function without reading the data afterwards."]
    #[doc = "     A directory mobile_file_relay.XXXX used for creating the archive will"]
    #[doc = "     remain in the /tmp directory otherwise."]
    #[doc = ""]
    #[doc = " @return FILE_RELAY_E_SUCCESS on succes, FILE_RELAY_E_INVALID_ARG when one or"]
    #[doc = "     more parameters are invalid, FILE_RELAY_E_MUX_ERROR if a communication"]
    #[doc = "     error occurs, FILE_RELAY_E_PLIST_ERROR when the received result is NULL"]
    #[doc = "     or is not a valid plist, FILE_RELAY_E_INVALID_SOURCE if one or more"]
    #[doc = "     sources are invalid, FILE_RELAY_E_STAGING_EMPTY if no data is available"]
    #[doc = "     for the given sources, or FILE_RELAY_E_UNKNOWN_ERROR otherwise."]
    pub fn file_relay_request_sources(
        client: file_relay_client_t,
        sources: *mut *const ::std::os::raw::c_char,
        connection: *mut idevice_connection_t,
    ) -> file_relay_error_t;
}
extern "C" {
    #[doc = " Request data for the given sources. Calls file_relay_request_sources_timeout() with"]
    #[doc = " a timeout of 60000 milliseconds (60 seconds)."]
    #[doc = ""]
    #[doc = " @param client The connected file_relay client."]
    #[doc = " @param sources A NULL-terminated list of sources to retrieve."]
    #[doc = "     Valid sources are:"]
    #[doc = "     - AppleSupport"]
    #[doc = "     - Network"]
    #[doc = "     - VPN"]
    #[doc = "     - WiFi"]
    #[doc = "     - UserDatabases"]
    #[doc = "     - CrashReporter"]
    #[doc = "     - tmp"]
    #[doc = "     - SystemConfiguration"]
    #[doc = " @param connection The connection that has to be used for receiving the"]
    #[doc = "     data using idevice_connection_receive(). The connection will be closed"]
    #[doc = "     automatically by the device, but use file_relay_client_free() to clean"]
    #[doc = "     up properly."]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @note WARNING: Don't call this function without reading the data afterwards."]
    #[doc = "     A directory mobile_file_relay.XXXX used for creating the archive will"]
    #[doc = "     remain in the /tmp directory otherwise."]
    #[doc = ""]
    #[doc = " @return FILE_RELAY_E_SUCCESS on succes, FILE_RELAY_E_INVALID_ARG when one or"]
    #[doc = "     more parameters are invalid, FILE_RELAY_E_MUX_ERROR if a communication"]
    #[doc = "     error occurs, FILE_RELAY_E_PLIST_ERROR when the received result is NULL"]
    #[doc = "     or is not a valid plist, FILE_RELAY_E_INVALID_SOURCE if one or more"]
    #[doc = "     sources are invalid, FILE_RELAY_E_STAGING_EMPTY if no data is available"]
    #[doc = "     for the given sources, or FILE_RELAY_E_UNKNOWN_ERROR otherwise."]
    pub fn file_relay_request_sources_timeout(
        client: file_relay_client_t,
        sources: *mut *const ::std::os::raw::c_char,
        connection: *mut idevice_connection_t,
        timeout: ::std::os::raw::c_uint,
    ) -> file_relay_error_t;
}
pub const heartbeat_error_t_HEARTBEAT_E_SUCCESS: heartbeat_error_t = 0;
pub const heartbeat_error_t_HEARTBEAT_E_INVALID_ARG: heartbeat_error_t = -1;
pub const heartbeat_error_t_HEARTBEAT_E_PLIST_ERROR: heartbeat_error_t = -2;
pub const heartbeat_error_t_HEARTBEAT_E_MUX_ERROR: heartbeat_error_t = -3;
pub const heartbeat_error_t_HEARTBEAT_E_SSL_ERROR: heartbeat_error_t = -4;
pub const heartbeat_error_t_HEARTBEAT_E_NOT_ENOUGH_DATA: heartbeat_error_t = -5;
pub const heartbeat_error_t_HEARTBEAT_E_TIMEOUT: heartbeat_error_t = -6;
pub const heartbeat_error_t_HEARTBEAT_E_UNKNOWN_ERROR: heartbeat_error_t = -256;
#[doc = " Error Codes"]
pub type heartbeat_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heartbeat_client_private {
    _unused: [u8; 0],
}
pub type heartbeat_client_t = *mut heartbeat_client_private;
extern "C" {
    #[doc = " Connects to the heartbeat service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     heartbeat_client_t upon successful return. Must be freed using"]
    #[doc = "     heartbeat_client_free() after use."]
    #[doc = ""]
    #[doc = " @return HEARTBEAT_E_SUCCESS on success, HEARTBEAT_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an HEARTBEAT_E_* error code otherwise."]
    pub fn heartbeat_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut heartbeat_client_t,
    ) -> heartbeat_error_t;
}
extern "C" {
    #[doc = " Starts a new heartbeat service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     heartbeat_client_t upon successful return. Must be freed using"]
    #[doc = "     heartbeat_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return HEARTBEAT_E_SUCCESS on success, or an HEARTBEAT_E_* error"]
    #[doc = "     code otherwise."]
    pub fn heartbeat_client_start_service(
        device: idevice_t,
        client: *mut heartbeat_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> heartbeat_error_t;
}
extern "C" {
    #[doc = " Disconnects a heartbeat client from the device and frees up the"]
    #[doc = " heartbeat client data."]
    #[doc = ""]
    #[doc = " @param client The heartbeat client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return HEARTBEAT_E_SUCCESS on success, HEARTBEAT_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an HEARTBEAT_E_* error code otherwise."]
    pub fn heartbeat_client_free(client: heartbeat_client_t) -> heartbeat_error_t;
}
extern "C" {
    #[doc = " Sends a plist to the service."]
    #[doc = ""]
    #[doc = " @param client The heartbeat client"]
    #[doc = " @param plist The plist to send"]
    #[doc = ""]
    #[doc = " @return HEARTBEAT_E_SUCCESS on success,"]
    #[doc = "  HEARTBEAT_E_INVALID_ARG when client or plist is NULL"]
    pub fn heartbeat_send(client: heartbeat_client_t, plist: plist_t) -> heartbeat_error_t;
}
extern "C" {
    #[doc = " Receives a plist from the service."]
    #[doc = ""]
    #[doc = " @param client The heartbeat client"]
    #[doc = " @param plist The plist to store the received data"]
    #[doc = ""]
    #[doc = " @return HEARTBEAT_E_SUCCESS on success,"]
    #[doc = "  HEARTBEAT_E_INVALID_ARG when client or plist is NULL"]
    pub fn heartbeat_receive(client: heartbeat_client_t, plist: *mut plist_t) -> heartbeat_error_t;
}
extern "C" {
    #[doc = " Receives a plist using the given heartbeat client."]
    #[doc = ""]
    #[doc = " @param client The heartbeat client to use for receiving"]
    #[doc = " @param plist pointer to a plist_t that will point to the received plist"]
    #[doc = "      upon successful return"]
    #[doc = " @param timeout_ms Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return HEARTBEAT_E_SUCCESS on success,"]
    #[doc = "      HEARTBEAT_E_INVALID_ARG when client or *plist is NULL,"]
    #[doc = "      HEARTBEAT_E_NOT_ENOUGH_DATA when not enough data"]
    #[doc = "      received, HEARTBEAT_E_TIMEOUT when the connection times out,"]
    #[doc = "      HEARTBEAT_E_PLIST_ERROR when the received data cannot be"]
    #[doc = "      converted to a plist, HEARTBEAT_E_MUX_ERROR when a"]
    #[doc = "      communication error occurs, or HEARTBEAT_E_UNKNOWN_ERROR"]
    #[doc = "      when an unspecified error occurs."]
    pub fn heartbeat_receive_with_timeout(
        client: heartbeat_client_t,
        plist: *mut plist_t,
        timeout_ms: u32,
    ) -> heartbeat_error_t;
}
pub const house_arrest_error_t_HOUSE_ARREST_E_SUCCESS: house_arrest_error_t = 0;
pub const house_arrest_error_t_HOUSE_ARREST_E_INVALID_ARG: house_arrest_error_t = -1;
pub const house_arrest_error_t_HOUSE_ARREST_E_PLIST_ERROR: house_arrest_error_t = -2;
pub const house_arrest_error_t_HOUSE_ARREST_E_CONN_FAILED: house_arrest_error_t = -3;
pub const house_arrest_error_t_HOUSE_ARREST_E_INVALID_MODE: house_arrest_error_t = -4;
pub const house_arrest_error_t_HOUSE_ARREST_E_UNKNOWN_ERROR: house_arrest_error_t = -256;
#[doc = " Error Codes"]
pub type house_arrest_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct house_arrest_client_private {
    _unused: [u8; 0],
}
pub type house_arrest_client_t = *mut house_arrest_client_private;
extern "C" {
    #[doc = " Connects to the house_arrest service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     housearrest_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return HOUSE_ARREST_E_SUCCESS on success, HOUSE_ARREST_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an HOUSE_ARREST_E_* error code otherwise."]
    pub fn house_arrest_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut house_arrest_client_t,
    ) -> house_arrest_error_t;
}
extern "C" {
    #[doc = " Starts a new house_arrest service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     house_arrest_client_t upon successful return. Must be freed using"]
    #[doc = "     house_arrest_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return HOUSE_ARREST_E_SUCCESS on success, or an HOUSE_ARREST_E_* error"]
    #[doc = "     code otherwise."]
    pub fn house_arrest_client_start_service(
        device: idevice_t,
        client: *mut house_arrest_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> house_arrest_error_t;
}
extern "C" {
    #[doc = " Disconnects an house_arrest client from the device and frees up the"]
    #[doc = " house_arrest client data."]
    #[doc = ""]
    #[doc = " @note After using afc_client_new_from_house_arrest_client(), make sure"]
    #[doc = "     you call afc_client_free() before calling this function to ensure"]
    #[doc = "     a proper cleanup. Do not call this function if you still need to"]
    #[doc = "     perform AFC operations since it will close the connection."]
    #[doc = ""]
    #[doc = " @param client The house_arrest client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return HOUSE_ARREST_E_SUCCESS on success, HOUSE_ARREST_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an HOUSE_ARREST_E_* error code otherwise."]
    pub fn house_arrest_client_free(client: house_arrest_client_t) -> house_arrest_error_t;
}
extern "C" {
    #[doc = " Sends a generic request to the connected house_arrest service."]
    #[doc = ""]
    #[doc = " @param client The house_arrest client to use."]
    #[doc = " @param dict The request to send as a plist of type PLIST_DICT."]
    #[doc = ""]
    #[doc = " @note If this function returns HOUSE_ARREST_E_SUCCESS it does not mean"]
    #[doc = "     that the request was successful. To check for success or failure you"]
    #[doc = "     need to call house_arrest_get_result()."]
    #[doc = " @see house_arrest_get_result"]
    #[doc = ""]
    #[doc = " @return HOUSE_ARREST_E_SUCCESS if the request was successfully sent,"]
    #[doc = "     HOUSE_ARREST_E_INVALID_ARG if client or dict is invalid,"]
    #[doc = "     HOUSE_ARREST_E_PLIST_ERROR if dict is not a plist of type PLIST_DICT,"]
    #[doc = "     HOUSE_ARREST_E_INVALID_MODE if the client is not in the correct mode,"]
    #[doc = "     or HOUSE_ARREST_E_CONN_FAILED if a connection error occurred."]
    pub fn house_arrest_send_request(
        client: house_arrest_client_t,
        dict: plist_t,
    ) -> house_arrest_error_t;
}
extern "C" {
    #[doc = " Send a command to the connected house_arrest service."]
    #[doc = " Calls house_arrest_send_request() internally."]
    #[doc = ""]
    #[doc = " @param client The house_arrest client to use."]
    #[doc = " @param command The command to send. Currently, only VendContainer and"]
    #[doc = "     VendDocuments are known."]
    #[doc = " @param appid The application identifier to pass along with the ."]
    #[doc = ""]
    #[doc = " @note If this function returns HOUSE_ARREST_E_SUCCESS it does not mean"]
    #[doc = "     that the command was successful. To check for success or failure you"]
    #[doc = "     need to call house_arrest_get_result()."]
    #[doc = " @see house_arrest_get_result"]
    #[doc = ""]
    #[doc = " @return HOUSE_ARREST_E_SUCCESS if the command was successfully sent,"]
    #[doc = "     HOUSE_ARREST_E_INVALID_ARG if client, command, or appid is invalid,"]
    #[doc = "     HOUSE_ARREST_E_INVALID_MODE if the client is not in the correct mode,"]
    #[doc = "     or HOUSE_ARREST_E_CONN_FAILED if a connection error occurred."]
    pub fn house_arrest_send_command(
        client: house_arrest_client_t,
        command: *const ::std::os::raw::c_char,
        appid: *const ::std::os::raw::c_char,
    ) -> house_arrest_error_t;
}
extern "C" {
    #[doc = " Retrieves the result of a previously sent house_arrest_request_* request."]
    #[doc = ""]
    #[doc = " @param client The house_arrest client to use"]
    #[doc = " @param dict Pointer that will be set to a plist containing the result to"]
    #[doc = "     the last performed operation. It holds a key 'Status' with the value"]
    #[doc = "     'Complete' on success or a key 'Error' with an error description as"]
    #[doc = "     value. The caller is responsible for freeing the returned plist."]
    #[doc = ""]
    #[doc = " @return HOUSE_ARREST_E_SUCCESS if a result plist was retrieved,"]
    #[doc = "     HOUSE_ARREST_E_INVALID_ARG if client is invalid,"]
    #[doc = "     HOUSE_ARREST_E_INVALID_MODE if the client is not in the correct mode,"]
    #[doc = "     or HOUSE_ARREST_E_CONN_FAILED if a connection error occurred."]
    pub fn house_arrest_get_result(
        client: house_arrest_client_t,
        dict: *mut plist_t,
    ) -> house_arrest_error_t;
}
extern "C" {
    #[doc = " Creates an AFC client using the given house_arrest client's connection"]
    #[doc = " allowing file access to a specific application directory requested by"]
    #[doc = " functions like house_arrest_request_vendor_documents()."]
    #[doc = ""]
    #[doc = " @param client The house_arrest client to use."]
    #[doc = " @param afc_client Pointer that will be set to a newly allocated afc_client_t"]
    #[doc = "     upon successful return."]
    #[doc = ""]
    #[doc = " @note After calling this function the house_arrest client will go in an"]
    #[doc = "     AFC mode that will only allow calling house_arrest_client_free()."]
    #[doc = "     Only call house_arrest_client_free() if all AFC operations have"]
    #[doc = "     completed since it will close the connection."]
    #[doc = ""]
    #[doc = " @return AFC_E_SUCCESS if the afc client was successfully created,"]
    #[doc = "     AFC_E_INVALID_ARG if client is invalid or was already used to create"]
    #[doc = "     an afc client, or an AFC_E_* error code returned by"]
    #[doc = "     afc_client_new_with_service_client()."]
    pub fn afc_client_new_from_house_arrest_client(
        client: house_arrest_client_t,
        afc_client: *mut afc_client_t,
    ) -> afc_error_t;
}
pub const instproxy_error_t_INSTPROXY_E_SUCCESS: instproxy_error_t = 0;
pub const instproxy_error_t_INSTPROXY_E_INVALID_ARG: instproxy_error_t = -1;
pub const instproxy_error_t_INSTPROXY_E_PLIST_ERROR: instproxy_error_t = -2;
pub const instproxy_error_t_INSTPROXY_E_CONN_FAILED: instproxy_error_t = -3;
pub const instproxy_error_t_INSTPROXY_E_OP_IN_PROGRESS: instproxy_error_t = -4;
pub const instproxy_error_t_INSTPROXY_E_OP_FAILED: instproxy_error_t = -5;
pub const instproxy_error_t_INSTPROXY_E_RECEIVE_TIMEOUT: instproxy_error_t = -6;
pub const instproxy_error_t_INSTPROXY_E_ALREADY_ARCHIVED: instproxy_error_t = -7;
pub const instproxy_error_t_INSTPROXY_E_API_INTERNAL_ERROR: instproxy_error_t = -8;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_ALREADY_INSTALLED: instproxy_error_t = -9;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_MOVE_FAILED: instproxy_error_t = -10;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_SINF_CAPTURE_FAILED: instproxy_error_t = -11;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_SANDBOX_FAILED: instproxy_error_t = -12;
pub const instproxy_error_t_INSTPROXY_E_APPLICATION_VERIFICATION_FAILED: instproxy_error_t = -13;
pub const instproxy_error_t_INSTPROXY_E_ARCHIVE_DESTRUCTION_FAILED: instproxy_error_t = -14;
pub const instproxy_error_t_INSTPROXY_E_BUNDLE_VERIFICATION_FAILED: instproxy_error_t = -15;
pub const instproxy_error_t_INSTPROXY_E_CARRIER_BUNDLE_COPY_FAILED: instproxy_error_t = -16;
pub const instproxy_error_t_INSTPROXY_E_CARRIER_BUNDLE_DIRECTORY_CREATION_FAILED:
    instproxy_error_t = -17;
pub const instproxy_error_t_INSTPROXY_E_CARRIER_BUNDLE_MISSING_SUPPORTED_SIMS: instproxy_error_t =
    -18;
pub const instproxy_error_t_INSTPROXY_E_COMM_CENTER_NOTIFICATION_FAILED: instproxy_error_t = -19;
pub const instproxy_error_t_INSTPROXY_E_CONTAINER_CREATION_FAILED: instproxy_error_t = -20;
pub const instproxy_error_t_INSTPROXY_E_CONTAINER_P0WN_FAILED: instproxy_error_t = -21;
pub const instproxy_error_t_INSTPROXY_E_CONTAINER_REMOVAL_FAILED: instproxy_error_t = -22;
pub const instproxy_error_t_INSTPROXY_E_EMBEDDED_PROFILE_INSTALL_FAILED: instproxy_error_t = -23;
pub const instproxy_error_t_INSTPROXY_E_EXECUTABLE_TWIDDLE_FAILED: instproxy_error_t = -24;
pub const instproxy_error_t_INSTPROXY_E_EXISTENCE_CHECK_FAILED: instproxy_error_t = -25;
pub const instproxy_error_t_INSTPROXY_E_INSTALL_MAP_UPDATE_FAILED: instproxy_error_t = -26;
pub const instproxy_error_t_INSTPROXY_E_MANIFEST_CAPTURE_FAILED: instproxy_error_t = -27;
pub const instproxy_error_t_INSTPROXY_E_MAP_GENERATION_FAILED: instproxy_error_t = -28;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_EXECUTABLE: instproxy_error_t = -29;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_IDENTIFIER: instproxy_error_t = -30;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_PATH: instproxy_error_t = -31;
pub const instproxy_error_t_INSTPROXY_E_MISSING_CONTAINER: instproxy_error_t = -32;
pub const instproxy_error_t_INSTPROXY_E_NOTIFICATION_FAILED: instproxy_error_t = -33;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_EXTRACTION_FAILED: instproxy_error_t = -34;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_INSPECTION_FAILED: instproxy_error_t = -35;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_MOVE_FAILED: instproxy_error_t = -36;
pub const instproxy_error_t_INSTPROXY_E_PATH_CONVERSION_FAILED: instproxy_error_t = -37;
pub const instproxy_error_t_INSTPROXY_E_RESTORE_CONTAINER_FAILED: instproxy_error_t = -38;
pub const instproxy_error_t_INSTPROXY_E_SEATBELT_PROFILE_REMOVAL_FAILED: instproxy_error_t = -39;
pub const instproxy_error_t_INSTPROXY_E_STAGE_CREATION_FAILED: instproxy_error_t = -40;
pub const instproxy_error_t_INSTPROXY_E_SYMLINK_FAILED: instproxy_error_t = -41;
pub const instproxy_error_t_INSTPROXY_E_UNKNOWN_COMMAND: instproxy_error_t = -42;
pub const instproxy_error_t_INSTPROXY_E_ITUNES_ARTWORK_CAPTURE_FAILED: instproxy_error_t = -43;
pub const instproxy_error_t_INSTPROXY_E_ITUNES_METADATA_CAPTURE_FAILED: instproxy_error_t = -44;
pub const instproxy_error_t_INSTPROXY_E_DEVICE_OS_VERSION_TOO_LOW: instproxy_error_t = -45;
pub const instproxy_error_t_INSTPROXY_E_DEVICE_FAMILY_NOT_SUPPORTED: instproxy_error_t = -46;
pub const instproxy_error_t_INSTPROXY_E_PACKAGE_PATCH_FAILED: instproxy_error_t = -47;
pub const instproxy_error_t_INSTPROXY_E_INCORRECT_ARCHITECTURE: instproxy_error_t = -48;
pub const instproxy_error_t_INSTPROXY_E_PLUGIN_COPY_FAILED: instproxy_error_t = -49;
pub const instproxy_error_t_INSTPROXY_E_BREADCRUMB_FAILED: instproxy_error_t = -50;
pub const instproxy_error_t_INSTPROXY_E_BREADCRUMB_UNLOCK_FAILED: instproxy_error_t = -51;
pub const instproxy_error_t_INSTPROXY_E_GEOJSON_CAPTURE_FAILED: instproxy_error_t = -52;
pub const instproxy_error_t_INSTPROXY_E_NEWSSTAND_ARTWORK_CAPTURE_FAILED: instproxy_error_t = -53;
pub const instproxy_error_t_INSTPROXY_E_MISSING_COMMAND: instproxy_error_t = -54;
pub const instproxy_error_t_INSTPROXY_E_NOT_ENTITLED: instproxy_error_t = -55;
pub const instproxy_error_t_INSTPROXY_E_MISSING_PACKAGE_PATH: instproxy_error_t = -56;
pub const instproxy_error_t_INSTPROXY_E_MISSING_CONTAINER_PATH: instproxy_error_t = -57;
pub const instproxy_error_t_INSTPROXY_E_MISSING_APPLICATION_IDENTIFIER: instproxy_error_t = -58;
pub const instproxy_error_t_INSTPROXY_E_MISSING_ATTRIBUTE_VALUE: instproxy_error_t = -59;
pub const instproxy_error_t_INSTPROXY_E_LOOKUP_FAILED: instproxy_error_t = -60;
pub const instproxy_error_t_INSTPROXY_E_DICT_CREATION_FAILED: instproxy_error_t = -61;
pub const instproxy_error_t_INSTPROXY_E_INSTALL_PROHIBITED: instproxy_error_t = -62;
pub const instproxy_error_t_INSTPROXY_E_UNINSTALL_PROHIBITED: instproxy_error_t = -63;
pub const instproxy_error_t_INSTPROXY_E_MISSING_BUNDLE_VERSION: instproxy_error_t = -64;
pub const instproxy_error_t_INSTPROXY_E_UNKNOWN_ERROR: instproxy_error_t = -256;
#[doc = " Error Codes"]
pub type instproxy_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct instproxy_client_private {
    _unused: [u8; 0],
}
pub type instproxy_client_t = *mut instproxy_client_private;
#[doc = " Reports the status response of the given command"]
pub type instproxy_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(command: plist_t, status: plist_t, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Connects to the installation_proxy service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to"]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "        instproxy_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success, or an INSTPROXY_E_* error value"]
    #[doc = "         when an error occurred."]
    pub fn instproxy_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut instproxy_client_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Starts a new installation_proxy service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "        instproxy_client_t upon successful return. Must be freed using"]
    #[doc = "        instproxy_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "        Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success, or an INSTPROXY_E_* error"]
    #[doc = "         code otherwise."]
    pub fn instproxy_client_start_service(
        device: idevice_t,
        client: *mut instproxy_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Disconnects an installation_proxy client from the device and frees up the"]
    #[doc = " installation_proxy client data."]
    #[doc = ""]
    #[doc = " @param client The installation_proxy client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success"]
    #[doc = "         or INSTPROXY_E_INVALID_ARG if client is NULL."]
    pub fn instproxy_client_free(client: instproxy_client_t) -> instproxy_error_t;
}
extern "C" {
    #[doc = " List installed applications. This function runs synchronously."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid client options include:"]
    #[doc = "          \"ApplicationType\" -> \"System\""]
    #[doc = "          \"ApplicationType\" -> \"User\""]
    #[doc = "          \"ApplicationType\" -> \"Internal\""]
    #[doc = "          \"ApplicationType\" -> \"Any\""]
    #[doc = " @param result Pointer that will be set to a plist that will hold an array"]
    #[doc = "        of PLIST_DICT holding information about the applications found."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_browse(
        client: instproxy_client_t,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " List pages of installed applications in a callback."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid client options include:"]
    #[doc = "          \"ApplicationType\" -> \"System\""]
    #[doc = "          \"ApplicationType\" -> \"User\""]
    #[doc = "          \"ApplicationType\" -> \"Internal\""]
    #[doc = "          \"ApplicationType\" -> \"Any\""]
    #[doc = " @param status_cb Callback function to process each page of application"]
    #[doc = "        information. Passing a callback is required."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_browse_with_callback(
        client: instproxy_client_t,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Lookup information about specific applications from the device."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param appids An array of bundle identifiers that MUST have a terminating"]
    #[doc = "        NULL entry or NULL to lookup all."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param result Pointer that will be set to a plist containing a PLIST_DICT"]
    #[doc = "        holding requested information about the application or NULL on errors."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_lookup(
        client: instproxy_client_t,
        appids: *mut *const ::std::os::raw::c_char,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Install an application on the device."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param pkg_path Path of the installation package (inside the AFC jail)"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"iTunesMetadata\" -> PLIST_DATA"]
    #[doc = "          \"ApplicationSINF\" -> PLIST_DATA"]
    #[doc = "          \"PackageType\" -> \"Developer\""]
    #[doc = "        If PackageType -> Developer is specified, then pkg_path points to"]
    #[doc = "        an .app directory instead of an install package."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_install(
        client: instproxy_client_t,
        pkg_path: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Upgrade an application on the device. This function is nearly the same as"]
    #[doc = " instproxy_install; the difference is that the installation progress on the"]
    #[doc = " device is faster if the application is already installed."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param pkg_path Path of the installation package (inside the AFC jail)"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"iTunesMetadata\" -> PLIST_DATA"]
    #[doc = "          \"ApplicationSINF\" -> PLIST_DATA"]
    #[doc = "          \"PackageType\" -> \"Developer\""]
    #[doc = "        If PackageType -> Developer is specified, then pkg_path points to"]
    #[doc = "        an .app directory instead of an install package."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_upgrade(
        client: instproxy_client_t,
        pkg_path: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Uninstall an application from the device."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the app to uninstall"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "     an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_uninstall(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " List archived applications. This function runs synchronously."]
    #[doc = ""]
    #[doc = " @see instproxy_archive"]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param result Pointer that will be set to a plist containing a PLIST_DICT"]
    #[doc = "        holding information about the archived applications found."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_lookup_archives(
        client: instproxy_client_t,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Archive an application on the device."]
    #[doc = " This function tells the device to make an archive of the specified"]
    #[doc = " application. This results in the device creating a ZIP archive in the"]
    #[doc = " 'ApplicationArchives' directory and uninstalling the application."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the app to archive."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"SkipUninstall\" -> Boolean"]
    #[doc = "          \"ArchiveType\" -> \"ApplicationOnly\""]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "     an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_archive(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Restore a previously archived application on the device."]
    #[doc = " This function is the counterpart to instproxy_archive."]
    #[doc = " @see instproxy_archive"]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the app to restore."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Valid options include:"]
    #[doc = "          \"ArchiveType\" -> \"DocumentsOnly\""]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "     an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_restore(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Removes a previously archived application from the device."]
    #[doc = " This function removes the ZIP archive from the 'ApplicationArchives'"]
    #[doc = " directory."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client"]
    #[doc = " @param appid ApplicationIdentifier of the archived app to remove."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so passing NULL is fine."]
    #[doc = " @param status_cb Callback function for progress and status information. If"]
    #[doc = "        NULL is passed, this function will run synchronously."]
    #[doc = " @param user_data Callback data passed to status_cb."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    #[doc = ""]
    #[doc = " @note If a callback function is given (async mode), this function returns"]
    #[doc = "       INSTPROXY_E_SUCCESS immediately if the status updater thread has been"]
    #[doc = "       created successfully; any error occurring during the command has to be"]
    #[doc = "       handled inside the specified callback function."]
    pub fn instproxy_remove_archive(
        client: instproxy_client_t,
        appid: *const ::std::os::raw::c_char,
        client_options: plist_t,
        status_cb: instproxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Checks a device for certain capabilities."]
    #[doc = ""]
    #[doc = " @param client The connected installation_proxy client"]
    #[doc = " @param capabilities An array of char* with capability names that MUST have a"]
    #[doc = "        terminating\u{a0}NULL entry."]
    #[doc = " @param client_options The client options to use, as PLIST_DICT, or NULL."]
    #[doc = "        Currently there are no known client options, so pass NULL here."]
    #[doc = " @param result Pointer that will be set to a plist containing a PLIST_DICT"]
    #[doc = "        holding information if the capabilities matched or NULL on errors."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success or an INSTPROXY_E_* error value if"]
    #[doc = "         an error occurred."]
    pub fn instproxy_check_capabilities_match(
        client: instproxy_client_t,
        capabilities: *mut *const ::std::os::raw::c_char,
        client_options: plist_t,
        result: *mut plist_t,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Gets the name from a command dictionary."]
    #[doc = ""]
    #[doc = " @param command The dictionary describing the command."]
    #[doc = " @param name Pointer to store the name of the command."]
    pub fn instproxy_command_get_name(command: plist_t, name: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the name of a status."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param name Pointer to store the name of the status."]
    pub fn instproxy_status_get_name(status: plist_t, name: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets error name, code and description from a response if available."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param name Pointer to store the name of an error."]
    #[doc = " @param description Pointer to store error description text if available."]
    #[doc = "        The caller is reponsible for freeing the allocated buffer after use."]
    #[doc = "        If NULL is passed no description will be returned."]
    #[doc = " @param code Pointer to store the returned error code if available."]
    #[doc = "        If NULL is passed no error code will be returned."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS if no error is found or an INSTPROXY_E_* error"]
    #[doc = "   value matching the error that as found in the status."]
    pub fn instproxy_status_get_error(
        status: plist_t,
        name: *mut *mut ::std::os::raw::c_char,
        description: *mut *mut ::std::os::raw::c_char,
        code: *mut u64,
    ) -> instproxy_error_t;
}
extern "C" {
    #[doc = " Gets total and current item information from a browse response if available."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param total Pointer to store the total number of items."]
    #[doc = " @param current_index Pointer to store the current index of all browsed items."]
    #[doc = " @param current_amount Pointer to store the amount of items in the"]
    #[doc = "        current list."]
    #[doc = " @param list Pointer to store a newly allocated plist with items."]
    #[doc = "        The caller is reponsible for freeing the list after use."]
    #[doc = "        If NULL is passed no list will be returned. If NULL is returned no"]
    #[doc = "        list was found in the status."]
    pub fn instproxy_status_get_current_list(
        status: plist_t,
        total: *mut u64,
        current_index: *mut u64,
        current_amount: *mut u64,
        list: *mut plist_t,
    );
}
extern "C" {
    #[doc = " Gets progress in percentage from a status if available."]
    #[doc = ""]
    #[doc = " @param status The dictionary status response to use."]
    #[doc = " @param percent Pointer to an int to store the progress in percent (0-100)"]
    #[doc = "        or -1 if no progress was found in the status."]
    pub fn instproxy_status_get_percent_complete(
        status: plist_t,
        percent: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Creates a new client_options plist."]
    #[doc = ""]
    #[doc = " @return A new plist_t of type PLIST_DICT."]
    pub fn instproxy_client_options_new() -> plist_t;
}
extern "C" {
    #[doc = " Adds one or more new key:value pairs to the given client_options."]
    #[doc = ""]
    #[doc = " @param client_options The client options to modify."]
    #[doc = " @param ... KEY, VALUE, [KEY, VALUE], NULL"]
    #[doc = ""]
    #[doc = " @note The keys and values passed are expected to be strings, except for the"]
    #[doc = "       keys \"ApplicationSINF\", \"iTunesMetadata\", \"ReturnAttributes\" which are"]
    #[doc = "       expecting a plist_t node as value and \"SkipUninstall\" expects int."]
    pub fn instproxy_client_options_add(client_options: plist_t, ...);
}
extern "C" {
    #[doc = " Adds attributes to the given client_options to filter browse results."]
    #[doc = ""]
    #[doc = " @param client_options The client options to modify."]
    #[doc = " @param ... VALUE, VALUE, [VALUE], NULL"]
    #[doc = ""]
    #[doc = " @note The values passed are expected to be strings."]
    pub fn instproxy_client_options_set_return_attributes(client_options: plist_t, ...);
}
extern "C" {
    #[doc = " Frees client_options plist."]
    #[doc = ""]
    #[doc = " @param client_options The client options plist to free. Does nothing if NULL"]
    #[doc = "        is passed."]
    pub fn instproxy_client_options_free(client_options: plist_t);
}
extern "C" {
    #[doc = " Queries the device for the path of an application."]
    #[doc = ""]
    #[doc = " @param client The connected installation proxy client."]
    #[doc = " @param bundle_id ApplicationIdentifier of app to retrieve the path for."]
    #[doc = " @param path Pointer to store the device path for the application"]
    #[doc = "        which is set to NULL if it could not be determined."]
    #[doc = ""]
    #[doc = " @return INSTPROXY_E_SUCCESS on success, INSTPROXY_E_OP_FAILED if"]
    #[doc = "         the path could not be determined or an INSTPROXY_E_* error"]
    #[doc = "         value if an error occurred."]
    pub fn instproxy_client_get_path_for_bundle_identifier(
        client: instproxy_client_t,
        bundle_id: *const ::std::os::raw::c_char,
        path: *mut *mut ::std::os::raw::c_char,
    ) -> instproxy_error_t;
}
pub const misagent_error_t_MISAGENT_E_SUCCESS: misagent_error_t = 0;
pub const misagent_error_t_MISAGENT_E_INVALID_ARG: misagent_error_t = -1;
pub const misagent_error_t_MISAGENT_E_PLIST_ERROR: misagent_error_t = -2;
pub const misagent_error_t_MISAGENT_E_CONN_FAILED: misagent_error_t = -3;
pub const misagent_error_t_MISAGENT_E_REQUEST_FAILED: misagent_error_t = -4;
pub const misagent_error_t_MISAGENT_E_UNKNOWN_ERROR: misagent_error_t = -256;
#[doc = " Error Codes"]
pub type misagent_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct misagent_client_private {
    _unused: [u8; 0],
}
pub type misagent_client_t = *mut misagent_client_private;
extern "C" {
    #[doc = " Connects to the misagent service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     misagent_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, MISAGENT_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an MISAGENT_E_* error code otherwise."]
    pub fn misagent_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut misagent_client_t,
    ) -> misagent_error_t;
}
extern "C" {
    #[doc = " Starts a new misagent service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     misagent_client_t upon successful return. Must be freed using"]
    #[doc = "     misagent_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, or an MISAGENT_E_* error"]
    #[doc = "     code otherwise."]
    pub fn misagent_client_start_service(
        device: idevice_t,
        client: *mut misagent_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> misagent_error_t;
}
extern "C" {
    #[doc = " Disconnects an misagent client from the device and frees up the"]
    #[doc = " misagent client data."]
    #[doc = ""]
    #[doc = " @param client The misagent client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, MISAGENT_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an MISAGENT_E_* error code otherwise."]
    pub fn misagent_client_free(client: misagent_client_t) -> misagent_error_t;
}
extern "C" {
    #[doc = " Installs the given provisioning profile. Only works with valid profiles."]
    #[doc = ""]
    #[doc = " @param client The connected misagent to use for installation"]
    #[doc = " @param profile The valid provisioning profile to install. This has to be"]
    #[doc = "    passed as a PLIST_DATA, otherwise the function will fail."]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, MISAGENT_E_INVALID_ARG when"]
    #[doc = "     client is invalid, or an MISAGENT_E_* error code otherwise."]
    pub fn misagent_install(client: misagent_client_t, profile: plist_t) -> misagent_error_t;
}
extern "C" {
    #[doc = " Retrieves all installed provisioning profiles (iOS 9.2.1 or below)."]
    #[doc = ""]
    #[doc = " @param client The connected misagent to use."]
    #[doc = " @param profiles Pointer to a plist_t that will be set to a PLIST_ARRAY"]
    #[doc = "    if the function is successful."]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, MISAGENT_E_INVALID_ARG when"]
    #[doc = "     client is invalid, or an MISAGENT_E_* error code otherwise."]
    #[doc = ""]
    #[doc = " @note This API call only works with iOS 9.2.1 or below."]
    #[doc = "     For newer iOS versions use misagent_copy_all() instead."]
    #[doc = ""]
    #[doc = " @note If no provisioning profiles are installed on the device, this function"]
    #[doc = "     still returns MISAGENT_E_SUCCESS and profiles will just point to an"]
    #[doc = "     empty array."]
    pub fn misagent_copy(client: misagent_client_t, profiles: *mut plist_t) -> misagent_error_t;
}
extern "C" {
    #[doc = " Retrieves all installed provisioning profiles (iOS 9.3 or higher)."]
    #[doc = ""]
    #[doc = " @param client The connected misagent to use."]
    #[doc = " @param profiles Pointer to a plist_t that will be set to a PLIST_ARRAY"]
    #[doc = "    if the function is successful."]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, MISAGENT_E_INVALID_ARG when"]
    #[doc = "     client is invalid, or an MISAGENT_E_* error code otherwise."]
    #[doc = ""]
    #[doc = " @note This API call only works with iOS 9.3 or higher."]
    #[doc = "     For older iOS versions use misagent_copy() instead."]
    #[doc = ""]
    #[doc = " @note If no provisioning profiles are installed on the device, this function"]
    #[doc = "     still returns MISAGENT_E_SUCCESS and profiles will just point to an"]
    #[doc = "     empty array."]
    pub fn misagent_copy_all(client: misagent_client_t, profiles: *mut plist_t)
        -> misagent_error_t;
}
extern "C" {
    #[doc = " Removes a given provisioning profile."]
    #[doc = ""]
    #[doc = " @param client The connected misagent to use."]
    #[doc = " @param profileID Identifier of the provisioning profile to remove."]
    #[doc = "    This is a UUID that can be obtained from the provisioning profile data."]
    #[doc = " @see misagent_copy"]
    #[doc = ""]
    #[doc = " @return MISAGENT_E_SUCCESS on success, MISAGENT_E_INVALID_ARG when"]
    #[doc = "     client is invalid, or an MISAGENT_E_* error code otherwise."]
    pub fn misagent_remove(
        client: misagent_client_t,
        profileID: *const ::std::os::raw::c_char,
    ) -> misagent_error_t;
}
extern "C" {
    #[doc = " Retrieves the status code from the last operation."]
    #[doc = ""]
    #[doc = " @param client The misagent to use."]
    #[doc = ""]
    #[doc = " @return -1 if client is invalid, or the status code from the last operation"]
    pub fn misagent_get_status_code(client: misagent_client_t) -> ::std::os::raw::c_int;
}
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_SUCCESS:
    mobile_image_mounter_error_t = 0;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_INVALID_ARG:
    mobile_image_mounter_error_t = -1;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_PLIST_ERROR:
    mobile_image_mounter_error_t = -2;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_CONN_FAILED:
    mobile_image_mounter_error_t = -3;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_COMMAND_FAILED:
    mobile_image_mounter_error_t = -4;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_DEVICE_LOCKED:
    mobile_image_mounter_error_t = -5;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_NOT_SUPPORTED:
    mobile_image_mounter_error_t = -6;
pub const mobile_image_mounter_error_t_MOBILE_IMAGE_MOUNTER_E_UNKNOWN_ERROR:
    mobile_image_mounter_error_t = -256;
#[doc = " Error Codes"]
pub type mobile_image_mounter_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mobile_image_mounter_client_private {
    _unused: [u8; 0],
}
pub type mobile_image_mounter_client_t = *mut mobile_image_mounter_client_private;
#[doc = " callback for image upload"]
pub type mobile_image_mounter_upload_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        length: size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ssize_t,
>;
extern "C" {
    #[doc = " Connects to the mobile_image_mounter service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "    mobile_image_mounter_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    MOBILE_IMAGE_MOUNTER_E_INVALID_ARG if device is NULL,"]
    #[doc = "    or MOBILE_IMAGE_MOUNTER_E_CONN_FAILED if the connection to the"]
    #[doc = "    device could not be established."]
    pub fn mobile_image_mounter_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut mobile_image_mounter_client_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Starts a new mobile_image_mounter service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     mobile_image_mounter_t upon successful return. Must be freed using"]
    #[doc = "     mobile_image_mounter_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success, or an MOBILE_IMAGE_MOUNTER_E_* error"]
    #[doc = "     code otherwise."]
    pub fn mobile_image_mounter_start_service(
        device: idevice_t,
        client: *mut mobile_image_mounter_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Disconnects a mobile_image_mounter client from the device and frees up the"]
    #[doc = " mobile_image_mounter client data."]
    #[doc = ""]
    #[doc = " @param client The mobile_image_mounter client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or MOBILE_IMAGE_MOUNTER_E_INVALID_ARG if client is NULL."]
    pub fn mobile_image_mounter_free(
        client: mobile_image_mounter_client_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Tells if the image of ImageType is already mounted."]
    #[doc = ""]
    #[doc = " @param client The client use"]
    #[doc = " @param image_type The type of the image to look up"]
    #[doc = " @param result Pointer to a plist that will receive the result of the"]
    #[doc = "    operation."]
    #[doc = ""]
    #[doc = " @note This function may return MOBILE_IMAGE_MOUNTER_E_SUCCESS even if the"]
    #[doc = "    operation has failed. Check the resulting plist for further information."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success, or an error code on error"]
    pub fn mobile_image_mounter_lookup_image(
        client: mobile_image_mounter_client_t,
        image_type: *const ::std::os::raw::c_char,
        result: *mut plist_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Uploads an image with an optional signature to the device."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param image_type Type of image that is being uploaded."]
    #[doc = " @param image_size Total size of the image."]
    #[doc = " @param signature Buffer with a signature of the image being uploaded. If"]
    #[doc = "    NULL, no signature will be used."]
    #[doc = " @param signature_size Total size of the image signature buffer. If 0, no"]
    #[doc = "    signature will be used."]
    #[doc = " @param upload_cb Callback function that gets the data chunks for uploading"]
    #[doc = "    the image."]
    #[doc = " @param userdata User defined data for the upload callback function."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on succes, or a"]
    #[doc = "    MOBILE_IMAGE_MOUNTER_E_* error code otherwise."]
    pub fn mobile_image_mounter_upload_image(
        client: mobile_image_mounter_client_t,
        image_type: *const ::std::os::raw::c_char,
        image_size: size_t,
        signature: *const ::std::os::raw::c_uchar,
        signature_size: ::std::os::raw::c_uint,
        upload_cb: mobile_image_mounter_upload_cb_t,
        userdata: *mut ::std::os::raw::c_void,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Mounts an image on the device."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param image_path The absolute path of the image to mount. The image must"]
    #[doc = "    be present before calling this function."]
    #[doc = " @param signature Pointer to a buffer holding the images' signature"]
    #[doc = " @param signature_size Length of the signature image_signature points to"]
    #[doc = " @param image_type Type of image to mount"]
    #[doc = " @param options A dictionary containing additional key/value pairs to add"]
    #[doc = " @param result Pointer to a plist that will receive the result of the"]
    #[doc = "    operation."]
    #[doc = ""]
    #[doc = " @note This function may return MOBILE_IMAGE_MOUNTER_E_SUCCESS even if the"]
    #[doc = "    operation has failed. Check the resulting plist for further information."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    MOBILE_IMAGE_MOUNTER_E_INVALID_ARG if on ore more parameters are"]
    #[doc = "    invalid, or another error code otherwise."]
    pub fn mobile_image_mounter_mount_image_with_options(
        client: mobile_image_mounter_client_t,
        image_path: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_uchar,
        signature_size: ::std::os::raw::c_uint,
        image_type: *const ::std::os::raw::c_char,
        options: plist_t,
        result: *mut plist_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Mounts an image on the device."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param image_path The absolute path of the image to mount. The image must"]
    #[doc = "    be present before calling this function."]
    #[doc = " @param signature Pointer to a buffer holding the images' signature"]
    #[doc = " @param signature_size Length of the signature image_signature points to"]
    #[doc = " @param image_type Type of image to mount"]
    #[doc = " @param result Pointer to a plist that will receive the result of the"]
    #[doc = "    operation."]
    #[doc = ""]
    #[doc = " @note This function may return MOBILE_IMAGE_MOUNTER_E_SUCCESS even if the"]
    #[doc = "    operation has failed. Check the resulting plist for further information."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    MOBILE_IMAGE_MOUNTER_E_INVALID_ARG if on ore more parameters are"]
    #[doc = "    invalid, or another error code otherwise."]
    pub fn mobile_image_mounter_mount_image(
        client: mobile_image_mounter_client_t,
        image_path: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_uchar,
        signature_size: ::std::os::raw::c_uint,
        image_type: *const ::std::os::raw::c_char,
        result: *mut plist_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Unmount a mounted image at given path on the device."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param mount_path The mount path of the mounted image on the device."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_unmount_image(
        client: mobile_image_mounter_client_t,
        mount_path: *const ::std::os::raw::c_char,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Hangs up the connection to the mobile_image_mounter service."]
    #[doc = " This functions has to be called before freeing up a mobile_image_mounter"]
    #[doc = " instance. If not, errors appear in the device's syslog."]
    #[doc = ""]
    #[doc = " @param client The client to hang up"]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "     MOBILE_IMAGE_MOUNTER_E_INVALID_ARG if client is invalid,"]
    #[doc = "     or another error code otherwise."]
    pub fn mobile_image_mounter_hangup(
        client: mobile_image_mounter_client_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Query the developer mode status of the given device."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param result A pointer to a plist_t that will be set to the resulting developer mode status dictionary."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_query_developer_mode_status(
        client: mobile_image_mounter_client_t,
        result: *mut plist_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Query a personalization nonce for the given image type, used for personalized disk images (iOS 17+)."]
    #[doc = " This nonce is supposed to be added to the TSS request for the corresponding image."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param image_type The image_type to get the personalization nonce for, usually `DeveloperDiskImage`."]
    #[doc = " @param nonce Pointer that will be set to an allocated buffer with the nonce value."]
    #[doc = " @param nonce_size Pointer to an unsigned int that will receive the size of the nonce value."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_query_nonce(
        client: mobile_image_mounter_client_t,
        image_type: *const ::std::os::raw::c_char,
        nonce: *mut *mut ::std::os::raw::c_uchar,
        nonce_size: *mut ::std::os::raw::c_uint,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Query personalization identitifers for the given image_type."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param image_type The image_type to get the personalization identifiers for. Can be NULL."]
    #[doc = " @param result A pointer to a plist_t that will be set to the resulting identifier dictionary."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_query_personalization_identifiers(
        client: mobile_image_mounter_client_t,
        image_type: *const ::std::os::raw::c_char,
        result: *mut plist_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = " @param image_type The image_type to get the personalization identifiers for. Can be NULL."]
    #[doc = " @param signature The signature of the corresponding personalized image."]
    #[doc = " @param signature_size The size of signature."]
    #[doc = " @param manifest Pointer that will be set to an allocated buffer with the manifest data."]
    #[doc = " @param manifest_size Pointer to an unsigned int that will be set to the size of the manifest data."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_query_personalization_manifest(
        client: mobile_image_mounter_client_t,
        image_type: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_uchar,
        signature_size: ::std::os::raw::c_uint,
        manifest: *mut *mut ::std::os::raw::c_uchar,
        manifest_size: *mut ::std::os::raw::c_uint,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Roll the personalization nonce."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_roll_personalization_nonce(
        client: mobile_image_mounter_client_t,
    ) -> mobile_image_mounter_error_t;
}
extern "C" {
    #[doc = " Roll the Cryptex nonce."]
    #[doc = ""]
    #[doc = " @param client The connected mobile_image_mounter client."]
    #[doc = ""]
    #[doc = " @return MOBILE_IMAGE_MOUNTER_E_SUCCESS on success,"]
    #[doc = "    or a MOBILE_IMAGE_MOUNTER_E_* error code on error."]
    pub fn mobile_image_mounter_roll_cryptex_nonce(
        client: mobile_image_mounter_client_t,
    ) -> mobile_image_mounter_error_t;
}
pub const mobileactivation_error_t_MOBILEACTIVATION_E_SUCCESS: mobileactivation_error_t = 0;
pub const mobileactivation_error_t_MOBILEACTIVATION_E_INVALID_ARG: mobileactivation_error_t = -1;
pub const mobileactivation_error_t_MOBILEACTIVATION_E_PLIST_ERROR: mobileactivation_error_t = -2;
pub const mobileactivation_error_t_MOBILEACTIVATION_E_MUX_ERROR: mobileactivation_error_t = -3;
pub const mobileactivation_error_t_MOBILEACTIVATION_E_UNKNOWN_REQUEST: mobileactivation_error_t =
    -4;
pub const mobileactivation_error_t_MOBILEACTIVATION_E_REQUEST_FAILED: mobileactivation_error_t = -5;
pub const mobileactivation_error_t_MOBILEACTIVATION_E_UNKNOWN_ERROR: mobileactivation_error_t =
    -256;
#[doc = " Error Codes"]
pub type mobileactivation_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mobileactivation_client_private {
    _unused: [u8; 0],
}
pub type mobileactivation_client_t = *mut mobileactivation_client_private;
extern "C" {
    #[doc = " Connects to the mobileactivation service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Reference that will point to a newly allocated"]
    #[doc = "     mobileactivation_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success,"]
    #[doc = "     MOBILEACTIVATION_E_INVALID_ARG when one of the parameters is invalid,"]
    #[doc = "     or MOBILEACTIVATION_E_MUX_ERROR when the connection failed."]
    pub fn mobileactivation_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut mobileactivation_client_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Starts a new mobileactivation service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     mobileactivation_client_t upon successful return. Must be freed using"]
    #[doc = "     mobileactivation_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_client_start_service(
        device: idevice_t,
        client: *mut mobileactivation_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Disconnects a mobileactivation client from the device and frees up the"]
    #[doc = " mobileactivation client data."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success,"]
    #[doc = "     MOBILEACTIVATION_E_INVALID_ARG when one of client or client->parent"]
    #[doc = "     is invalid, or MOBILEACTIVATION_E_UNKNOWN_ERROR when the was an"]
    #[doc = "     error freeing the parent property_list_service client."]
    pub fn mobileactivation_client_free(
        client: mobileactivation_client_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Retrieves the device's activation state."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client."]
    #[doc = " @param state Pointer to a plist_t variable that will be set to the"]
    #[doc = "     activation state reported by the mobileactivation service. The"]
    #[doc = "     consumer is responsible for freeing the returned object using"]
    #[doc = "     plist_free()."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_get_activation_state(
        client: mobileactivation_client_t,
        state: *mut plist_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Retrieves a session blob required for 'drmHandshake' via albert.apple.com."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client"]
    #[doc = " @param blob Pointer to a plist_t variable that will be set to the"]
    #[doc = "     session blob created by the mobielactivation service. The"]
    #[doc = "     consumer is responsible for freeing the returned object using"]
    #[doc = "     plist_free()."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_create_activation_session_info(
        client: mobileactivation_client_t,
        blob: *mut plist_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Retrieves the activation info required for device activation."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client"]
    #[doc = " @param info Pointer to a plist_t variable that will be set to the"]
    #[doc = "     activation info created by the mobileactivation service. The"]
    #[doc = "     consumer is responsible for freeing the returned object using"]
    #[doc = "     plist_free()."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_create_activation_info(
        client: mobileactivation_client_t,
        info: *mut plist_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Retrieves the activation info required for device activation in 'session'"]
    #[doc = " mode. This function expects a handshake result retrieved from"]
    #[doc = " https://albert.apple.com/deviceservies/drmHandshake  with a blob"]
    #[doc = " provided by mobileactivation_create_activation_session_info()."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client"]
    #[doc = " @param handshake_response The handshake response returned from drmHandshake"]
    #[doc = " @param info Pointer to a plist_t variable that will be set to the"]
    #[doc = "     activation info created by the mobileactivation service. The"]
    #[doc = "     consumer is responsible for freeing the returned object using"]
    #[doc = "     plist_free()."]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_create_activation_info_with_session(
        client: mobileactivation_client_t,
        handshake_response: plist_t,
        info: *mut plist_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Activates the device with the given activation record."]
    #[doc = " The activation record plist dictionary must be obtained using the"]
    #[doc = " activation protocol requesting from Apple's https webservice."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client"]
    #[doc = " @param activation_record The activation record plist dictionary"]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_activate(
        client: mobileactivation_client_t,
        activation_record: plist_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Activates the device with the given activation record in 'session' mode."]
    #[doc = " The activation record plist must be obtained using the"]
    #[doc = " activation protocol requesting from Apple's https webservice."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client"]
    #[doc = " @param activation_record The activation record in plist format"]
    #[doc = " @param headers A plist dictionary with the activation response headers"]
    #[doc = "     as returned from Apple's https webservice with the activation record"]
    #[doc = ""]
    #[doc = " @return MOBILEACTIVATION_E_SUCCESS on success, or an MOBILEACTIVATION_E_*"]
    #[doc = "     error code otherwise."]
    pub fn mobileactivation_activate_with_session(
        client: mobileactivation_client_t,
        activation_record: plist_t,
        headers: plist_t,
    ) -> mobileactivation_error_t;
}
extern "C" {
    #[doc = " Deactivates the device."]
    #[doc = ""]
    #[doc = " @param client The mobileactivation client"]
    pub fn mobileactivation_deactivate(
        client: mobileactivation_client_t,
    ) -> mobileactivation_error_t;
}
pub const mobilebackup_error_t_MOBILEBACKUP_E_SUCCESS: mobilebackup_error_t = 0;
pub const mobilebackup_error_t_MOBILEBACKUP_E_INVALID_ARG: mobilebackup_error_t = -1;
pub const mobilebackup_error_t_MOBILEBACKUP_E_PLIST_ERROR: mobilebackup_error_t = -2;
pub const mobilebackup_error_t_MOBILEBACKUP_E_MUX_ERROR: mobilebackup_error_t = -3;
pub const mobilebackup_error_t_MOBILEBACKUP_E_SSL_ERROR: mobilebackup_error_t = -4;
pub const mobilebackup_error_t_MOBILEBACKUP_E_RECEIVE_TIMEOUT: mobilebackup_error_t = -5;
pub const mobilebackup_error_t_MOBILEBACKUP_E_BAD_VERSION: mobilebackup_error_t = -6;
pub const mobilebackup_error_t_MOBILEBACKUP_E_REPLY_NOT_OK: mobilebackup_error_t = -7;
pub const mobilebackup_error_t_MOBILEBACKUP_E_UNKNOWN_ERROR: mobilebackup_error_t = -256;
#[doc = " Error Codes"]
pub type mobilebackup_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mobilebackup_client_private {
    _unused: [u8; 0],
}
pub type mobilebackup_client_t = *mut mobilebackup_client_private;
pub const mobilebackup_flags_t_MB_RESTORE_NOTIFY_SPRINGBOARD: mobilebackup_flags_t = 1;
pub const mobilebackup_flags_t_MB_RESTORE_PRESERVE_SETTINGS: mobilebackup_flags_t = 2;
pub const mobilebackup_flags_t_MB_RESTORE_PRESERVE_CAMERA_ROLL: mobilebackup_flags_t = 4;
#[doc = " Available flags passed to #mobilebackup_request_restore"]
pub type mobilebackup_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Connects to the mobilebackup service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     mobilebackup_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID ARG if one"]
    #[doc = "     or more parameters are invalid, or DEVICE_LINK_SERVICE_E_BAD_VERSION if"]
    #[doc = "     the mobilebackup version on the device is newer."]
    pub fn mobilebackup_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut mobilebackup_client_t,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Starts a new mobilebackup service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     mobilebackup_client_t upon successful return. Must be freed using"]
    #[doc = "     mobilebackup_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, or an MOBILEBACKUP_E_* error"]
    #[doc = "     code otherwise."]
    pub fn mobilebackup_client_start_service(
        device: idevice_t,
        client: *mut mobilebackup_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Disconnects a mobilebackup client from the device and frees up the"]
    #[doc = " mobilebackup client data."]
    #[doc = ""]
    #[doc = " @param client The mobilebackup client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, or MOBILEBACKUP_E_INVALID_ARG"]
    #[doc = "     if client is NULL."]
    pub fn mobilebackup_client_free(client: mobilebackup_client_t) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Polls the device for mobilebackup data."]
    #[doc = ""]
    #[doc = " @param client The mobilebackup client"]
    #[doc = " @param plist A pointer to the location where the plist should be stored"]
    #[doc = ""]
    #[doc = " @return an error code"]
    pub fn mobilebackup_receive(
        client: mobilebackup_client_t,
        plist: *mut plist_t,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Sends mobilebackup data to the device"]
    #[doc = ""]
    #[doc = " @note This function is low-level and should only be used if you need to send"]
    #[doc = "        a new type of message."]
    #[doc = ""]
    #[doc = " @param client The mobilebackup client"]
    #[doc = " @param plist The location of the plist to send"]
    #[doc = ""]
    #[doc = " @return an error code"]
    pub fn mobilebackup_send(client: mobilebackup_client_t, plist: plist_t)
        -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Request a backup from the connected device."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param backup_manifest The backup manifest, a plist_t of type PLIST_DICT"]
    #[doc = "    containing the backup state of the last backup. For a first-time backup"]
    #[doc = "    set this parameter to NULL."]
    #[doc = " @param base_path The base path on the device to use for the backup"]
    #[doc = "    operation, usually \"/\"."]
    #[doc = " @param proto_version A string denoting the version of the backup protocol"]
    #[doc = "    to use. Latest known version is \"1.6\""]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    one of the parameters is invalid, MOBILEBACKUP_E_PLIST_ERROR if"]
    #[doc = "    backup_manifest is not of type PLIST_DICT, MOBILEBACKUP_E_MUX_ERROR"]
    #[doc = "    if a communication error occurs, MOBILEBACKUP_E_REPLY_NOT_OK"]
    pub fn mobilebackup_request_backup(
        client: mobilebackup_client_t,
        backup_manifest: plist_t,
        base_path: *const ::std::os::raw::c_char,
        proto_version: *const ::std::os::raw::c_char,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Sends a confirmation to the device that a backup file has been received."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    client is invalid, or MOBILEBACKUP_E_MUX_ERROR if a communication error"]
    #[doc = "    occurs."]
    pub fn mobilebackup_send_backup_file_received(
        client: mobilebackup_client_t,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Request that a backup should be restored to the connected device."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param backup_manifest The backup manifest, a plist_t of type PLIST_DICT"]
    #[doc = "    containing the backup state to be restored."]
    #[doc = " @param flags Flags to send with the request. Currently this is a combination"]
    #[doc = "    of the following mobilebackup_flags_t:"]
    #[doc = "    MB_RESTORE_NOTIFY_SPRINGBOARD - let SpringBoard show a 'Restore' screen"]
    #[doc = "    MB_RESTORE_PRESERVE_SETTINGS - do not overwrite any settings"]
    #[doc = "    MB_RESTORE_PRESERVE_CAMERA_ROLL - preserve the photos of the camera roll"]
    #[doc = " @param proto_version A string denoting the version of the backup protocol"]
    #[doc = "    to use. Latest known version is \"1.6\". Ideally this value should be"]
    #[doc = "    extracted from the given manifest plist."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    one of the parameters is invalid, MOBILEBACKUP_E_PLIST_ERROR if"]
    #[doc = "    backup_manifest is not of type PLIST_DICT, MOBILEBACKUP_E_MUX_ERROR"]
    #[doc = "    if a communication error occurs, or MOBILEBACKUP_E_REPLY_NOT_OK"]
    #[doc = "    if the device did not accept the request."]
    pub fn mobilebackup_request_restore(
        client: mobilebackup_client_t,
        backup_manifest: plist_t,
        flags: mobilebackup_flags_t,
        proto_version: *const ::std::os::raw::c_char,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Receive a confirmation from the device that it successfully received"]
    #[doc = " a restore file."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param result Pointer to a plist_t that will be set to the received plist"]
    #[doc = "    for further processing. The caller has to free it using plist_free()."]
    #[doc = "    Note that it will be set to NULL if the operation itself fails due to"]
    #[doc = "    a communication or plist error."]
    #[doc = "    If this parameter is NULL, it will be ignored."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    client is invalid, MOBILEBACKUP_E_REPLY_NOT_OK if the expected"]
    #[doc = "    'BackupMessageRestoreFileReceived' message could not be received,"]
    #[doc = "    MOBILEBACKUP_E_PLIST_ERROR if the received message is not a valid backup"]
    #[doc = "    message plist, or MOBILEBACKUP_E_MUX_ERROR if a communication error"]
    #[doc = "    occurs."]
    pub fn mobilebackup_receive_restore_file_received(
        client: mobilebackup_client_t,
        result: *mut plist_t,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Receive a confirmation from the device that it successfully received"]
    #[doc = " application data file."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param result Pointer to a plist_t that will be set to the received plist"]
    #[doc = "    for further processing. The caller has to free it using plist_free()."]
    #[doc = "    Note that it will be set to NULL if the operation itself fails due to"]
    #[doc = "    a communication or plist error."]
    #[doc = "    If this parameter is NULL, it will be ignored."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    client is invalid, MOBILEBACKUP_E_REPLY_NOT_OK if the expected"]
    #[doc = "    'BackupMessageRestoreApplicationReceived' message could not be received,"]
    #[doc = "    MOBILEBACKUP_E_PLIST_ERROR if the received message is not a valid backup"]
    #[doc = "    message plist, or MOBILEBACKUP_E_MUX_ERROR if a communication error"]
    #[doc = "    occurs."]
    pub fn mobilebackup_receive_restore_application_received(
        client: mobilebackup_client_t,
        result: *mut plist_t,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Tells the device that the restore process is complete and waits for the"]
    #[doc = " device to close the connection. After that, the device should reboot."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    client is invalid, MOBILEBACKUP_E_PLIST_ERROR if the received disconnect"]
    #[doc = "    message plist is invalid, or MOBILEBACKUP_E_MUX_ERROR if a communication"]
    #[doc = "    error occurs."]
    pub fn mobilebackup_send_restore_complete(
        client: mobilebackup_client_t,
    ) -> mobilebackup_error_t;
}
extern "C" {
    #[doc = " Sends a backup error message to the device."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param reason A string describing the reason for the error message."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP_E_SUCCESS on success, MOBILEBACKUP_E_INVALID_ARG if"]
    #[doc = "    one of the parameters is invalid, or MOBILEBACKUP_E_MUX_ERROR if a"]
    #[doc = "    communication error occurs."]
    pub fn mobilebackup_send_error(
        client: mobilebackup_client_t,
        reason: *const ::std::os::raw::c_char,
    ) -> mobilebackup_error_t;
}
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_SUCCESS: mobilebackup2_error_t = 0;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_INVALID_ARG: mobilebackup2_error_t = -1;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_PLIST_ERROR: mobilebackup2_error_t = -2;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_MUX_ERROR: mobilebackup2_error_t = -3;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_SSL_ERROR: mobilebackup2_error_t = -4;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_RECEIVE_TIMEOUT: mobilebackup2_error_t = -5;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_BAD_VERSION: mobilebackup2_error_t = -6;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_REPLY_NOT_OK: mobilebackup2_error_t = -7;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_NO_COMMON_VERSION: mobilebackup2_error_t = -8;
pub const mobilebackup2_error_t_MOBILEBACKUP2_E_UNKNOWN_ERROR: mobilebackup2_error_t = -256;
#[doc = " Error Codes"]
pub type mobilebackup2_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mobilebackup2_client_private {
    _unused: [u8; 0],
}
pub type mobilebackup2_client_t = *mut mobilebackup2_client_private;
extern "C" {
    #[doc = " Connects to the mobilebackup2 service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     mobilebackup2_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS on success, MOBILEBACKUP2_E_INVALID ARG"]
    #[doc = "     if one or more parameter is invalid, or MOBILEBACKUP2_E_BAD_VERSION"]
    #[doc = "     if the mobilebackup2 version on the device is newer."]
    pub fn mobilebackup2_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut mobilebackup2_client_t,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Starts a new mobilebackup2 service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     mobilebackup2_client_t upon successful return. Must be freed using"]
    #[doc = "     mobilebackup2_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS on success, or an MOBILEBACKUP2_E_* error"]
    #[doc = "     code otherwise."]
    pub fn mobilebackup2_client_start_service(
        device: idevice_t,
        client: *mut mobilebackup2_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Disconnects a mobilebackup2 client from the device and frees up the"]
    #[doc = " mobilebackup2 client data."]
    #[doc = ""]
    #[doc = " @param client The mobilebackup2 client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS on success, or MOBILEBACKUP2_E_INVALID_ARG"]
    #[doc = "     if client is NULL."]
    pub fn mobilebackup2_client_free(client: mobilebackup2_client_t) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Sends a backup message plist."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param message The message to send. This will be inserted into the request"]
    #[doc = "     plist as value for MessageName. If this parameter is NULL,"]
    #[doc = "     the plist passed in the options parameter will be sent directly."]
    #[doc = " @param options Additional options as PLIST_DICT to add to the request."]
    #[doc = "     The MessageName key with the value passed in the message parameter"]
    #[doc = "     will be inserted into this plist before sending it. This parameter"]
    #[doc = "     can be NULL if message is not NULL."]
    pub fn mobilebackup2_send_message(
        client: mobilebackup2_client_t,
        message: *const ::std::os::raw::c_char,
        options: plist_t,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Receives a DL* message plist from the device."]
    #[doc = " This function is a wrapper around device_link_service_receive_message."]
    #[doc = ""]
    #[doc = " @param client The connected MobileBackup client to use."]
    #[doc = " @param msg_plist Pointer to a plist that will be set to the contents of the"]
    #[doc = "    message plist upon successful return."]
    #[doc = " @param dlmessage A pointer that will be set to a newly allocated char*"]
    #[doc = "     containing the DL* string from the given plist. It is up to the caller"]
    #[doc = "     to free the allocated memory. If this parameter is NULL"]
    #[doc = "     it will be ignored."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS if a DL* message was received,"]
    #[doc = "    MOBILEBACKUP2_E_INVALID_ARG if client or message is invalid,"]
    #[doc = "    MOBILEBACKUP2_E_PLIST_ERROR if the received plist is invalid"]
    #[doc = "    or is not a DL* message plist, or MOBILEBACKUP2_E_MUX_ERROR if"]
    #[doc = "    receiving from the device failed."]
    pub fn mobilebackup2_receive_message(
        client: mobilebackup2_client_t,
        msg_plist: *mut plist_t,
        dlmessage: *mut *mut ::std::os::raw::c_char,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Send binary data to the device."]
    #[doc = ""]
    #[doc = " @note This function returns MOBILEBACKUP2_E_SUCCESS even if less than the"]
    #[doc = "     requested length has been sent. The fourth parameter is required and"]
    #[doc = "     must be checked to ensure if the whole data has been sent."]
    #[doc = ""]
    #[doc = " @param client The MobileBackup client to send to."]
    #[doc = " @param data Pointer to the data to send"]
    #[doc = " @param length Number of bytes to send"]
    #[doc = " @param bytes Number of bytes actually sent"]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS if any data was successfully sent,"]
    #[doc = "     MOBILEBACKUP2_E_INVALID_ARG if one of the parameters is invalid,"]
    #[doc = "     or MOBILEBACKUP2_E_MUX_ERROR if sending of the data failed."]
    pub fn mobilebackup2_send_raw(
        client: mobilebackup2_client_t,
        data: *const ::std::os::raw::c_char,
        length: u32,
        bytes: *mut u32,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Receive binary from the device."]
    #[doc = ""]
    #[doc = " @note This function returns MOBILEBACKUP2_E_SUCCESS even if no data"]
    #[doc = "     has been received (unless a communication error occurred)."]
    #[doc = "     The fourth parameter is required and must be checked to know how"]
    #[doc = "     many bytes were actually received."]
    #[doc = ""]
    #[doc = " @param client The MobileBackup client to receive from."]
    #[doc = " @param data Pointer to a buffer that will be filled with the received data."]
    #[doc = " @param length Number of bytes to receive. The data buffer needs to be large"]
    #[doc = "     enough to store this amount of data."]
    #[doc = " @param bytes Number of bytes actually received."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS if any or no data was received,"]
    #[doc = "     MOBILEBACKUP2_E_INVALID_ARG if one of the parameters is invalid,"]
    #[doc = "     or MOBILEBACKUP2_E_MUX_ERROR if receiving the data failed."]
    pub fn mobilebackup2_receive_raw(
        client: mobilebackup2_client_t,
        data: *mut ::std::os::raw::c_char,
        length: u32,
        bytes: *mut u32,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Performs the mobilebackup2 protocol version exchange."]
    #[doc = ""]
    #[doc = " @param client The MobileBackup client to use."]
    #[doc = " @param local_versions An array of supported versions to send to the remote."]
    #[doc = " @param count The number of items in local_versions."]
    #[doc = " @param remote_version Holds the protocol version of the remote on success."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS on success, or a MOBILEBACKUP2_E_* error"]
    #[doc = "     code otherwise."]
    pub fn mobilebackup2_version_exchange(
        client: mobilebackup2_client_t,
        local_versions: *mut f64,
        count: ::std::os::raw::c_char,
        remote_version: *mut f64,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Send a request to the connected mobilebackup2 service."]
    #[doc = ""]
    #[doc = " @param client"]
    #[doc = " @param request The request to send to the backup service."]
    #[doc = "     Currently, this is one of \"Backup\", \"Restore\", \"Info\", or \"List\"."]
    #[doc = " @param target_identifier UDID of the target device."]
    #[doc = " @param source_identifier UDID of backup data?"]
    #[doc = " @param options Additional options in a plist of type PLIST_DICT."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS if the request was successfully sent,"]
    #[doc = "     or a MOBILEBACKUP2_E_* error value otherwise."]
    pub fn mobilebackup2_send_request(
        client: mobilebackup2_client_t,
        request: *const ::std::os::raw::c_char,
        target_identifier: *const ::std::os::raw::c_char,
        source_identifier: *const ::std::os::raw::c_char,
        options: plist_t,
    ) -> mobilebackup2_error_t;
}
extern "C" {
    #[doc = " Sends a DLMessageStatusResponse to the device."]
    #[doc = ""]
    #[doc = " @param client The MobileBackup client to use."]
    #[doc = " @param status_code The status code to send."]
    #[doc = " @param status1 A status message to send. Can be NULL if not required."]
    #[doc = " @param status2 An additional status plist to attach to the response."]
    #[doc = "     Can be NULL if not required."]
    #[doc = ""]
    #[doc = " @return MOBILEBACKUP2_E_SUCCESS on success, MOBILEBACKUP2_E_INVALID_ARG"]
    #[doc = "     if client is invalid, or another MOBILEBACKUP2_E_* otherwise."]
    pub fn mobilebackup2_send_status_response(
        client: mobilebackup2_client_t,
        status_code: ::std::os::raw::c_int,
        status1: *const ::std::os::raw::c_char,
        status2: plist_t,
    ) -> mobilebackup2_error_t;
}
pub const mobilesync_error_t_MOBILESYNC_E_SUCCESS: mobilesync_error_t = 0;
pub const mobilesync_error_t_MOBILESYNC_E_INVALID_ARG: mobilesync_error_t = -1;
pub const mobilesync_error_t_MOBILESYNC_E_PLIST_ERROR: mobilesync_error_t = -2;
pub const mobilesync_error_t_MOBILESYNC_E_MUX_ERROR: mobilesync_error_t = -3;
pub const mobilesync_error_t_MOBILESYNC_E_SSL_ERROR: mobilesync_error_t = -4;
pub const mobilesync_error_t_MOBILESYNC_E_RECEIVE_TIMEOUT: mobilesync_error_t = -5;
pub const mobilesync_error_t_MOBILESYNC_E_BAD_VERSION: mobilesync_error_t = -6;
pub const mobilesync_error_t_MOBILESYNC_E_SYNC_REFUSED: mobilesync_error_t = -7;
pub const mobilesync_error_t_MOBILESYNC_E_CANCELLED: mobilesync_error_t = -8;
pub const mobilesync_error_t_MOBILESYNC_E_WRONG_DIRECTION: mobilesync_error_t = -9;
pub const mobilesync_error_t_MOBILESYNC_E_NOT_READY: mobilesync_error_t = -10;
pub const mobilesync_error_t_MOBILESYNC_E_UNKNOWN_ERROR: mobilesync_error_t = -256;
#[doc = " Error Codes"]
pub type mobilesync_error_t = ::std::os::raw::c_int;
#[doc = "< Fast-sync requires that only the changes made since the last synchronization should be reported by the computer."]
pub const mobilesync_sync_type_t_MOBILESYNC_SYNC_TYPE_FAST: mobilesync_sync_type_t = 0;
#[doc = "< Slow-sync requires that all data from the computer needs to be synchronized/sent."]
pub const mobilesync_sync_type_t_MOBILESYNC_SYNC_TYPE_SLOW: mobilesync_sync_type_t = 1;
#[doc = "< Reset-sync signals that the computer should send all data again."]
pub const mobilesync_sync_type_t_MOBILESYNC_SYNC_TYPE_RESET: mobilesync_sync_type_t = 2;
#[doc = " The sync type of the current sync session."]
pub type mobilesync_sync_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mobilesync_client_private {
    _unused: [u8; 0],
}
pub type mobilesync_client_t = *mut mobilesync_client_private;
#[doc = " Anchors used by the device and computer (structure)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mobilesync_anchors {
    #[doc = "< device anchor"]
    pub device_anchor: *mut ::std::os::raw::c_char,
    #[doc = "< computer anchor"]
    pub computer_anchor: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mobilesync_anchors() {
    assert_eq!(
        ::std::mem::size_of::<mobilesync_anchors>(),
        16usize,
        concat!("Size of: ", stringify!(mobilesync_anchors))
    );
    assert_eq!(
        ::std::mem::align_of::<mobilesync_anchors>(),
        8usize,
        concat!("Alignment of ", stringify!(mobilesync_anchors))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mobilesync_anchors>())).device_anchor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mobilesync_anchors),
            "::",
            stringify!(device_anchor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mobilesync_anchors>())).computer_anchor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mobilesync_anchors),
            "::",
            stringify!(computer_anchor)
        )
    );
}
#[doc = " Anchors used by the device and computer"]
pub type mobilesync_anchors_t = *mut mobilesync_anchors;
extern "C" {
    #[doc = " Connects to the mobilesync service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     #mobilesync_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one or more parameters are invalid"]
    #[doc = " @retval DEVICE_LINK_SERVICE_E_BAD_VERSION if the mobilesync version on"]
    #[doc = " the device is newer."]
    pub fn mobilesync_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut mobilesync_client_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Starts a new mobilesync service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     mobilesync_client_t upon successful return. Must be freed using"]
    #[doc = "     mobilesync_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return MOBILESYNC_E_SUCCESS on success, or an MOBILESYNC_E_* error"]
    #[doc = "     code otherwise."]
    pub fn mobilesync_client_start_service(
        device: idevice_t,
        client: *mut mobilesync_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Disconnects a mobilesync client from the device and frees up the"]
    #[doc = " mobilesync client data."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client to disconnect and free."]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if \\a client is NULL."]
    pub fn mobilesync_client_free(client: mobilesync_client_t) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Polls the device for mobilesync data."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param plist A pointer to the location where the plist should be stored"]
    #[doc = ""]
    #[doc = " @return an error code"]
    pub fn mobilesync_receive(
        client: mobilesync_client_t,
        plist: *mut plist_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Sends mobilesync data to the device"]
    #[doc = ""]
    #[doc = " @note This function is low-level and should only be used if you need to send"]
    #[doc = "        a new type of message."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param plist The location of the plist to send"]
    #[doc = ""]
    #[doc = " @return an error code"]
    pub fn mobilesync_send(client: mobilesync_client_t, plist: plist_t) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Requests starting synchronization of a data class with the device"]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param data_class The data class identifier to sync"]
    #[doc = " @param anchors The anchors required to exchange with the device. The anchors"]
    #[doc = "   allow the device to tell if the synchronization information on the computer"]
    #[doc = "   and device are consistent to determine what sync type is required."]
    #[doc = " @param computer_data_class_version The version of the data class storage on the computer"]
    #[doc = " @param sync_type A pointer to store the sync type reported by the device_anchor"]
    #[doc = " @param device_data_class_version The version of the data class storage on the device"]
    #[doc = " @param error_description A pointer to store an error message if reported by the device"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    #[doc = " @retval MOBILESYNC_E_PLIST_ERROR if the received plist is not of valid form"]
    #[doc = " @retval MOBILESYNC_E_SYNC_REFUSED if the device refused to sync"]
    #[doc = " @retval MOBILESYNC_E_CANCELLED if the device explicitly cancelled the"]
    #[doc = " sync request"]
    pub fn mobilesync_start(
        client: mobilesync_client_t,
        data_class: *const ::std::os::raw::c_char,
        anchors: mobilesync_anchors_t,
        computer_data_class_version: u64,
        sync_type: *mut mobilesync_sync_type_t,
        device_data_class_version: *mut u64,
        error_description: *mut *mut ::std::os::raw::c_char,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Cancels a running synchronization session with a device at any time."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param reason The reason to supply to the device for cancelling"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    pub fn mobilesync_cancel(
        client: mobilesync_client_t,
        reason: *const ::std::os::raw::c_char,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Finish a synchronization session of a data class on the device."]
    #[doc = " A session must have previously been started using mobilesync_start()."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    #[doc = " @retval MOBILESYNC_E_PLIST_ERROR if the received plist is not of valid"]
    #[doc = " form"]
    pub fn mobilesync_finish(client: mobilesync_client_t) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Requests to receive all records of the currently set data class from the device."]
    #[doc = " The actually changes are retrieved using mobilesync_receive_changes() after this"]
    #[doc = " request has been successful."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    pub fn mobilesync_get_all_records_from_device(
        client: mobilesync_client_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Requests to receive only changed records of the currently set data class from the device."]
    #[doc = " The actually changes are retrieved using mobilesync_receive_changes() after this"]
    #[doc = " request has been successful."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    pub fn mobilesync_get_changes_from_device(client: mobilesync_client_t) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Requests the device to delete all records of the current data class"]
    #[doc = ""]
    #[doc = " @note The operation must be called after starting synchronization."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    #[doc = " @retval MOBILESYNC_E_PLIST_ERROR if the received plist is not of valid form"]
    pub fn mobilesync_clear_all_records_on_device(
        client: mobilesync_client_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Receives changed entitites of the currently set data class from the device"]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param entities A pointer to store the changed entity records as a PLIST_DICT"]
    #[doc = " @param is_last_record A pointer to store a flag indicating if this submission is the last one"]
    #[doc = " @param actions A pointer to additional flags the device is sending or NULL to ignore"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    #[doc = " @retval MOBILESYNC_E_CANCELLED if the device explicitly cancelled the"]
    #[doc = " session"]
    pub fn mobilesync_receive_changes(
        client: mobilesync_client_t,
        entities: *mut plist_t,
        is_last_record: *mut u8,
        actions: *mut plist_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Acknowledges to the device that the changes have been merged on the computer"]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    pub fn mobilesync_acknowledge_changes_from_device(
        client: mobilesync_client_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Verifies if the device is ready to receive changes from the computer."]
    #[doc = " This call changes the synchronization direction so that mobilesync_send_changes()"]
    #[doc = " can be used to send changes to the device."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    #[doc = " @retval MOBILESYNC_E_PLIST_ERROR if the received plist is not of valid form"]
    #[doc = " @retval MOBILESYNC_E_WRONG_DIRECTION if the current sync direction does"]
    #[doc = " not permit this call"]
    #[doc = " @retval MOBILESYNC_E_CANCELLED if the device explicitly cancelled the"]
    #[doc = " session"]
    #[doc = " @retval MOBILESYNC_E_NOT_READY if the device is not ready to start"]
    #[doc = " receiving any changes"]
    pub fn mobilesync_ready_to_send_changes_from_computer(
        client: mobilesync_client_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Sends changed entities of the currently set data class to the device"]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param entities The changed entity records as a PLIST_DICT"]
    #[doc = " @param is_last_record A flag indicating if this submission is the last one"]
    #[doc = " @param actions Additional actions for the device created with mobilesync_actions_new()"]
    #[doc = "    or NULL if no actions should be passed"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid,"]
    #[doc = " @retval MOBILESYNC_E_WRONG_DIRECTION if the current sync direction does"]
    #[doc = " not permit this call"]
    pub fn mobilesync_send_changes(
        client: mobilesync_client_t,
        entities: plist_t,
        is_last_record: u8,
        actions: plist_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Receives any remapped identifiers reported after the device merged submitted changes."]
    #[doc = ""]
    #[doc = " @param client The mobilesync client"]
    #[doc = " @param mapping A pointer to an array plist containing a dict of identifier remappings"]
    #[doc = ""]
    #[doc = " @retval MOBILESYNC_E_SUCCESS on success"]
    #[doc = " @retval MOBILESYNC_E_INVALID_ARG if one of the parameters is invalid"]
    #[doc = " @retval MOBILESYNC_E_PLIST_ERROR if the received plist is not of valid"]
    #[doc = " form"]
    #[doc = " @retval MOBILESYNC_E_WRONG_DIRECTION if the current sync direction does"]
    #[doc = " not permit this call"]
    #[doc = " @retval MOBILESYNC_E_CANCELLED if the device explicitly cancelled the"]
    #[doc = " session"]
    pub fn mobilesync_remap_identifiers(
        client: mobilesync_client_t,
        mapping: *mut plist_t,
    ) -> mobilesync_error_t;
}
extern "C" {
    #[doc = " Allocates memory for a new anchors struct initialized with the passed anchors."]
    #[doc = ""]
    #[doc = " @param device_anchor An anchor the device reported the last time or NULL"]
    #[doc = "   if none is known yet which for instance is true on first synchronization."]
    #[doc = " @param computer_anchor An arbitrary string to use as anchor for the computer."]
    #[doc = ""]
    #[doc = " @return A new #mobilesync_anchors_t struct. Must be freed using mobilesync_anchors_free()."]
    pub fn mobilesync_anchors_new(
        device_anchor: *const ::std::os::raw::c_char,
        computer_anchor: *const ::std::os::raw::c_char,
    ) -> mobilesync_anchors_t;
}
extern "C" {
    #[doc = " Free memory used by anchors."]
    #[doc = ""]
    #[doc = " @param anchors The anchors to free."]
    pub fn mobilesync_anchors_free(anchors: mobilesync_anchors_t);
}
extern "C" {
    #[doc = " Create a new actions plist to use in mobilesync_send_changes()."]
    #[doc = ""]
    #[doc = " @return A new plist_t of type PLIST_DICT."]
    pub fn mobilesync_actions_new() -> plist_t;
}
extern "C" {
    #[doc = " Add one or more new key:value pairs to the given actions plist."]
    #[doc = ""]
    #[doc = " @param actions The actions to modify."]
    #[doc = " @param ... KEY, VALUE, [KEY, VALUE], NULL"]
    #[doc = ""]
    #[doc = " @note The known keys so far are \"SyncDeviceLinkEntityNamesKey\" which expects"]
    #[doc = "       an array of entity names, followed by a count paramter as well as"]
    #[doc = "       \"SyncDeviceLinkAllRecordsOfPulledEntityTypeSentKey\" which expects an"]
    #[doc = "       integer to use as a boolean value indicating that the device should"]
    #[doc = "       link submitted changes and report remapped identifiers."]
    pub fn mobilesync_actions_add(actions: plist_t, ...);
}
extern "C" {
    #[doc = " Free actions plist."]
    #[doc = ""]
    #[doc = " @param actions The actions plist to free. Does nothing if NULL is passed."]
    pub fn mobilesync_actions_free(actions: plist_t);
}
pub const np_error_t_NP_E_SUCCESS: np_error_t = 0;
pub const np_error_t_NP_E_INVALID_ARG: np_error_t = -1;
pub const np_error_t_NP_E_PLIST_ERROR: np_error_t = -2;
pub const np_error_t_NP_E_CONN_FAILED: np_error_t = -3;
pub const np_error_t_NP_E_UNKNOWN_ERROR: np_error_t = -256;
#[doc = " Error Codes"]
pub type np_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct np_client_private {
    _unused: [u8; 0],
}
pub type np_client_t = *mut np_client_private;
#[doc = " Callback function that reports which notification was received."]
pub type np_notify_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        notification: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Connects to the notification_proxy on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated np_client_t"]
    #[doc = "    upon successful return."]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS on success, NP_E_INVALID_ARG when device is NULL,"]
    #[doc = "   or NP_E_CONN_FAILED when the connection to the device could not be"]
    #[doc = "   established."]
    pub fn np_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut np_client_t,
    ) -> np_error_t;
}
extern "C" {
    #[doc = " Starts a new notification proxy service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     np_client_t upon successful return. Must be freed using"]
    #[doc = "     np_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS on success, or an NP_E_* error"]
    #[doc = "     code otherwise."]
    pub fn np_client_start_service(
        device: idevice_t,
        client: *mut np_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> np_error_t;
}
extern "C" {
    #[doc = " Disconnects a notification_proxy client from the device and frees up the"]
    #[doc = " notification_proxy client data."]
    #[doc = ""]
    #[doc = " @param client The notification_proxy client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS on success, or NP_E_INVALID_ARG when client is NULL."]
    pub fn np_client_free(client: np_client_t) -> np_error_t;
}
extern "C" {
    #[doc = " Sends a notification to the device's notification_proxy."]
    #[doc = ""]
    #[doc = " @param client The client to send to"]
    #[doc = " @param notification The notification message to send"]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS on success, or an error returned by np_plist_send"]
    pub fn np_post_notification(
        client: np_client_t,
        notification: *const ::std::os::raw::c_char,
    ) -> np_error_t;
}
extern "C" {
    #[doc = " Tells the device to send a notification on the specified event."]
    #[doc = ""]
    #[doc = " @param client The client to send to"]
    #[doc = " @param notification The notifications that should be observed."]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS on success, NP_E_INVALID_ARG when client or"]
    #[doc = "    notification are NULL, or an error returned by np_plist_send."]
    pub fn np_observe_notification(
        client: np_client_t,
        notification: *const ::std::os::raw::c_char,
    ) -> np_error_t;
}
extern "C" {
    #[doc = " Tells the device to send a notification on specified events."]
    #[doc = ""]
    #[doc = " @param client The client to send to"]
    #[doc = " @param notification_spec Specification of the notifications that should be"]
    #[doc = "  observed. This is expected to be an array of const char* that MUST have a"]
    #[doc = "  terminating NULL entry."]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS on success, NP_E_INVALID_ARG when client is null,"]
    #[doc = "   or an error returned by np_observe_notification."]
    pub fn np_observe_notifications(
        client: np_client_t,
        notification_spec: *mut *const ::std::os::raw::c_char,
    ) -> np_error_t;
}
extern "C" {
    #[doc = " This function allows an application to define a callback function that will"]
    #[doc = " be called when a notification has been received."]
    #[doc = " It will start a thread that polls for notifications and calls the callback"]
    #[doc = " function if a notification has been received."]
    #[doc = " In case of an error condition when polling for notifications - e.g. device"]
    #[doc = " disconnect - the thread will call the callback function with an empty"]
    #[doc = " notification \"\" and terminate itself."]
    #[doc = ""]
    #[doc = " @param client the NP client"]
    #[doc = " @param notify_cb pointer to a callback function or NULL to de-register a"]
    #[doc = "        previously set callback function."]
    #[doc = " @param user_data Pointer that will be passed to the callback function as"]
    #[doc = "        user data. If notify_cb is NULL, this parameter is ignored."]
    #[doc = ""]
    #[doc = " @note Only one callback function can be registered at the same time;"]
    #[doc = "       any previously set callback function will be removed automatically."]
    #[doc = ""]
    #[doc = " @return NP_E_SUCCESS when the callback was successfully registered,"]
    #[doc = "         NP_E_INVALID_ARG when client is NULL, or NP_E_UNKNOWN_ERROR when"]
    #[doc = "         the callback thread could no be created."]
    pub fn np_set_notify_callback(
        client: np_client_t,
        notify_cb: np_notify_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> np_error_t;
}
pub const preboard_error_t_PREBOARD_E_SUCCESS: preboard_error_t = 0;
pub const preboard_error_t_PREBOARD_E_INVALID_ARG: preboard_error_t = -1;
pub const preboard_error_t_PREBOARD_E_PLIST_ERROR: preboard_error_t = -2;
pub const preboard_error_t_PREBOARD_E_MUX_ERROR: preboard_error_t = -3;
pub const preboard_error_t_PREBOARD_E_SSL_ERROR: preboard_error_t = -4;
pub const preboard_error_t_PREBOARD_E_NOT_ENOUGH_DATA: preboard_error_t = -5;
pub const preboard_error_t_PREBOARD_E_TIMEOUT: preboard_error_t = -6;
pub const preboard_error_t_PREBOARD_E_OP_IN_PROGRESS: preboard_error_t = -10;
pub const preboard_error_t_PREBOARD_E_UNKNOWN_ERROR: preboard_error_t = -256;
#[doc = " Error Codes"]
pub type preboard_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct preboard_client_private {
    _unused: [u8; 0],
}
pub type preboard_client_t = *mut preboard_client_private;
#[doc = " Reports the status response of the given command"]
pub type preboard_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(message: plist_t, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Connects to the preboard service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     preboard_client_t upon successful return. Must be freed using"]
    #[doc = "     preboard_client_free() after use."]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS on success, PREBOARD_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an PREBOARD_E_* error code otherwise."]
    pub fn preboard_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut preboard_client_t,
    ) -> preboard_error_t;
}
extern "C" {
    #[doc = " Starts a new preboard service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     preboard_client_t upon successful return. Must be freed using"]
    #[doc = "     preboard_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS on success, or a PREBOARD_E_* error"]
    #[doc = "     code otherwise."]
    pub fn preboard_client_start_service(
        device: idevice_t,
        client: *mut preboard_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> preboard_error_t;
}
extern "C" {
    #[doc = " Disconnects a preboard client from the device and frees up the"]
    #[doc = " preboard client data."]
    #[doc = ""]
    #[doc = " @param client The preboard client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS on success, PREBOARD_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or a PREBOARD_E_* error code otherwise."]
    pub fn preboard_client_free(client: preboard_client_t) -> preboard_error_t;
}
extern "C" {
    #[doc = " Sends a plist to the service."]
    #[doc = ""]
    #[doc = " @param client The preboard client"]
    #[doc = " @param plist The plist to send"]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS on success,"]
    #[doc = "  PREBOARD_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "  or a PREBOARD_E_* error code on error"]
    pub fn preboard_send(client: preboard_client_t, plist: plist_t) -> preboard_error_t;
}
extern "C" {
    #[doc = " Receives a plist from the service."]
    #[doc = ""]
    #[doc = " @param client The preboard client"]
    #[doc = " @param plist Pointer to a plist_t what will be set to the received plist"]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS on success,"]
    #[doc = "  PREBOARD_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "  PREBOARD_E_TIMEOUT when no data was received after 5 seconds,"]
    #[doc = "  or a PREBOARD_E_* error code on error"]
    pub fn preboard_receive(client: preboard_client_t, plist: *mut plist_t) -> preboard_error_t;
}
extern "C" {
    #[doc = " Receives a plist from the service with the specified timeout."]
    #[doc = ""]
    #[doc = " @param client The preboard client"]
    #[doc = " @param plist Pointer to a plist_t what will be set to the received plist"]
    #[doc = " @param timeout_ms Timeout in milliseconds"]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS on success,"]
    #[doc = "  PREBOARD_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "  PREBOARD_E_TIMEOUT when no data was received after the given timeout,"]
    #[doc = "  or a PREBOARD_E_* error code on error."]
    pub fn preboard_receive_with_timeout(
        client: preboard_client_t,
        plist: *mut plist_t,
        timeout_ms: u32,
    ) -> preboard_error_t;
}
extern "C" {
    #[doc = " Tells the preboard service to create a stashbag. This will make the device"]
    #[doc = " show a passcode entry so it can generate and store a token that is later"]
    #[doc = " used during restore."]
    #[doc = ""]
    #[doc = " @param client The preboard client"]
    #[doc = " @param manifest An optional manifest"]
    #[doc = " @param status_cb Callback function that will receive status and error messages."]
    #[doc = "   Can be NULL if you want to handle receiving messages in your own code."]
    #[doc = " @param user_data User data for callback function or NULL."]
    #[doc = ""]
    #[doc = " The callback or following preboard_receive* invocations will usually"]
    #[doc = " receive a dictionary with:"]
    #[doc = "     { ShowDialog: true }"]
    #[doc = " If the user does not enter a passcode, after 2 minutes a timeout is reached"]
    #[doc = " and the device sends a dictionary with:"]
    #[doc = "     { Timeout: true }"]
    #[doc = "     followed by { HideDialog: true }"]
    #[doc = " If the user aborts the passcode entry, the device sends a dictionary:"]
    #[doc = "     { Error: 1, ErrorString: \\<error string\\> }"]
    #[doc = "     followed by { HideDialog: true }"]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS if the command was successfully submitted,"]
    #[doc = "  PREBOARD_E_INVALID_ARG when client is invalid,"]
    #[doc = "  or a PREBOARD_E_* error code on error."]
    pub fn preboard_create_stashbag(
        client: preboard_client_t,
        manifest: plist_t,
        status_cb: preboard_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> preboard_error_t;
}
extern "C" {
    #[doc = " Instructs the preboard service to commit a previously created stashbag."]
    #[doc = ""]
    #[doc = " @param client The preboard client to use for receiving"]
    #[doc = " @param manifest An optional manifest"]
    #[doc = " @param status_cb Callback function that will receive status and error messages"]
    #[doc = "   Can be NULL if you want to handle receiving messages in your own code."]
    #[doc = " @param user_data User data for callback function or NULL."]
    #[doc = ""]
    #[doc = " The callback or following preboard_receive* invocations will usually"]
    #[doc = " receive a dictionary with:"]
    #[doc = "     { StashbagCommitComplete: true }"]
    #[doc = " or in case of an error:"]
    #[doc = "     { StashbagCommitComplete: 0, Error: 1, \\<optional\\> ErrorString: \\<error string\\> }"]
    #[doc = ""]
    #[doc = " @return PREBOARD_E_SUCCESS if the command was successfully submitted,"]
    #[doc = "  PREBOARD_E_INVALID_ARG when client is invalid,"]
    #[doc = "  or a PREBOARD_E_* error code on error."]
    pub fn preboard_commit_stashbag(
        client: preboard_client_t,
        manifest: plist_t,
        status_cb: preboard_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> preboard_error_t;
}
pub const service_error_t_SERVICE_E_SUCCESS: service_error_t = 0;
pub const service_error_t_SERVICE_E_INVALID_ARG: service_error_t = -1;
pub const service_error_t_SERVICE_E_MUX_ERROR: service_error_t = -3;
pub const service_error_t_SERVICE_E_SSL_ERROR: service_error_t = -4;
pub const service_error_t_SERVICE_E_START_SERVICE_ERROR: service_error_t = -5;
pub const service_error_t_SERVICE_E_NOT_ENOUGH_DATA: service_error_t = -6;
pub const service_error_t_SERVICE_E_TIMEOUT: service_error_t = -7;
pub const service_error_t_SERVICE_E_UNKNOWN_ERROR: service_error_t = -256;
pub type service_error_t = ::std::os::raw::c_int;
pub type service_client_t = *mut service_client_private;
extern "C" {
    pub fn service_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut service_client_t,
    ) -> service_error_t;
}
extern "C" {
    pub fn service_client_factory_start_service(
        device: idevice_t,
        service_name: *const ::std::os::raw::c_char,
        client: *mut *mut ::std::os::raw::c_void,
        label: *const ::std::os::raw::c_char,
        constructor_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: idevice_t,
                arg2: lockdownd_service_descriptor_t,
                arg3: *mut *mut ::std::os::raw::c_void,
            ) -> i32,
        >,
        error_code: *mut i32,
    ) -> service_error_t;
}
extern "C" {
    pub fn service_client_free(client: service_client_t) -> service_error_t;
}
extern "C" {
    pub fn service_send(
        client: service_client_t,
        data: *const ::std::os::raw::c_char,
        size: u32,
        sent: *mut u32,
    ) -> service_error_t;
}
extern "C" {
    pub fn service_receive_with_timeout(
        client: service_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> service_error_t;
}
extern "C" {
    pub fn service_receive(
        client: service_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
    ) -> service_error_t;
}
extern "C" {
    pub fn service_enable_ssl(client: service_client_t) -> service_error_t;
}
extern "C" {
    pub fn service_disable_ssl(client: service_client_t) -> service_error_t;
}
extern "C" {
    pub fn service_disable_bypass_ssl(client: service_client_t, sslBypass: u8) -> service_error_t;
}
extern "C" {
    pub fn service_get_connection(
        client: service_client_t,
        connection: *mut idevice_connection_t,
    ) -> service_error_t;
}
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_SUCCESS:
    property_list_service_error_t = 0;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_INVALID_ARG:
    property_list_service_error_t = -1;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_PLIST_ERROR:
    property_list_service_error_t = -2;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_MUX_ERROR:
    property_list_service_error_t = -3;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_SSL_ERROR:
    property_list_service_error_t = -4;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_RECEIVE_TIMEOUT:
    property_list_service_error_t = -5;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_NOT_ENOUGH_DATA:
    property_list_service_error_t = -6;
pub const property_list_service_error_t_PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR:
    property_list_service_error_t = -256;
#[doc = " Error Codes"]
pub type property_list_service_error_t = ::std::os::raw::c_int;
pub type property_list_service_private = property_list_service_client_private;
pub type property_list_service_client_t = *mut property_list_service_private;
extern "C" {
    #[doc = " Creates a new property list service for the specified port."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     property_list_service_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG when one of the arguments is invalid,"]
    #[doc = "     or PROPERTY_LIST_SERVICE_E_MUX_ERROR when connecting to the device failed."]
    pub fn property_list_service_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Frees a PropertyList service."]
    #[doc = ""]
    #[doc = " @param client The property list service to free."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG when client is invalid, or a"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when another error occurred."]
    pub fn property_list_service_client_free(
        client: property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Sends an XML plist."]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for sending."]
    #[doc = " @param plist plist to send"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when dict is not a valid plist,"]
    #[doc = "      or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when an unspecified error occurs."]
    pub fn property_list_service_send_xml_plist(
        client: property_list_service_client_t,
        plist: plist_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Sends a binary plist."]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for sending."]
    #[doc = " @param plist plist to send"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when client or plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when dict is not a valid plist,"]
    #[doc = "      or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when an unspecified error occurs."]
    pub fn property_list_service_send_binary_plist(
        client: property_list_service_client_t,
        plist: plist_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Receives a plist using the given property list service client with specified"]
    #[doc = " timeout."]
    #[doc = " Binary or XML plists are automatically handled."]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for receiving"]
    #[doc = " @param plist pointer to a plist_t that will point to the received plist"]
    #[doc = "              upon successful return"]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when connection or *plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when the received data cannot be"]
    #[doc = "      converted to a plist, PROPERTY_LIST_SERVICE_E_MUX_ERROR when a"]
    #[doc = "      communication error occurs, or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when"]
    #[doc = "      an unspecified error occurs."]
    pub fn property_list_service_receive_plist_with_timeout(
        client: property_list_service_client_t,
        plist: *mut plist_t,
        timeout: ::std::os::raw::c_uint,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Receives a plist using the given property list service client."]
    #[doc = " Binary or XML plists are automatically handled."]
    #[doc = ""]
    #[doc = " This function is like property_list_service_receive_plist_with_timeout"]
    #[doc = "   using a timeout of 10 seconds."]
    #[doc = " @see property_list_service_receive_plist_with_timeout"]
    #[doc = ""]
    #[doc = " @param client The property list service client to use for receiving"]
    #[doc = " @param plist pointer to a plist_t that will point to the received plist"]
    #[doc = "      upon successful return"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_INVALID_ARG when client or *plist is NULL,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_NOT_ENOUGH_DATA when not enough data"]
    #[doc = "      received, PROPERTY_LIST_SERVICE_E_RECEIVE_TIMEOUT when the connection times out,"]
    #[doc = "      PROPERTY_LIST_SERVICE_E_PLIST_ERROR when the received data cannot be"]
    #[doc = "      converted to a plist, PROPERTY_LIST_SERVICE_E_MUX_ERROR when a"]
    #[doc = "      communication error occurs, or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR when"]
    #[doc = "      an unspecified error occurs."]
    pub fn property_list_service_receive_plist(
        client: property_list_service_client_t,
        plist: *mut plist_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Enable SSL for the given property list service client."]
    #[doc = ""]
    #[doc = " @param client The connected property list service client for which SSL"]
    #[doc = "     should be enabled."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG if one or more of the arguments are invalid,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_SSL_ERROR when SSL could not be enabled,"]
    #[doc = "     or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn property_list_service_enable_ssl(
        client: property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Disable SSL for the given property list service client."]
    #[doc = ""]
    #[doc = " @param client The connected property list service client for which SSL"]
    #[doc = "     should be disabled."]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG if one or more of the arguments are invalid,"]
    #[doc = "     or PROPERTY_LIST_SERVICE_E_UNKNOWN_ERROR otherwise."]
    pub fn property_list_service_disable_ssl(
        client: property_list_service_client_t,
    ) -> property_list_service_error_t;
}
extern "C" {
    #[doc = " Return a handle to the parent #service_client_t of the given property list service client."]
    #[doc = ""]
    #[doc = " @param client The property list service client"]
    #[doc = " @param service_client Pointer to be assigned to the parent #service_client_t"]
    #[doc = ""]
    #[doc = " @return PROPERTY_LIST_SERVICE_E_SUCCESS on success,"]
    #[doc = "     PROPERTY_LIST_SERVICE_E_INVALID_ARG if one or more of the arguments are invalid."]
    pub fn property_list_service_get_service_client(
        client: property_list_service_client_t,
        service_client: *mut service_client_t,
    ) -> property_list_service_error_t;
}
pub const restored_error_t_RESTORE_E_SUCCESS: restored_error_t = 0;
pub const restored_error_t_RESTORE_E_INVALID_ARG: restored_error_t = -1;
pub const restored_error_t_RESTORE_E_PLIST_ERROR: restored_error_t = -2;
pub const restored_error_t_RESTORE_E_MUX_ERROR: restored_error_t = -3;
pub const restored_error_t_RESTORE_E_NOT_ENOUGH_DATA: restored_error_t = -4;
pub const restored_error_t_RESTORE_E_RECEIVE_TIMEOUT: restored_error_t = -5;
pub const restored_error_t_RESTORE_E_UNKNOWN_ERROR: restored_error_t = -256;
#[doc = " Error Codes"]
pub type restored_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restored_client_private {
    _unused: [u8; 0],
}
pub type restored_client_t = *mut restored_client_private;
extern "C" {
    #[doc = " Creates a new restored client for the device."]
    #[doc = ""]
    #[doc = " @param device The device to create a restored client for"]
    #[doc = " @param client The pointer to the location of the new restored_client"]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client is NULL"]
    pub fn restored_client_new(
        device: idevice_t,
        client: *mut restored_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> restored_error_t;
}
extern "C" {
    #[doc = " Closes the restored client session if one is running and frees up the"]
    #[doc = " restored_client struct."]
    #[doc = ""]
    #[doc = " @param client The restore client"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client is NULL"]
    pub fn restored_client_free(client: restored_client_t) -> restored_error_t;
}
extern "C" {
    #[doc = " Query the type of the service daemon. Depending on whether the device is"]
    #[doc = " queried in normal mode or restore mode, different types will be returned."]
    #[doc = ""]
    #[doc = " @param client The restored client"]
    #[doc = " @param type The type returned by the service daemon. Pass NULL to ignore."]
    #[doc = " @param version The restore protocol version. Pass NULL to ignore."]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client is NULL"]
    pub fn restored_query_type(
        client: restored_client_t,
        type_: *mut *mut ::std::os::raw::c_char,
        version: *mut u64,
    ) -> restored_error_t;
}
extern "C" {
    #[doc = " Queries a value from the device specified by a key."]
    #[doc = ""]
    #[doc = " @param client An initialized restored client."]
    #[doc = " @param key The key name to request"]
    #[doc = " @param value A plist node representing the result value node"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client is NULL, RESTORE_E_PLIST_ERROR if value for key can't be found"]
    pub fn restored_query_value(
        client: restored_client_t,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> restored_error_t;
}
extern "C" {
    #[doc = " Retrieves a value from information plist specified by a key."]
    #[doc = ""]
    #[doc = " @param client An initialized restored client."]
    #[doc = " @param key The key name to request or NULL to query for all keys"]
    #[doc = " @param value A plist node representing the result value node"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client is NULL, RESTORE_E_PLIST_ERROR if value for key can't be found"]
    pub fn restored_get_value(
        client: restored_client_t,
        key: *const ::std::os::raw::c_char,
        value: *mut plist_t,
    ) -> restored_error_t;
}
extern "C" {
    #[doc = " Sends a plist to restored."]
    #[doc = ""]
    #[doc = " @note This function is low-level and should only be used if you need to send"]
    #[doc = "        a new type of message."]
    #[doc = ""]
    #[doc = " @param client The restored client"]
    #[doc = " @param plist The plist to send"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client or"]
    #[doc = "  plist is NULL"]
    pub fn restored_send(client: restored_client_t, plist: plist_t) -> restored_error_t;
}
extern "C" {
    #[doc = " Receives a plist from restored."]
    #[doc = ""]
    #[doc = " @param client The restored client"]
    #[doc = " @param plist The plist to store the received data"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client or"]
    #[doc = "  plist is NULL"]
    pub fn restored_receive(client: restored_client_t, plist: *mut plist_t) -> restored_error_t;
}
extern "C" {
    #[doc = " Sends the Goodbye request to restored signaling the end of communication."]
    #[doc = ""]
    #[doc = " @param client The restore client"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG when client is NULL,"]
    #[doc = "  RESTORE_E_PLIST_ERROR if the device did not acknowledge the request"]
    pub fn restored_goodbye(client: restored_client_t) -> restored_error_t;
}
extern "C" {
    #[doc = " Requests to start a restore and retrieve it's port on success."]
    #[doc = ""]
    #[doc = " @param client The restored client"]
    #[doc = " @param options PLIST_DICT with options for the restore process or NULL"]
    #[doc = " @param version the restore protocol version, see restored_query_type()"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG if a parameter"]
    #[doc = "  is NULL, RESTORE_E_START_RESTORE_FAILED if the request fails"]
    pub fn restored_start_restore(
        client: restored_client_t,
        options: plist_t,
        version: u64,
    ) -> restored_error_t;
}
extern "C" {
    #[doc = " Requests device to reboot."]
    #[doc = ""]
    #[doc = " @param client The restored client"]
    #[doc = ""]
    #[doc = " @return RESTORE_E_SUCCESS on success, RESTORE_E_INVALID_ARG if a parameter"]
    #[doc = "  is NULL"]
    pub fn restored_reboot(client: restored_client_t) -> restored_error_t;
}
extern "C" {
    #[doc = " Sets the label to send for requests to restored."]
    #[doc = ""]
    #[doc = " @param client The restore client"]
    #[doc = " @param label The label to set or NULL to disable sending a label"]
    #[doc = ""]
    pub fn restored_client_set_label(
        client: restored_client_t,
        label: *const ::std::os::raw::c_char,
    );
}
pub const reverse_proxy_error_t_REVERSE_PROXY_E_SUCCESS: reverse_proxy_error_t = 0;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_INVALID_ARG: reverse_proxy_error_t = -1;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_PLIST_ERROR: reverse_proxy_error_t = -2;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_MUX_ERROR: reverse_proxy_error_t = -3;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_SSL_ERROR: reverse_proxy_error_t = -4;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_NOT_ENOUGH_DATA: reverse_proxy_error_t = -5;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_TIMEOUT: reverse_proxy_error_t = -6;
pub const reverse_proxy_error_t_REVERSE_PROXY_E_UNKNOWN_ERROR: reverse_proxy_error_t = -256;
#[doc = " Error Codes"]
pub type reverse_proxy_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reverse_proxy_client_private {
    _unused: [u8; 0],
}
pub type reverse_proxy_client_t = *mut reverse_proxy_client_private;
#[doc = "< control connection"]
pub const reverse_proxy_client_type_t_RP_TYPE_CTRL: reverse_proxy_client_type_t = 1;
#[doc = "< proxy connection"]
pub const reverse_proxy_client_type_t_RP_TYPE_CONN: reverse_proxy_client_type_t = 2;
#[doc = " reverse proxy client type"]
pub type reverse_proxy_client_type_t = ::std::os::raw::c_uint;
#[doc = "< proxy is ready"]
pub const reverse_proxy_status_t_RP_STATUS_READY: reverse_proxy_status_t = 1;
#[doc = "< proxy terminated"]
pub const reverse_proxy_status_t_RP_STATUS_TERMINATE: reverse_proxy_status_t = 2;
#[doc = "< connection request received (only RP_TYPE_CTRL)"]
pub const reverse_proxy_status_t_RP_STATUS_CONNECT_REQ: reverse_proxy_status_t = 3;
#[doc = "< shutdown request received (only RP_TYPE_CTRL)"]
pub const reverse_proxy_status_t_RP_STATUS_SHUTDOWN_REQ: reverse_proxy_status_t = 4;
#[doc = "< connection established (only RP_TYPE_CONN)"]
pub const reverse_proxy_status_t_RP_STATUS_CONNECTED: reverse_proxy_status_t = 5;
#[doc = "< connection closed (only RP_TYPE_CONN)"]
pub const reverse_proxy_status_t_RP_STATUS_DISCONNECTED: reverse_proxy_status_t = 6;
#[doc = " reverse proxy status for reverse_proxy_status_cb_t callback"]
pub type reverse_proxy_status_t = ::std::os::raw::c_uint;
#[doc = "< data going out to remote host"]
pub const reverse_proxy_data_direction_t_RP_DATA_DIRECTION_OUT: reverse_proxy_data_direction_t = 1;
#[doc = "< data coming in from remote host"]
pub const reverse_proxy_data_direction_t_RP_DATA_DIRECTION_IN: reverse_proxy_data_direction_t = 2;
#[doc = " reverse proxy data direction passed to reverse_proxy_data_cb_t callback"]
pub type reverse_proxy_data_direction_t = ::std::os::raw::c_uint;
#[doc = " Log callback function prototype."]
#[doc = ""]
#[doc = " @param client The client that called the callback function"]
#[doc = " @param log_msg The log message"]
#[doc = " @param user_data The user_data pointer that was set when registering the callback"]
pub type reverse_proxy_log_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: reverse_proxy_client_t,
        log_msg: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Data callback function prototype."]
#[doc = ""]
#[doc = " @param client The client that called the callback function"]
#[doc = " @param direction The direction of the data, either RP_DATA_DIRECTION_OUT or RP_DATA_DIRECTION_IN"]
#[doc = " @param buffer The data buffer"]
#[doc = " @param length The length of the data buffer"]
#[doc = " @param user_data The user_data pointer that was set when registering the callback"]
pub type reverse_proxy_data_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: reverse_proxy_client_t,
        direction: reverse_proxy_data_direction_t,
        buffer: *const ::std::os::raw::c_char,
        length: u32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Status callback function prototype."]
#[doc = ""]
#[doc = " @param client The client that called the callback function"]
#[doc = " @param status The status the client is reporting"]
#[doc = " @param status_msg A status message the client reports along with the status"]
#[doc = " @param user_data The user_data pointer that was set when registering the callback"]
pub type reverse_proxy_status_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: reverse_proxy_client_t,
        status: reverse_proxy_status_t,
        status_msg: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Create a reverse proxy client using com.apple.PurpleReverseProxy.Ctrl and"]
    #[doc = " com.apple.PurpleReverseProxy.Conn lockdown services. This will open a port"]
    #[doc = " 1083 on the device that iOS apps could connect to; \\b however that is"]
    #[doc = " only allowed if an app has the com.apple.private.PurpleReverseProxy.allowed"]
    #[doc = " entitlement, which currently only \\c /usr/libexec/fdrhelper holds."]
    #[doc = ""]
    #[doc = " @note This function only creates and initializes the reverse proxy;"]
    #[doc = "    to make it operational, call reverse_proxy_client_start_proxy()."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will be set to a newly allocated #reverse_proxy_client_t"]
    #[doc = "    upon successful return."]
    #[doc = " @param label A label to pass to lockdownd when creating the service"]
    #[doc = "    connections, usually the program name."]
    #[doc = ""]
    #[doc = " @return REVERSE_PROXY_E_SUCCESS on success,"]
    #[doc = "    or a REVERSE_PROXY_E_* error code otherwise."]
    pub fn reverse_proxy_client_create_with_service(
        device: idevice_t,
        client: *mut reverse_proxy_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> reverse_proxy_error_t;
}
extern "C" {
    #[doc = " Create a reverse proxy client using an open port on the device. This is"]
    #[doc = " used during firmware restores with the default port REVERSE_PROXY_DEFAULT_PORT (1082)."]
    #[doc = ""]
    #[doc = " @note This function only creates and initializes the reverse proxy;"]
    #[doc = "    to make it operational, call reverse_proxy_client_start_proxy()."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will be set to a newly allocated reverse_proxy_client_t"]
    #[doc = "    upon successful return."]
    #[doc = " @param device_port An open port on the device. Unless it's being used for"]
    #[doc = "    a custom implementation, pass REVERSE_PROXY_DEFAULT_PORT here."]
    #[doc = ""]
    #[doc = " @return REVERSE_PROXY_E_SUCCESS on success,"]
    #[doc = "    or a REVERSE_PROXY_E_* error code otherwise."]
    pub fn reverse_proxy_client_create_with_port(
        device: idevice_t,
        client: *mut reverse_proxy_client_t,
        device_port: u16,
    ) -> reverse_proxy_error_t;
}
extern "C" {
    #[doc = " Disconnects a reverse proxy client and frees up the client data."]
    #[doc = ""]
    #[doc = " @param client The reverse proxy client to disconnect and free."]
    pub fn reverse_proxy_client_free(client: reverse_proxy_client_t) -> reverse_proxy_error_t;
}
extern "C" {
    #[doc = " Make an initialized reverse proxy client operational, i.e. start the actual proxy."]
    #[doc = ""]
    #[doc = " @param client The reverse proxy client to start."]
    #[doc = " @param control_protocol_version The control protocol version to use."]
    #[doc = "    This is either 1 or 2. Recent devices use 2."]
    #[doc = ""]
    #[doc = " @return REVERSE_PROXY_E_SUCCESS on success,"]
    #[doc = "    or a REVERSE_PROXY_E_* error code otherwise."]
    pub fn reverse_proxy_client_start_proxy(
        client: reverse_proxy_client_t,
        control_protocol_version: ::std::os::raw::c_int,
    ) -> reverse_proxy_error_t;
}
extern "C" {
    #[doc = " Set a status callback function. This allows to report the status of the"]
    #[doc = " reverse proxy, like Ready, Connect Request, Connected, etc."]
    #[doc = ""]
    #[doc = " @note Set the callback before calling reverse_proxy_client_start_proxy()."]
    #[doc = ""]
    #[doc = " @param client The reverse proxy client"]
    #[doc = " @param callback The status callback function that will be called"]
    #[doc = "    when the status of the reverse proxy changes."]
    #[doc = " @param user_data A pointer that will be passed to the callback function."]
    pub fn reverse_proxy_client_set_status_callback(
        client: reverse_proxy_client_t,
        callback: reverse_proxy_status_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Set a log callback function. Useful for debugging or verbosity."]
    #[doc = ""]
    #[doc = " @note Set the callback before calling reverse_proxy_client_start_proxy()."]
    #[doc = ""]
    #[doc = " @param client The reverse proxy client"]
    #[doc = " @param callback The log callback function that will be called"]
    #[doc = "    when the reverse proxy logs something."]
    #[doc = " @param user_data A pointer that will be passed to the callback function."]
    pub fn reverse_proxy_client_set_log_callback(
        client: reverse_proxy_client_t,
        callback: reverse_proxy_log_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Set a data callback function. Useful for debugging or extra verbosity."]
    #[doc = ""]
    #[doc = " @note Set the callback before calling reverse_proxy_client_start_proxy()."]
    #[doc = ""]
    #[doc = " @param client The reverse proxy client"]
    #[doc = " @param callback The status callback function that will be called"]
    #[doc = "    when the status of the reverse proxy changes."]
    #[doc = " @param user_data A pointer that will be passed to the callback function."]
    pub fn reverse_proxy_client_set_data_callback(
        client: reverse_proxy_client_t,
        callback: reverse_proxy_data_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Helper function to return the type of a given reverse proxy client, which"]
    #[doc = " is either RP_TYPE_CTRL or RP_TYPE_CONN. Useful for callback functions."]
    #[doc = " @see reverse_proxy_client_type_t"]
    #[doc = ""]
    #[doc = " @param client The reverse proxy client"]
    #[doc = ""]
    #[doc = " @return The type of the rerverse proxy client"]
    pub fn reverse_proxy_get_type(client: reverse_proxy_client_t) -> reverse_proxy_client_type_t;
}
pub const sbservices_error_t_SBSERVICES_E_SUCCESS: sbservices_error_t = 0;
pub const sbservices_error_t_SBSERVICES_E_INVALID_ARG: sbservices_error_t = -1;
pub const sbservices_error_t_SBSERVICES_E_PLIST_ERROR: sbservices_error_t = -2;
pub const sbservices_error_t_SBSERVICES_E_CONN_FAILED: sbservices_error_t = -3;
pub const sbservices_error_t_SBSERVICES_E_UNKNOWN_ERROR: sbservices_error_t = -256;
#[doc = " Error Codes"]
pub type sbservices_error_t = ::std::os::raw::c_int;
pub const sbservices_interface_orientation_t_SBSERVICES_INTERFACE_ORIENTATION_UNKNOWN:
    sbservices_interface_orientation_t = 0;
pub const sbservices_interface_orientation_t_SBSERVICES_INTERFACE_ORIENTATION_PORTRAIT:
    sbservices_interface_orientation_t = 1;
pub const sbservices_interface_orientation_t_SBSERVICES_INTERFACE_ORIENTATION_PORTRAIT_UPSIDE_DOWN : sbservices_interface_orientation_t = 2 ;
pub const sbservices_interface_orientation_t_SBSERVICES_INTERFACE_ORIENTATION_LANDSCAPE_RIGHT:
    sbservices_interface_orientation_t = 3;
pub const sbservices_interface_orientation_t_SBSERVICES_INTERFACE_ORIENTATION_LANDSCAPE_LEFT:
    sbservices_interface_orientation_t = 4;
#[doc = " Orientation of the user interface on the device"]
pub type sbservices_interface_orientation_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbservices_client_private {
    _unused: [u8; 0],
}
pub type sbservices_client_t = *mut sbservices_client_private;
extern "C" {
    #[doc = " Connects to the springboardservices service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     sbservices_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an SBSERVICES_E_* error code otherwise."]
    pub fn sbservices_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut sbservices_client_t,
    ) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Starts a new sbservices service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     sbservices_client_t upon successful return. Must be freed using"]
    #[doc = "     sbservices_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, or an SBSERVICES_E_* error"]
    #[doc = "     code otherwise."]
    pub fn sbservices_client_start_service(
        device: idevice_t,
        client: *mut sbservices_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Disconnects an sbservices client from the device and frees up the"]
    #[doc = " sbservices client data."]
    #[doc = ""]
    #[doc = " @param client The sbservices client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an SBSERVICES_E_* error code otherwise."]
    pub fn sbservices_client_free(client: sbservices_client_t) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Gets the icon state of the connected device."]
    #[doc = ""]
    #[doc = " @param client The connected sbservices client to use."]
    #[doc = " @param state Pointer that will point to a newly allocated plist containing"]
    #[doc = "     the current icon state. It is up to the caller to free the memory."]
    #[doc = " @param format_version A string to be passed as formatVersion along with"]
    #[doc = "     the request, or NULL if no formatVersion should be passed. This is only"]
    #[doc = "     supported since iOS 4.0 so for older firmware versions this must be set"]
    #[doc = "     to NULL."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client or state is invalid, or an SBSERVICES_E_* error code otherwise."]
    pub fn sbservices_get_icon_state(
        client: sbservices_client_t,
        state: *mut plist_t,
        format_version: *const ::std::os::raw::c_char,
    ) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Sets the icon state of the connected device."]
    #[doc = ""]
    #[doc = " @param client The connected sbservices client to use."]
    #[doc = " @param newstate A plist containing the new iconstate."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client or newstate is NULL, or an SBSERVICES_E_* error code otherwise."]
    pub fn sbservices_set_icon_state(
        client: sbservices_client_t,
        newstate: plist_t,
    ) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Get the icon of the specified app as PNG data."]
    #[doc = ""]
    #[doc = " @param client The connected sbservices client to use."]
    #[doc = " @param bundleId The bundle identifier of the app to retrieve the icon for."]
    #[doc = " @param pngdata Pointer that will point to a newly allocated buffer"]
    #[doc = "     containing the PNG data upon successful return. It is up to the caller"]
    #[doc = "     to free the memory."]
    #[doc = " @param pngsize Pointer to a uint64_t that will be set to the size of the"]
    #[doc = "     buffer pngdata points to upon successful return."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client, bundleId, or pngdata are invalid, or an SBSERVICES_E_* error"]
    #[doc = "     code otherwise."]
    pub fn sbservices_get_icon_pngdata(
        client: sbservices_client_t,
        bundleId: *const ::std::os::raw::c_char,
        pngdata: *mut *mut ::std::os::raw::c_char,
        pngsize: *mut u64,
    ) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Gets the interface orientation of the device."]
    #[doc = ""]
    #[doc = " @param client The connected sbservices client to use."]
    #[doc = " @param interface_orientation The interface orientation upon successful return."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client or state is invalid, or an SBSERVICES_E_* error code otherwise."]
    pub fn sbservices_get_interface_orientation(
        client: sbservices_client_t,
        interface_orientation: *mut sbservices_interface_orientation_t,
    ) -> sbservices_error_t;
}
extern "C" {
    #[doc = " Get the home screen wallpaper as PNG data."]
    #[doc = ""]
    #[doc = " @param client The connected sbservices client to use."]
    #[doc = " @param pngdata Pointer that will point to a newly allocated buffer"]
    #[doc = "     containing the PNG data upon successful return. It is up to the caller"]
    #[doc = "     to free the memory."]
    #[doc = " @param pngsize Pointer to a uint64_t that will be set to the size of the"]
    #[doc = "     buffer pngdata points to upon successful return."]
    #[doc = ""]
    #[doc = " @return SBSERVICES_E_SUCCESS on success, SBSERVICES_E_INVALID_ARG when"]
    #[doc = "     client or pngdata are invalid, or an SBSERVICES_E_* error"]
    #[doc = "     code otherwise."]
    pub fn sbservices_get_home_screen_wallpaper_pngdata(
        client: sbservices_client_t,
        pngdata: *mut *mut ::std::os::raw::c_char,
        pngsize: *mut u64,
    ) -> sbservices_error_t;
}
pub const screenshotr_error_t_SCREENSHOTR_E_SUCCESS: screenshotr_error_t = 0;
pub const screenshotr_error_t_SCREENSHOTR_E_INVALID_ARG: screenshotr_error_t = -1;
pub const screenshotr_error_t_SCREENSHOTR_E_PLIST_ERROR: screenshotr_error_t = -2;
pub const screenshotr_error_t_SCREENSHOTR_E_MUX_ERROR: screenshotr_error_t = -3;
pub const screenshotr_error_t_SCREENSHOTR_E_SSL_ERROR: screenshotr_error_t = -4;
pub const screenshotr_error_t_SCREENSHOTR_E_RECEIVE_TIMEOUT: screenshotr_error_t = -5;
pub const screenshotr_error_t_SCREENSHOTR_E_BAD_VERSION: screenshotr_error_t = -6;
pub const screenshotr_error_t_SCREENSHOTR_E_UNKNOWN_ERROR: screenshotr_error_t = -256;
#[doc = " Error Codes"]
pub type screenshotr_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct screenshotr_client_private {
    _unused: [u8; 0],
}
pub type screenshotr_client_t = *mut screenshotr_client_private;
extern "C" {
    #[doc = " Connects to the screenshotr service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will be set to a newly allocated"]
    #[doc = "     screenshotr_client_t upon successful return."]
    #[doc = ""]
    #[doc = " @note This service is only available if a developer disk image has been"]
    #[doc = "     mounted."]
    #[doc = ""]
    #[doc = " @return SCREENSHOTR_E_SUCCESS on success, SCREENSHOTR_E_INVALID ARG if one"]
    #[doc = "     or more parameters are invalid, or SCREENSHOTR_E_CONN_FAILED if the"]
    #[doc = "     connection to the device could not be established."]
    pub fn screenshotr_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut screenshotr_client_t,
    ) -> screenshotr_error_t;
}
extern "C" {
    #[doc = " Starts a new screenshotr service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     screenshotr_client_t upon successful return. Must be freed using"]
    #[doc = "     screenshotr_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return SCREENSHOTR_E_SUCCESS on success, or an SCREENSHOTR_E_* error"]
    #[doc = "     code otherwise."]
    pub fn screenshotr_client_start_service(
        device: idevice_t,
        client: *mut screenshotr_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> screenshotr_error_t;
}
extern "C" {
    #[doc = " Disconnects a screenshotr client from the device and frees up the"]
    #[doc = " screenshotr client data."]
    #[doc = ""]
    #[doc = " @param client The screenshotr client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return SCREENSHOTR_E_SUCCESS on success, or SCREENSHOTR_E_INVALID_ARG"]
    #[doc = "     if client is NULL."]
    pub fn screenshotr_client_free(client: screenshotr_client_t) -> screenshotr_error_t;
}
extern "C" {
    #[doc = " Get a screen shot from the connected device."]
    #[doc = ""]
    #[doc = " @param client The connection screenshotr service client."]
    #[doc = " @param imgdata Pointer that will point to a newly allocated buffer"]
    #[doc = "     containing TIFF image data upon successful return. It is up to the"]
    #[doc = "     caller to free the memory."]
    #[doc = " @param imgsize Pointer to a uint64_t that will be set to the size of the"]
    #[doc = "     buffer imgdata points to upon successful return."]
    #[doc = ""]
    #[doc = " @return SCREENSHOTR_E_SUCCESS on success, SCREENSHOTR_E_INVALID_ARG if"]
    #[doc = "     one or more parameters are invalid, or another error code if an"]
    #[doc = "     error occurred."]
    pub fn screenshotr_take_screenshot(
        client: screenshotr_client_t,
        imgdata: *mut *mut ::std::os::raw::c_char,
        imgsize: *mut u64,
    ) -> screenshotr_error_t;
}
pub const syslog_relay_error_t_SYSLOG_RELAY_E_SUCCESS: syslog_relay_error_t = 0;
pub const syslog_relay_error_t_SYSLOG_RELAY_E_INVALID_ARG: syslog_relay_error_t = -1;
pub const syslog_relay_error_t_SYSLOG_RELAY_E_MUX_ERROR: syslog_relay_error_t = -2;
pub const syslog_relay_error_t_SYSLOG_RELAY_E_SSL_ERROR: syslog_relay_error_t = -3;
pub const syslog_relay_error_t_SYSLOG_RELAY_E_NOT_ENOUGH_DATA: syslog_relay_error_t = -4;
pub const syslog_relay_error_t_SYSLOG_RELAY_E_TIMEOUT: syslog_relay_error_t = -5;
pub const syslog_relay_error_t_SYSLOG_RELAY_E_UNKNOWN_ERROR: syslog_relay_error_t = -256;
#[doc = " Error Codes"]
pub type syslog_relay_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syslog_relay_client_private {
    _unused: [u8; 0],
}
pub type syslog_relay_client_t = *mut syslog_relay_client_private;
#[doc = " Receives each character received from the device."]
pub type syslog_relay_receive_cb_t = ::std::option::Option<
    unsafe extern "C" fn(c: ::std::os::raw::c_char, user_data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Connects to the syslog_relay service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     syslog_relay_client_t upon successful return. Must be freed using"]
    #[doc = "     syslog_relay_client_free() after use."]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success, SYSLOG_RELAY_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an SYSLOG_RELAY_E_* error code otherwise."]
    pub fn syslog_relay_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut syslog_relay_client_t,
    ) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Starts a new syslog_relay service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     syslog_relay_client_t upon successful return. Must be freed using"]
    #[doc = "     syslog_relay_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success, or an SYSLOG_RELAY_E_* error"]
    #[doc = "     code otherwise."]
    pub fn syslog_relay_client_start_service(
        device: idevice_t,
        client: *mut syslog_relay_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Disconnects a syslog_relay client from the device and frees up the"]
    #[doc = " syslog_relay client data."]
    #[doc = ""]
    #[doc = " @param client The syslog_relay client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success, SYSLOG_RELAY_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an SYSLOG_RELAY_E_* error code otherwise."]
    pub fn syslog_relay_client_free(client: syslog_relay_client_t) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Starts capturing the syslog of the device using a callback."]
    #[doc = ""]
    #[doc = " Use syslog_relay_stop_capture() to stop receiving the syslog."]
    #[doc = ""]
    #[doc = " @param client The syslog_relay client to use"]
    #[doc = " @param callback Callback to receive each character from the syslog."]
    #[doc = " @param user_data Custom pointer passed to the callback function."]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success,"]
    #[doc = "      SYSLOG_RELAY_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid or SYSLOG_RELAY_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs or a syslog capture has already been started."]
    pub fn syslog_relay_start_capture(
        client: syslog_relay_client_t,
        callback: syslog_relay_receive_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Starts capturing the *raw* syslog of the device using a callback."]
    #[doc = " This function is like syslog_relay_start_capture with the difference that"]
    #[doc = " it will neither check nor process the received data before passing it to"]
    #[doc = " the callback function."]
    #[doc = ""]
    #[doc = " Use syslog_relay_stop_capture() to stop receiving the syslog."]
    #[doc = ""]
    #[doc = " @note Use syslog_relay_start_capture for a safer implementation."]
    #[doc = ""]
    #[doc = " @param client The syslog_relay client to use"]
    #[doc = " @param callback Callback to receive each character from the syslog."]
    #[doc = " @param user_data Custom pointer passed to the callback function."]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success,"]
    #[doc = "      SYSLOG_RELAY_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid or SYSLOG_RELAY_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs or a syslog capture has already been started."]
    pub fn syslog_relay_start_capture_raw(
        client: syslog_relay_client_t,
        callback: syslog_relay_receive_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Stops capturing the syslog of the device."]
    #[doc = ""]
    #[doc = " Use syslog_relay_start_capture() to start receiving the syslog."]
    #[doc = ""]
    #[doc = " @param client The syslog_relay client to use"]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success,"]
    #[doc = "      SYSLOG_RELAY_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid or SYSLOG_RELAY_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs or a syslog capture has already been started."]
    pub fn syslog_relay_stop_capture(client: syslog_relay_client_t) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Receives data using the given syslog_relay client with specified timeout."]
    #[doc = ""]
    #[doc = " @param client The syslog_relay client to use for receiving"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = " @param timeout Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success,"]
    #[doc = "      SYSLOG_RELAY_E_INVALID_ARG when one or more parameters are"]
    #[doc = "      invalid, SYSLOG_RELAY_E_MUX_ERROR when a communication error"]
    #[doc = "      occurs, or SYSLOG_RELAY_E_UNKNOWN_ERROR when an unspecified"]
    #[doc = "      error occurs."]
    pub fn syslog_relay_receive_with_timeout(
        client: syslog_relay_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
        timeout: ::std::os::raw::c_uint,
    ) -> syslog_relay_error_t;
}
extern "C" {
    #[doc = " Receives data from the service."]
    #[doc = ""]
    #[doc = " @param client The syslog_relay client"]
    #[doc = " @param data Buffer that will be filled with the data received"]
    #[doc = " @param size Number of bytes to receive"]
    #[doc = " @param received Number of bytes received (can be NULL to ignore)"]
    #[doc = ""]
    #[doc = " @return SYSLOG_RELAY_E_SUCCESS on success,"]
    #[doc = "  SYSLOG_RELAY_E_INVALID_ARG when client or plist is NULL"]
    pub fn syslog_relay_receive(
        client: syslog_relay_client_t,
        data: *mut ::std::os::raw::c_char,
        size: u32,
        received: *mut u32,
    ) -> syslog_relay_error_t;
}
pub const webinspector_error_t_WEBINSPECTOR_E_SUCCESS: webinspector_error_t = 0;
pub const webinspector_error_t_WEBINSPECTOR_E_INVALID_ARG: webinspector_error_t = -1;
pub const webinspector_error_t_WEBINSPECTOR_E_PLIST_ERROR: webinspector_error_t = -2;
pub const webinspector_error_t_WEBINSPECTOR_E_MUX_ERROR: webinspector_error_t = -3;
pub const webinspector_error_t_WEBINSPECTOR_E_SSL_ERROR: webinspector_error_t = -4;
pub const webinspector_error_t_WEBINSPECTOR_E_RECEIVE_TIMEOUT: webinspector_error_t = -5;
pub const webinspector_error_t_WEBINSPECTOR_E_NOT_ENOUGH_DATA: webinspector_error_t = -6;
pub const webinspector_error_t_WEBINSPECTOR_E_UNKNOWN_ERROR: webinspector_error_t = -256;
#[doc = " Error Codes"]
pub type webinspector_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct webinspector_client_private {
    _unused: [u8; 0],
}
pub type webinspector_client_t = *mut webinspector_client_private;
extern "C" {
    #[doc = " Connects to the webinspector service on the specified device."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param service The service descriptor returned by lockdownd_start_service."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     webinspector_client_t upon successful return. Must be freed using"]
    #[doc = "     webinspector_client_free() after use."]
    #[doc = ""]
    #[doc = " @return WEBINSPECTOR_E_SUCCESS on success, WEBINSPECTOR_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an WEBINSPECTOR_E_* error code otherwise."]
    pub fn webinspector_client_new(
        device: idevice_t,
        service: lockdownd_service_descriptor_t,
        client: *mut webinspector_client_t,
    ) -> webinspector_error_t;
}
extern "C" {
    #[doc = " Starts a new webinspector service on the specified device and connects to it."]
    #[doc = ""]
    #[doc = " @param device The device to connect to."]
    #[doc = " @param client Pointer that will point to a newly allocated"]
    #[doc = "     webinspector_client_t upon successful return. Must be freed using"]
    #[doc = "     webinspector_client_free() after use."]
    #[doc = " @param label The label to use for communication. Usually the program name."]
    #[doc = "  Pass NULL to disable sending the label in requests to lockdownd."]
    #[doc = ""]
    #[doc = " @return WEBINSPECTOR_E_SUCCESS on success, or an WEBINSPECTOR_E_* error"]
    #[doc = "     code otherwise."]
    pub fn webinspector_client_start_service(
        device: idevice_t,
        client: *mut webinspector_client_t,
        label: *const ::std::os::raw::c_char,
    ) -> webinspector_error_t;
}
extern "C" {
    #[doc = " Disconnects a webinspector client from the device and frees up the"]
    #[doc = " webinspector client data."]
    #[doc = ""]
    #[doc = " @param client The webinspector client to disconnect and free."]
    #[doc = ""]
    #[doc = " @return WEBINSPECTOR_E_SUCCESS on success, WEBINSPECTOR_E_INVALID_ARG when"]
    #[doc = "     client is NULL, or an WEBINSPECTOR_E_* error code otherwise."]
    pub fn webinspector_client_free(client: webinspector_client_t) -> webinspector_error_t;
}
extern "C" {
    #[doc = " Sends a plist to the service."]
    #[doc = ""]
    #[doc = " @param client The webinspector client"]
    #[doc = " @param plist The plist to send"]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client or plist is NULL"]
    pub fn webinspector_send(client: webinspector_client_t, plist: plist_t)
        -> webinspector_error_t;
}
extern "C" {
    #[doc = " Receives a plist from the service."]
    #[doc = ""]
    #[doc = " @param client The webinspector client"]
    #[doc = " @param plist The plist to store the received data"]
    #[doc = ""]
    #[doc = " @return DIAGNOSTICS_RELAY_E_SUCCESS on success,"]
    #[doc = "  DIAGNOSTICS_RELAY_E_INVALID_ARG when client or plist is NULL"]
    pub fn webinspector_receive(
        client: webinspector_client_t,
        plist: *mut plist_t,
    ) -> webinspector_error_t;
}
extern "C" {
    #[doc = " Receives a plist using the given webinspector client."]
    #[doc = ""]
    #[doc = " @param client The webinspector client to use for receiving"]
    #[doc = " @param plist pointer to a plist_t that will point to the received plist"]
    #[doc = "      upon successful return"]
    #[doc = " @param timeout_ms Maximum time in milliseconds to wait for data."]
    #[doc = ""]
    #[doc = " @return WEBINSPECTOR_E_SUCCESS on success,"]
    #[doc = "      WEBINSPECTOR_E_INVALID_ARG when client or *plist is NULL,"]
    #[doc = "      WEBINSPECTOR_E_PLIST_ERROR when the received data cannot be"]
    #[doc = "      converted to a plist, WEBINSPECTOR_E_MUX_ERROR when a"]
    #[doc = "      communication error occurs, or WEBINSPECTOR_E_UNKNOWN_ERROR"]
    #[doc = "      when an unspecified error occurs."]
    pub fn webinspector_receive_with_timeout(
        client: webinspector_client_t,
        plist: *mut plist_t,
        timeout_ms: u32,
    ) -> webinspector_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_data_private {}
#[test]
fn bindgen_test_layout_ssl_data_private() {
    assert_eq!(
        ::std::mem::size_of::<ssl_data_private>(),
        0usize,
        concat!("Size of: ", stringify!(ssl_data_private))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_data_private>(),
        1usize,
        concat!("Alignment of ", stringify!(ssl_data_private))
    );
}
pub type ssl_data_t = *mut ssl_data_private;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_connection_private {
    pub device: idevice_t,
    pub type_: idevice_connection_type,
    pub data: *mut ::std::os::raw::c_void,
    pub ssl_data: ssl_data_t,
    pub ssl_recv_timeout: ::std::os::raw::c_uint,
    pub status: idevice_error_t,
}
#[test]
fn bindgen_test_layout_idevice_connection_private() {
    assert_eq!(
        ::std::mem::size_of::<idevice_connection_private>(),
        40usize,
        concat!("Size of: ", stringify!(idevice_connection_private))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_connection_private>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_connection_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).type_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_connection_private>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).ssl_data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(ssl_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).ssl_recv_timeout as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(ssl_recv_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<idevice_connection_private>())).status as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_connection_private),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idevice_private {
    pub udid: *mut ::std::os::raw::c_char,
    pub mux_id: u32,
    pub conn_type: idevice_connection_type,
    pub conn_data: *mut ::std::os::raw::c_void,
    pub version: ::std::os::raw::c_int,
    pub device_class: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_idevice_private() {
    assert_eq!(
        ::std::mem::size_of::<idevice_private>(),
        32usize,
        concat!("Size of: ", stringify!(idevice_private))
    );
    assert_eq!(
        ::std::mem::align_of::<idevice_private>(),
        8usize,
        concat!("Alignment of ", stringify!(idevice_private))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).udid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(udid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).mux_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(mux_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).conn_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(conn_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).conn_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(conn_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idevice_private>())).device_class as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(idevice_private),
            "::",
            stringify!(device_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service_client_private {
    pub connection: idevice_connection_t,
}
#[test]
fn bindgen_test_layout_service_client_private() {
    assert_eq!(
        ::std::mem::size_of::<service_client_private>(),
        8usize,
        concat!("Size of: ", stringify!(service_client_private))
    );
    assert_eq!(
        ::std::mem::align_of::<service_client_private>(),
        8usize,
        concat!("Alignment of ", stringify!(service_client_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<service_client_private>())).connection as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(service_client_private),
            "::",
            stringify!(connection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct property_list_service_client_private {
    pub parent: service_client_t,
}
#[test]
fn bindgen_test_layout_property_list_service_client_private() {
    assert_eq!(
        ::std::mem::size_of::<property_list_service_client_private>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(property_list_service_client_private)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<property_list_service_client_private>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(property_list_service_client_private)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<property_list_service_client_private>())).parent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(property_list_service_client_private),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdownd_client_private {
    pub parent: property_list_service_client_t,
    pub ssl_enabled: ::std::os::raw::c_int,
    pub session_id: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
    pub device: idevice_t,
    pub cu_key: *mut ::std::os::raw::c_uchar,
    pub cu_key_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lockdownd_client_private() {
    assert_eq!(
        ::std::mem::size_of::<lockdownd_client_private>(),
        56usize,
        concat!("Size of: ", stringify!(lockdownd_client_private))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdownd_client_private>(),
        8usize,
        concat!("Alignment of ", stringify!(lockdownd_client_private))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_client_private>())).ssl_enabled as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(ssl_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_client_private>())).session_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).device as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lockdownd_client_private>())).cu_key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(cu_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockdownd_client_private>())).cu_key_len as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lockdownd_client_private),
            "::",
            stringify!(cu_key_len)
        )
    );
}
extern "C" {
    pub fn lockdown_check_result(
        dict: plist_t,
        query_match: *const ::std::os::raw::c_char,
    ) -> lockdownd_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
